/**
 * edoclite validation functions
 * http://www.quirksmode.org/js/introevents.html for background on javascript event quagmire
 *
 * How It All Works
 *
 * This script is called on page load (onPageLoad).  It will register onblur and onchange handlers (probably only
 * onblur is necessary at this time, but it started with just onchange) for fields which have been pre-registered
 * in java script blocks in the incoming document.  The pre-registration supplies a field name which must match a form
 * input name, a regular expression, and an optional error message.  The handlers will fire when the form fields
 * are tabbed-out and unhide a CSS-hidden message row on which a specific CSS style is set depending on warning or error,
 * to color the row appropriately.  A warning/error message is set in this row.  The secret row must have ids like:
 *
 * <fieldname>_message - the message element (typically a <span>)
 * <fieldname>_messageHeaderCell - the "header" cell of the message row (containing label warning/error)
 * <fieldname>_messageDataCell - the "data" cell of the message row (containing the actual message)
 * <fieldname>_messageRow - the entire row for any other decoration
 *
 * The CSS classes set on the header and data cells and message row, are respectively:
 *
 * <msgtype>_messageHeaderCell
 * <msgtype>_messageDataCell
 * <msgtype>_messageRow
 *
 * Where <msgtype> is either "warning", "error", or "empty" (which should just ensure that the elements are hidden regardless).
 *
 * A first-time pass at validation occurs on page load also, to ensure the user is notified ahead of time of field validation
 * requirements.  Fields which do NOT have validation requirements must be carefully omitted from pre-registration, so that fields
 * with outstanding errors generated by, for example, attributes, do NOT have their errors automatically implicitly cleared (the first
 * time pass would otherwise just default to an "accept-anything" regular expression, and immediately wipe out the error generated
 * on the server.  This underlines the importance of ensuring client-side JavaScript-based validation defined in the EDL document
 * is in sync with the ultimate attribute validation (or at least omitted to avoid false positive validation on the client side).
 *
 * Aaron Hamid (arh14 at cornell dot edu) 1/10/06
 */

// ---- globals

var nbsp = 160;    // non-breaking space char

var empty_regex = /^\s*$/;

var field_titles = new Object();
var field_regexes = new Object();
var field_errorMessages = new Object();
var field_validationRequired= new Object();
var field_customValidators = new Object();

var field_names = new Array;

// ---- utils

function setTextValue(id, text) {
    var element = document.getElementById(id);
    var node = element.firstChild;
    if (node == null) {
      node = document.createTextNode("");
      element.appendChild(node);
    }
    node.nodeValue = text;
}

function setClass(id, className) {
    document.getElementById(id).className = className;
}

// -----------------------------------------
//                  msg
// Display warn/error message in HTML element
// commonCheck routine must have previously been called
// -----------------------------------------

function setMessage(fld,     // id of element to display message in
             msgtype, // class to give element ("warn" or "error")
             message) // string to display
{
    if (!fld) {
        return;
    }
    // setting an empty string can give problems if later set to a
    // non-empty string, so ensure a space present. (For Mozilla and Opera one could
    // simply use a space, but IE demands something more, like a non-breaking space.)
    var dispmessage;
    if (empty_regex.test(message)) {
        dispmessage = String.fromCharCode(nbsp);
    } else {
        dispmessage = message;
    }

    // set the text value of the message
    setTextValue(fld + "_message", dispmessage);
    // set the text value of the message header cell
    setTextValue(fld + "_messageHeaderCell", msgtype+": ");
    // update messageHeaderCell class
    //setClass(fld + "_messageHeaderCell", msgtype + "_messageHeaderCell");
    // update messageDataCell class
    //setClass(fld + "_messageDataCell", msgtype + "_messageDataCell");
    // update the row class
    //setClass(fld + "_messageRow", msgtype + "_messageRow");
    setClass(fld + "_message", msgtype + "Message");
    setClass(fld+"_messageHeaderCell",msgtype+"Message");
}

function getTarget(event) {
    var target;
    if (event.target) target = event.target;
	  else if (event.srcElement) target = event.srcElement;
    if (target.nodeType == 3) // defeat Safari bug
		    target = target.parentNode;
    return target;
}

function registerHandlers() {
    //alert("Registering handlers");
    // register event handler
    for (var i in field_names) {
        var fieldName = field_names[i];
        //alert("registering handler for: " + fieldName);
        var element = document.getElementById('edoclite')[fieldName];
        if (element.length > 1) {
            // for radio buttons (all share the same name)
            for (var j = 0; j < element.length; j++) {
	            element[j].onchange = validate;
                element[j].onblur = validate;
            }
        }
        element.onchange = validate;
        element.onblur = validate;
        if (element.captureEvents) element.captureEvents(Event.CHANGE);
    }
}

/**
 * Registers an event handler in the "traditional" method
 * and fills in global regex, message, and validationRequired maps
 */
function register(name, title, regex, message, validationRequired) {
    //alert("registering " + name + " " + regex + " " + message + " " + validationRequired);
    field_names.push(name);

    // set the title for this field
    field_titles[name] = title;

    // set the regex for this field
    field_regexes[name] = regex;

    // set the error message for this field
    field_errorMessages[name] = message;

    // set the error message for this field
    field_validationRequired[name] = validationRequired == "true";

	// set the custom validator to be false
    field_customValidators[name] = false;
}

function register_custom(name, title, messages, validationRequired, validationFunction) {
    field_names.push(name)
    field_titles[name] = title;
    field_errorMessages[name] = messages;
    field_validationRequired[name] = validationRequired == "true";
    field_customValidators[name] = validationFunction;
}

function isValidationRequired(fieldName) {
    /*if (field_validationRequired[fieldName]) {
      alert("validation required: " + fieldName + " " + field_validationRequired[fieldName]);
    } else {
      //alert("validation NOT required: " + fieldName + " " + field_validationRequired[fieldName]);
    }*/
    return field_validationRequired[fieldName];
}

// ---- validation

function trim(string) {
    return string.replace(/^\s+/m, "") // strip leading
                 .replace(/\s+$/m, ""); // strip trailing
}

function isValid(element, regex, required, validator) {
    //alert("isValid: " + element);
    //alert("regex for " + element.name + ": " + regex);
    //alert("element value: '" + element.value + "'");
	var fieldValue = getFieldValue(fieldInputs);
    if (validator) {
        return validator(fieldValue);
    }
    if (regex == null || regex == "") {
        //alert("no regex for " + element.name);
        if (required) {
            //alert("element value: " + element.value);
            return fieldValue != null && trim(fieldValue).length > 0;
        } else {
            return true;
        }
    } else {
        return fieldValue.match(regex);
    }
    //return false;
}

//function validate(event, regex, message) {
function validate(event) {
    //alert("validate event: " + event);
    if (!event) var event = window.event;
    // event gives access to the event in all browsers
	var target = getTarget(event);
	var targetArray = new Array();
	targetArray[0] = target;
	var fieldName = getFieldName(targetArray);
    validateField(getFieldInputs(fieldName), fieldName);
}


function getFieldValue(fieldInputs) {
	if (fieldInputs.length > 1) {
		var type = fieldInputs[0].type;
		if (type == 'radio' || type == 'checkbox') {
			for (var i=0; i < fieldInputs.length; i++){
				if (fieldInputs[i].checked) {
					return fieldInputs[i].value;
				}
			}
		}
		throw 'Problem determining field value for inputs, type was: ' + type;
	}
	else {
		return fieldInputs[0].value;
	}
}


function getFieldName(fieldInputs) {
	if (fieldInputs.length > 1) {
		var type = fieldInputs[0].type;
		if (type == 'radio' || type == 'checkbox') {
			for (var i=0; i < fieldInputs.length; i++){
				if (fieldInputs[i].checked) {
					return fieldInputs[i].name;
				}
			}
		}
		throw 'Problem determining field name for inputs, type was: ' + type;
	}
	else {
		return fieldInputs[0].name;
	}
}


function validateField(fieldInputs, fieldName) {
    try {
        if (!field_customValidators[fieldName]) {
            var regex = field_regexes[fieldName];
            var required = isValidationRequired(fieldName);
            var valid = isValid(fieldInputs, regex, required, false);
        } else {
            var validator = field_customValidators[fieldNname]
            var required = isValidationRequired(fieldName);
            var valid = isValid(fieldInputs, "", required, validator)
        }
        var message = "";
        var type = "empty";

        if (!valid) {
            // set a color instead and then pop up summary alert on submit
            // if there are any fields which fail validation
            // but are required="true" in the bizdata
            message = field_errorMessages[fieldName];
            var error_element = document.getElementById(fieldName + "_message");
            if (error_element == null) {
                alert("Could not find error element by id: " + fieldName + "_message");
            } else {
              if (message.length == 0) {
                if (regex == null || regex == "") {
                    var title = field_titles[fieldName];
                    if (title == null) {
                        title = fieldName;
                    }
                    message = "field '" + title + "' is required";
                } else {
                  message = getFieldValue(fieldInputs) + " does not match " + regex;
                }
              }
              if (required) {
                type = "error";
              } else {
                type = "warning";
              }
            }
        }

    } catch (error) {
        message = "Error validating target " + fieldInputs + ": " + error;
        type = "error";
        valid = false;
    }
    setMessage(fieldName, type, message);
    return valid;
}

function validateForm() {
    var errs = 0;
    for (var i in field_names) {
        var fieldName = field_names[i];
        var fieldInputs = getFieldInputs(fieldName);
        // TODO: in the case that there is an error getting the field name or the field name returned by
        // getFieldName(...) does not match the field name above, we are going to suppress validation
        // of the field and continue with the next field.
        //
        // Currently, this is most likely to happen in the case of a "read only" field.  Because disabled
        // input fields are not submitted with the form, we added hidden fields in that case so that you
        // end up with something like the following:
        //
        // <input name="myField" type="hidden" value="..."><input name="myField" type="text" value="..." disabled>
        //
        // As we can see there are 2 input fields so both are returned by calls to getElementById which
        // results in getFieldName throwing an error.  Really, all of this javascript needs to be improved but
        // we need to get this fixed up prior to the 2.2.5 release of KEW and we don't have time to do
        // a hefty refactoring.
        try {
        	var calculatedFieldName = getFieldName(fieldInputs);
        	if (calculatedFieldName == null || calculatedFieldName != fieldName) {
        		continue;
        	}
        } catch (error) {
        	continue;
        }
        if (!validateField(fieldInputs, fieldName)) {
            if (isValidationRequired(fieldName)) {
                errs += 1;
            }
        }
    }
    return errs;
}

function getFieldInputs(fieldName) {
    var edocliteForm = document.getElementById('edoclite');
	var fieldInputs = new Array();
	for(var i = 0; i < edocliteForm.elements.length; i++) {
		if(edocliteForm.elements[i].name == fieldName) {
			fieldInputs[fieldInputs.length] = edocliteForm.elements[i];
		}
	}
	return fieldInputs;
}

function validateOnSubmit(form) {
    //alert("validating on submit");
    var errs = validateForm();
    //alert("Errs: " + errs);
    if (errs > 1)  alert('There are fields which require correction before sending');
    else if (errs == 1) alert('There is a field which requires correction before sending');

    return (errs == 0);
}

/**
 * Called when the page is loaded
 * Registers handlers for fields and then
 * performs an initial validation pass (but does not display alert dialog)
 */
function onPageLoad() {
    registerHandlers();
    // commented out for now
    // validateForm();
}