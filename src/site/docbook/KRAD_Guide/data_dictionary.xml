<?xml version='1.0' encoding='UTF-8'?>
<!--

    Copyright 2005-2012 The Kuali Foundation

    Licensed under the Educational Community License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.opensource.org/licenses/ecl2.php

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

--><chapter xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://docbook.org/ns/docbook" xml:id="data_dictionary" version="5.0">
  <title> The Data Dictionary </title>
  <section>
    <title> Introduction to the Data Dictionary </title>
    <para>The data dictionary is the main repository for metadata storage and provides the glue
            to combining classes related to a single piece of functionality. The data dictionary is
            specified in XML and allows for quick changes to be made to functionality. The Data
            Dictionary files use the Spring Framework for configuration so the notation and parsing
            operation will match that of the files that define the module configurers.</para>
    <para>The contents of the data dictionary are defined by two sets of vocabularies; the
            ‘business object’ and the ‘document’ data.</para>
    <section>
      <title>Recap</title>
      <itemizedlist>
        <listitem>
          <para>The Data Dictionary is a repository of metadata primarily describing data
                        objects and their properties</para>
        </listitem>
        <listitem>
          <para>Metadata is provided through Spring bean XML</para>
        </listitem>
        <listitem>
          <para>Use of Spring allows for easy overriding by implementers</para>
        </listitem>
        <listitem>
          <para>Data dictionary files are configured through the module
                        configuration</para>
        </listitem>
        <listitem>
          <para>Much functionality provided by the KRAD frameworks rely on the metadata
                        provided by the data dictionary</para>
        </listitem>
        <listitem>
          <para>In addition to describing data objects, the data dictionary is also used
                        to configure framework behavior (for example ‘business rule class’)</para>
        </listitem>
        <listitem>
          <para>The data dictionary beans are loaded into a separate Spring bean container
                        whose information can be accessed through the Data Dictionary Service</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>
  <section>
    <title> Attribute Definitions </title>
    <para>Attribute definitions are used to provide metadata about the attributes (i.e. fields)
            of a business object. The following is a sampling of attribute definitions from the
            CampusImpl business object data dictionary file:</para>
    <programlisting>
&lt;bean id=&quot;Campus-campusCode-parentBean&quot; abstract=&quot;true&quot; parent=&quot;AttributeDefinition&quot;&gt;
    &lt;property name=&quot;forceUppercase&quot; value=&quot;true&quot;/&gt;
    &lt;property name=&quot;shortLabel&quot; value=&quot;Campus Code&quot;/&gt;
    &lt;property name=&quot;maxLength&quot; value=&quot;2&quot;/&gt;
    &lt;property name=&quot;validationPattern&quot;&gt;
        &lt;bean parent=&quot;AlphaNumericValidationPattern&quot;/&gt;
    &lt;/property&gt;
    &lt;property name=&quot;required&quot; value=&quot;true&quot;/&gt;
    &lt;property name=&quot;control&quot;&gt;
        &lt;bean parent=&quot;TextControlDefinition&quot; p:size=&quot;2&quot;/&gt;
    &lt;/property&gt;
    &lt;property name=&quot;summary&quot; value=&quot;Campus Code&quot;/&gt;
    &lt;property name=&quot;name&quot; value=&quot;campusCode&quot;/&gt;
    &lt;property name=&quot;label&quot; value=&quot;Campus Code&quot;/&gt;
    &lt;property name=&quot;description&quot; value=&quot;The code uniquely identifying a particular campus.&quot;/&gt;
&lt;/bean&gt;
        </programlisting>
    <para>In client applications, it is common that several business objects share a field
            representing the same type of data. For example, a country’s postal code may occur in
            many different tables. In these circumstances, the use of a parent bean reference
            (parent=&quot;Country-postalCountryCode”) definition allows the reuse of parts of a standard
            definition from the &quot;master&quot; business object. For instance, the StateImpl business
            object (business object data dictionary file State.xml) references the postalCountryCode
            property of the CountryImpl (business object data dictionary file Country.xml). Because
            the postalCountryCode fields in StateImpl and CountryImpl are identical, a simple
            attribute definition bean in the Business Object data dictionary file (State.xml) can be
            used:</para>
    <programlisting>
&lt;bean id=&quot;State-postalCountryCode&quot; parent=&quot;Country-postalCountryCode-parentBean&quot;/&gt;</programlisting>
    <para>The definition of the
            Country-postalCountryCode-parentBean bean is seen inside the Country.xml file (for the
            CountryImpl business object):</para>
    <programlisting>
&lt;bean id=&quot;Country-postalCountryCode-parentBean&quot; abstract=&quot;true&quot; parent=&quot;AttributeDefinition&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;postalCountryCode&quot;/&gt;
    &lt;property name=&quot;forceUppercase&quot; value=&quot;true&quot;/&gt;
    &lt;property name=&quot;label&quot; value=&quot;Country Code&quot;/&gt;
    &lt;property name=&quot;shortLabel&quot; value=&quot;Country Code&quot;/&gt;
    &lt;property name=&quot;maxLength&quot; value=&quot;2&quot;/&gt;
    &lt;property name=&quot;validationPattern&quot;&gt;
        &lt;bean parent=&quot;AlphaNumericValidationPattern&quot;/&gt;
    &lt;/property&gt;
    &lt;property name=&quot;required&quot; value=&quot;true&quot;/&gt;
    &lt;property name=&quot;control&quot;&gt;
        &lt;bean parent=&quot;TextControlDefinition&quot; p:size=&quot;2&quot;/&gt;
    &lt;/property&gt;
    &lt;property name=&quot;summary&quot; value=&quot;Postal Country Code&quot;/&gt;
    &lt;property name=&quot;description&quot; value=&quot;The code uniquely identify a country.&quot;/&gt;
&lt;/bean&gt;
        </programlisting>
    <section>
      <title>Recap</title>
      <itemizedlist>
        <listitem>
          <para>An Attribute Definition provides metadata about a single data object
                        property</para>
        </listitem>
        <listitem>
          <para>Created with a bean whose parent is “AttributeDefinition” (or another
                        attribute definition bean)</para>
        </listitem>
        <listitem>
          <para>Properties that can be configured include:<itemizedlist>
              <listitem>
                <para>name (required) – name of the property on the data object the
                                    definition describes</para>
              </listitem>
              <listitem>
                <para>label – label text to use when rendering the property</para>
              </listitem>
              <listitem>
                <para>shortLabel – short label text to use when rendering the
                                    property</para>
              </listitem>
              <listitem>
                <para>minLength/maxLength – min and max length a value for this
                                    property can have</para>
              </listitem>
              <listitem>
                <para>required – whether a value for this property is always
                                    required (usually refers to persistence requiredness)</para>
              </listitem>
              <listitem>
                <para>validationPattern – a validation constraint that applies to
                                    any property value</para>
              </listitem>
              <listitem>
                <para>controlField (and control) – the control component to use by
                                    default when rendering the property</para>
              </listitem>
              <listitem>
                <para>summary/description – help information for the property</para>
              </listitem>
            </itemizedlist></para>
        </listitem>
      </itemizedlist>
    </section>
  </section>
  <section>
    <title> Data Object and Business Object Entries </title>
    <para>Data Object entries provide the KRAD framework extra metadata about a data object
            which is not provided by the persistence mapping or the class itself.</para>
    <para>The data object entry contains information about:<itemizedlist>
        <listitem>
          <para>Descriptive labels for each attribute in the data object (data dictionary
                        terminology uses the term “attribute” to refer to fields with getter/setter
                        methods)</para>
        </listitem>
        <listitem>
          <para>Primary keys for the data object</para>
        </listitem>
        <listitem>
          <para>Metadata about each attribute </para>
        </listitem>
        <listitem>
          <para>How input fields on HTML pages should be rendered for an attribute (e.g.
                        textbox, drop down, etc.)</para>
        </listitem>
        <listitem>
          <para>Relationships and collections that exists for the data object</para>
        </listitem>
      </itemizedlist></para>
    <para>The following is an example of a data object entry:</para>
    <programlisting>&#160; 
&lt;bean id=&quot;Book&quot; parent=&quot;Book-parentBean&quot;/&gt;
&lt;bean id=&quot;Book-parentBean&quot; abstract=&quot;true&quot; parent=&quot;DataObjectEntry&quot;&gt;
    &lt;property name=&quot;dataObjectClass&quot; value=&quot;edu.sampleu.bookstore.bo.Book&quot;/&gt;
    &lt;property name=&quot;objectLabel&quot; value=&quot;Book&quot;/&gt;
    &lt;property name=&quot;collections&quot;&gt;
        &lt;list&gt;
            &lt;bean parent=&quot;CollectionDefinition&quot; p:name=&quot;authors&quot; p:label=&quot;Authors&quot; p:shortLabel=&quot;Authors&quot; p:elementLabel=&quot;Author&quot;/&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name=&quot;attributes&quot;&gt;
        &lt;list&gt;
            &lt;ref bean=&quot;Book-id&quot;/&gt;
            &lt;ref bean=&quot;Book-title&quot;/&gt;
            &lt;ref bean=&quot;Book-typeCode&quot;/&gt;
            &lt;ref bean=&quot;Book-isbn&quot;/&gt;
            &lt;ref bean=&quot;Book-publisher&quot;/&gt;
            &lt;ref bean=&quot;Book-publicationDate&quot;/&gt;
            &lt;ref bean=&quot;Book-price&quot;/&gt;
            &lt;ref bean=&quot;Book-rating&quot;/&gt;
            &lt;ref bean=&quot;Book-bookType-name&quot;/&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name=&quot;titleAttribute&quot; value=&quot;id&quot;/&gt;
    &lt;property name=&quot;primaryKeys&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;id&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
        </programlisting>
    <section>
      <title>Recap</title>
      <itemizedlist>
        <listitem>
          <para>A Data Object (or Business Object) Entry provides metadata about a data
                        object</para>
        </listitem>
        <listitem>
          <para>Created with a bean whose parent is “DataObjectEntry” (or extending
                        another data object entry bean)</para>
        </listitem>
        <listitem>
          <para>Properties that can be configured include:</para>
          <itemizedlist>
            <listitem>
              <para>dataObjectClass(required) – full classname for the data object
                                    being described</para>
            </listitem>
            <listitem>
              <para>objectLabel – label text to use when rendering a data object
                                    record</para>
            </listitem>
            <listitem>
              <para>dataObjectClass(required) – full classname for the data object
                                    being described</para>
            </listitem>
            <listitem>
              <para>objectLabel – label text to use when rendering a data object
                                    record</para>
            </listitem>
            <listitem>
              <para>primaryKeys – list of property names that make up the primary
                                    keys</para>
            </listitem>
            <listitem>
              <para>titleAttribute – name of the property to use as a record
                                    identifier </para>
            </listitem>
            <listitem>
              <para>attributes – list of attribute definitions for properties
                                    contained in the data object</para>
            </listitem>
            <listitem>
              <para>relationships/collections – list of relationship (1-1) and
                                    collection (1-many) definitions for the data object</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
    </section>
  </section>
  <section>
    <title> Relationship and Collection Definitions </title>
    <para>Coming Soon!</para>
<!--TODO: Add content here
         -->  </section>
  <section>
    <title> Constraints </title>
    <para>Constraints define what the acceptable values for a field are.&#160; </para>
    <para>There are a variety of constraints that can be defined at either the InputField level
            or the AttributeDefinition level.&#160; These constraints go by the exact same property name
            at both levels.&#160; Keep in mind that constraints defined at the InputField level always
            override those at the AttributeDefinition level (when the field is backed by an
            AttributeDefinition).</para>
    <para>Constraints are applied during a process called Validation.&#160; Validation can occur on
            the client during user input, on the server during a submit process, or both.&#160; By
            default, client-side validation is on and server-side validation is off for FormViews in
            Rice 2.0.</para>
    <para>Some constraints mimic those that were in available in the Rice KNS framework and go
            by similar names.&#160; To help identify which constraints are new and should be used to
            build KRAD compatible InputFields and AttributeDefinitions, the constraints are all
            followed by a suffix in both their bean and java class names of “Constraint”.</para>
    <para>All constraints are enforced client-side during validation, unless noted below. </para>
    <section>
      <title>Simple Constraint Properties</title>
      <para><emphasis role="bold">Required</emphasis></para>
      <para>Property: required</para>
      <para>Values: true if required otherwise false</para>
      <para>When a field is required, the field must have some inpute value to be considered
                valid - it</para>
      <programlisting>
&lt;bean parent=&quot;Uif-InputField&quot; p:required=&quot;true&quot; p:propertyName=&quot;field1&quot;&gt;...&lt;/bean&gt;</programlisting>
      <para><emphasis role="bold">MinLength</emphasis></para>
      <para>Property: minLength</para>
      <para>Values: integer, 0 or greater</para>
      <para>When a minLength is set, the input value’s character length cannot be less than
                minLength.</para>
      <para><emphasis role="bold">MaxLength</emphasis></para>
      <para>Property: maxLength</para>
      <para>Values: integer - 0 or greater</para>
      <para>When a maxLength is set, the input value’s character length cannot be greater than
                maxLength.&#160; MaxLength should be set to a greater value than minLength (if
                set).</para>
      <programlisting>
&lt;bean parent=&quot;Uif-InputField&quot; p:minLength=&quot;1&quot; p:maxLength=&quot;8&quot;&#160;p:propertyName=&quot;field1&quot;&gt;...&lt;/bean&gt;</programlisting>
      <para><emphasis role="bold">ExclusiveMin</emphasis></para>
      <para>Property: exclusiveMin</para>
      <para>Values: String representing a number or date value</para>
      <para>When exclusiveMin is set to a number, and the input’s value is a number, that
                number must be greater than exclusiveMin. If exclusiveMin is set to a date, and the
                input’s value is a date, that date must be greater than exclusiveMin.&#160; Note that for
                dates, exclusiveMin validation is <emphasis role="italic">not enforced client-side</emphasis>, but the DatePicker widget will limit date selection
                based on this value (though the widget will limit min inclusively - not exclusively
                - so values should still be checked server-side).</para>
      <para><emphasis role="bold">InclusiveMax</emphasis></para>
      <para>Property: inclusiveMax</para>
      <para>Values: String representing a number or date value</para>
      <para>When inclusiveMax is set to a number and the input’s value is a number, that
                number must be less than, or equal to, inclusiveMax. If inclusiveMax is set to a
                date and the input’s value is a date, that date must be less than, or equal to,
                inclusiveMax.&#160; Note that for dates, inclusiveMin validation is <emphasis role="italic">not enforced client-side</emphasis>, but the DatePicker widget
                will limit date selection based on this value.</para>
      <programlisting>
&lt;bean parent=&quot;Uif-InputField&quot; p:exclusiveMin=&quot;0&quot; p:inclusiveMax=&quot;500&quot;&#160;p:propertyName=&quot;field1&gt;...&lt;/bean&gt;</programlisting>
      <para><emphasis role="bold">dataType</emphasis></para>
      <para>Property: dataType</para>
      <para>Values: STRING, MARKUP, DATE, TRUNCATED_DATE, BOOLEAN, INTEGER, FLOAT, DOUBLE,
                LONG, DATETIME</para>
      <para>When dataType is set to one of the above types, it checks to see if the input’s
                value can be converted into that type.&#160; This is <emphasis role="italic">not enforced client-side</emphasis> and can only be enforced during server-side
                validation.</para>
      <programlisting>
&lt;bean parent=&quot;Uif-InputField&quot; p:dataType=&quot;INTEGER&quot; p:propertyName=&quot;field1&quot;&gt;...&lt;/bean&gt;</programlisting>
      <para><emphasis role="bold"> minOccurs/maxOccurs </emphasis></para>
      <para>This constraint is not yet fully supported.&#160; The name and location may change in
                the future.&#160; Future intended use is to constrain total collection items in a
                collection.</para>
      <section>
        <title>SimpleConstraint</title>
        <para>The SimpleConstraint class is a constraint that contains all of the simple
                    constraint properties (identified above) within it.&#160; These are:</para>
        <itemizedlist>
          <listitem>
            <para>required</para>
          </listitem>
          <listitem>
            <para>maxLength</para>
          </listitem>
          <listitem>
            <para>minLength</para>
          </listitem>
          <listitem>
            <para>exclusiveMin</para>
          </listitem>
          <listitem>
            <para>inclusiveMax</para>
          </listitem>
          <listitem>
            <para>dataType</para>
          </listitem>
          <listitem>
            <para>minOccurs/maxOccurs</para>
          </listitem>
        </itemizedlist>
        <para>The SimpleContraint is used within InputField to store the settings you can
                    set directly through its simple constraint properties.&#160; SimpleConstraint itself
                    can also be set directly on the InputField bean and will override all settings
                    that may have been set through a simple constraint property on InputField.&#160;
                    Beyond this usage, SimpleConstraints main role is to allow the usage of simple
                    constraints in CaseConstraints.</para>
      </section>
      <section>
        <title>Complex Constraints</title>
        <para>The rest of the constraints allow more complex validation to occur on input
                    values.&#160; All of these constraints allow the setting of a labelKey property if
                    you would like to redefine the message that is shown when validation encounters
                    an error.&#160; By default, all complex constraints already have a message predefined
                    with parameters generated for that message, and it is recommended you use the
                    already defined messages in most cases, except for a few when noted below.&#160; The
                    base beans for all of the following constraints are defined in
                    DataDictionaryBaseTypes.xml.</para>
      </section>
    </section>
    <section>
      <title>Validation Patterns</title>
      <para>ValidCharacterConstraints allow you to constrain the allowed input on a field
                    to a set combination of characters by using regex (Regular Expressions).&#160; There
                    are a variety of predefined ValidCharacterConstraints available in KRAD, but the
                    ability to easily create your own is available as well using standard regex.&#160; A
                    ValidCharacterConstraint is set through the validCharacterConstraint property on
                    either an InputField or AttributeDefinition.&#160; This constraint mimics, but
                    enhances, constraints available in the original KNS called ValidationPatterns.&#160;
                        <emphasis role="italic">However, do not use ValidationPatterns in KRAD as they are deprecated and no longer used.</emphasis></para>
      <programlisting>
&lt;bean parent=&quot;Uif-InputField&quot; p:propertyName=&quot;field62&quot;&gt;
    &lt;property name=&quot;validCharactersConstraint&quot;&gt;
        &lt;bean parent=&quot;AlphaNumericPatternConstraint&quot; /&gt;
    &lt;/property&gt;
&lt;/bean&gt;
                </programlisting>
      <para>The predefined beans for ValidCharacterConstraint are:</para>
      <para><emphasis role="bold">AlphaNumericPatternConstraint</emphasis></para>
      <para>Only alphabetic and numeric characters allowed.</para>
      <para><emphasis role="bold">AlphaPatternConstraint</emphasis></para>
      <para>Only alphabetic characters allowed.</para>
      <para><emphasis role="bold">AnyCharacterPatternConstraint</emphasis></para>
      <para>Only keyboard characters are allowed.&#160; Specifically, these are ASCII
                    characters x21 through x7E in hexadecimal.&#160; Whitespace is not allowed by default
                    unless enabled through the allowWhitespace flag.</para>
      <para><emphasis role="bold">CharsetPatternConstraint</emphasis></para>
      <para>Allows any characters set through its validCharacters property.</para>
      <para><emphasis role="bold">NumericPatternConstraint</emphasis></para>
      <para>Only numeric characters allowed.</para>
      <para><emphasis role="bold">AlphaNumericWithBasicPunc</emphasis></para>
      <para>Only alphabetic and numeric characters with whitespace, question marks,
                    exclamation points, periods, parentheses, double quotes, apostrophes, forward
                    slashes, dashes, colons, and semi-colons allowed.&#160; This is an additional
                    configuration of AlphaNumericPatternConstraint with some “allow” flags turned
                    on.</para>
      <para><emphasis role="bold">AlphaWithBasicPunc</emphasis></para>
      <para>Only alphabetic characters with whitespace, question marks, exclamation
                    points, periods, parentheses, double quotes, apostrophes, forward slashes,
                    dashes, colons, and semi-colons allowed.&#160; This is an additional configuration of
                    AlphaPatternConstraint with some “allow” flags turned on.</para>
      <para><emphasis role="bold">NumericWithOperators</emphasis></para>
      <para>Only numeric characters with whitespace, asterisks, pluses, periods,
                    parentheses, forward slashes, dashes, and equals signs, dashes allowed.&#160; This is
                    an additional configuration of NumericPatternConstraint with some “allow” flags
                    turned on.</para>
      <para><emphasis role="bold">FixedPointPatternConstraint</emphasis></para>
      <para>Only allows a numeric value where the precision property represents the
                    maximum number of numbers allowed, and scale represents the maximum numbers
                    after the decimal point.&#160; For example, a FixedPointPatternConstraint with
                    precision 5 and scale 2 would allow: 2, 555, 555.11; but would not allow:
                    111.222, 1.222, 5555 (this is actually the value 5555.00, so it is not
                    allowed).</para>
      <para><emphasis role="bold">IntegerPatternConstraint</emphasis></para>
      <para>Allows any valid integer (but does not restrict length or range).&#160; There are
                    optional flags for allowing negative integers, only negative integers, or not
                    allowing zero as input.</para>
      <para><emphasis role="bold">DatePatternConstraint</emphasis></para>
      <para>Allows any date to be input that is a valid date in the system.&#160; Any format
                    defined in the configuration parameter “STRING_TO_DATE_FORMATS” is
                    allowed.</para>
      <para><emphasis role="bold">BasicDatePatternConstraint</emphasis></para>
      <para>Allows a subset of the default date formats defined by DatePatternConstraint.&#160;
                    These formats represent the most common input for date values: MM/dd/yy,
                    MM/dd/yyyy, MM-dd-yy, and MM-dd-yyyy.&#160; It is recommended that this constraint be
                    used on fields which use the DatePicker widget.</para>
      <para><emphasis role="bold">ConfigurationBasedRegexPatternConstraint</emphasis></para>
      <para>The following constraints are configurations of the
                    ConfigurationBasedRegexPatternConstraint which have a patternConstraintKey that
                    is used to retrieve a regex pattern by key in ApplicationResources.properties
                    (or any other imported properties file).&#160; This differs from the above
                    ValidCharactersConstraints because those generate their regex based on flags and
                    options set on them.&#160; These constraints can easily have their functionality
                    modified by changing the regex they use in any imported properties file.</para>
      <tip>
        <title>Custom Regex Constraints</title>
        <para>You can easily define your own ConfigurationBasedRegexPatternContraint
                        bean by setting your own labelKey and patternConstraintKey to something that
                        you have defined in a properties file. </para>
      </tip>
      <para><emphasis role="bold">FloatingPointPatternConstraint</emphasis></para>
      <para>patternConstraintKey: validationPatternRegex.floatingPoint</para>
      <para>Allows any valid floating point value (does not limit length or range).&#160; In
                    other words, any number which may include a decimal point.</para>
      <para><emphasis role="bold">PhoneNumberPatternConstraint</emphasis></para>
      <para>patternConstraintKey: validationPatternRegex.phoneNumber</para>
      <para>Allows any valid US phone number in this format: ###-###-####.</para>
      <para><emphasis role="bold">TimePatternConstraint</emphasis></para>
      <para>patternConstraintKey: validationPatternRegex.time12</para>
      <para>Allows any valid time in 12 hour format, seconds and leading 0 are
                    optional.</para>
      <para><emphasis role="bold">Time24HPatternConstraint</emphasis></para>
      <para>patternConstraintKey: validationPatternRegex.time24</para>
      <para>Allows any valid time in 24 hour format, seconds and leading 0 are
                    optional.</para>
      <para><emphasis role="bold">UrlPatternConstraint</emphasis></para>
      <para>patternConstraintKey: validationPatternRegex.url</para>
      <para>Allows any valid url; the prefixes http://, https://, or ftp:// are
                    required.</para>
      <para><emphasis role="bold">NoWhitespacePatternConstraint</emphasis></para>
      <para>patternConstraintKey: validationPatternRegex.noWhitespace</para>
      <para>Any characters except for whitespace are allowed.</para>
      <para><emphasis role="bold">JavaClassPatternConstraint</emphasis></para>
      <para>patternConstraintKey: validationPatternRegex.javaClass</para>
      <para>Only values that would be valid java class names are allowed.</para>
      <para><emphasis role="bold">EmailAddressPatternConstraint</emphasis></para>
      <para>patternConstraintKey: validationPatternRegex.emailAddress</para>
      <para>Only valid email addresses are allowed.</para>
      <para><emphasis role="bold">TimestampPatternConstraint</emphasis></para>
      <para>patternConstraintKey: validationPatternRegex.timestamp</para>
      <para>Only valid timestamp values are allowed.</para>
      <para><emphasis role="bold">YearPatternConstraint</emphasis></para>
      <para>patternConstraintKey: validationPatternRegex.year</para>
      <para>Any year from the 1600s to the 2100s is allowed.</para>
      <para><emphasis role="bold">MonthPatternConstraint</emphasis></para>
      <para>patternConstraintKey: validationPatternRegex.month</para>
      <para>Any valid month, by number, is allowed.</para>
      <para><emphasis role="bold">ZipcodePatternConstraint</emphasis></para>
      <para>patternConstraintKey: validationPatternRegex.zipcode</para>
      <para>Any valid US zip code, with or without its 4 number postfix, is
                    allowed.</para>
    </section>
    <section>
      <title>Custom Validation Patterns</title>
      <para>In addition to the above defined ValidCharacterConstraints, you can define
                    your own ValidCharactersConstraint by defining the regex property “value”
                    directly.&#160; This is an additional configuration option, similar to defining a
                    custom ConfigurationBasedRegexPatternConstraint, the only difference being that
                    the regex value is defined at the bean level and in a
                    ConfigurationBasedRegexPatternConstraint it is defined in an imported properties
                    file.&#160; Both custom configurations must have a labelKey defined.</para>
      <programlisting>
&lt;bean parent=&quot;Uif-InputField&quot; p:instructionalText=&quot;custom valid characters
    constraint - this one accepts only 1 alpha character followed by a period&#160; and
    then followed by a number (a.8, b.0, etc)&quot; p:propertyName=&quot;field1&quot;&gt;
    &lt;property name=&quot;validCharactersConstraint&quot;&gt;
        &lt;bean parent=&quot;ValidCharactersConstraint&quot; p:value=&quot;<emphasis role="bold">^[a-zA-Z]\.[0-9]$&quot;</emphasis>
            p:labelKey=&quot;validation.aDotNumTest&quot;/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
                </programlisting>
    </section>
    <section>
      <title>Prerequisite Constraints</title>
      <para>A prerequisite constraint defines what fields must be filled out with this
                    field (the field that the PrerequisiteConstraint is defined on).&#160;&#160; When this
                    field is filled out, it requires the field set in the “propertyName” property of
                    the PrerequisiteConstraint to be filled out as a result.&#160; </para>
      <para>During client-side validation, whether that field comes after or before that
                    field is irrelevant, as the UI will only notify the user when appropriate.&#160; For
                    example, if you haven’t yet visited a field that is now required, the user will
                    only be notified of an error after they have first visited this newly required
                    field and have not filled it out.&#160; Alternatively, if the field that is now
                    required comes before the field that requires it, the user will be notified
                    immediately.&#160; These mechanisms are set up to prevent the UI from showing errors
                    before the user had a chance to interact with the corresponding field within the
                    overall page flow.</para>
      <para>A field can have any number of PrerequisiteConstraints in their
                    “dependencyConstraints” property. </para>
      <programlisting>
&lt;bean parent=&quot;Uif-InputField&quot; p:propertyName=&quot;field1&quot; &gt;
    &lt;property name=&quot;dependencyConstraints&quot;&gt;
        &lt;list&gt;
            &lt;bean parent=&quot;PrerequisiteConstraint&quot; p:propertyName=&quot;field7&quot;/&gt;
            &lt;bean parent=&quot;PrerequisiteConstraint&quot; p:propertyName=&quot;field8&quot;/&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
                </programlisting>
      <tip>
        <title>Prerequisite Constraints</title>
        <para>A useful and common technique is to put a&#160;prerequisite constraint on both
                        fields that may require each other (example case: a measurement requires
                        both a value and a unit, neither make sense without the other).&#160;&#160; </para>
      </tip>
    </section>
    <section>
      <title>Must Occur Constraints</title>
      <para>MustOccurConstraint is used to identify fields that are required before this
                    field can be filled out.&#160; This is different from PrerequisiteConstraints because
                    the number of fields required from different set of fields can be
                    defined.</para>
      <para>MustOccurConstraints have a min and max property.&#160; This defines how many
                    PrerequisiteConstraints defined in its “prerequisiteConstraints” property, in
                    combination with, the MustOccurConstraints defined its “mustOccurConstraints”
                    property must be satisfied to satisfy this overall MustOccurConstraint.&#160;
                    Essentially, either a satisfied PrerequisiteConstraint or a satisfied
                    MustOccurConstraint counts as one toward the min/max.&#160; By using these in
                    combination you can define different sets of fields that are required by the
                    field using its MustOccurConstraint.</para>
      <para>The following MustOccurConstraint is valid when field11 has a value, or is
                    valid when both field12 and field13 has a value (min=”2” and max=”2” in the
                    nested MustOccursConstraint enforces that both must be filled out).&#160; However, in
                    this case, filling out all three fields is also valid because of min=”1” and
                    max=”2” on the top level constraint (there is one PrerequisiteConstraint and one
                    MustOccursConstraint at the top level).&#160; Alternatively, setting a max=”1” at the
                    top level would make this constraint only allow one of the two conditions to be
                    satisfied (otherwise, it would be invalid).</para>
      <programlisting>
&lt;bean parent=&quot;Uif-InputField&quot; p:propertyName=&quot;field1&quot;&gt;
    &lt;property name=&quot;mustOccurConstraints&quot;&gt;
        &lt;list&gt;
            &lt;bean parent=&quot;MustOccurConstraint&quot;&gt;
                &lt;property name=&quot;min&quot; value=&quot;1&quot; /&gt;
                &lt;property name=&quot;max&quot; value=&quot;2&quot; /&gt;
                    &lt;property name=&quot;prerequisiteConstraints&quot;&gt;
                        &lt;list&gt;
                            &lt;bean parent=&quot;PrerequisiteConstraint&quot; p:propertyName=&quot;field11&quot;/&gt;
                        &lt;/list&gt;
                    &lt;/property&gt;
                &lt;property name=&quot;mustOccurConstraints&quot;&gt;
                    &lt;list&gt;
                        &lt;bean parent=&quot;MustOccurConstraint&quot;&gt;
                            &lt;property name=&quot;min&quot; value=&quot;2&quot; /&gt;
                            &lt;property name=&quot;max&quot; value=&quot;2&quot; /&gt;
                            &lt;property name=&quot;prerequisiteConstraints&quot;&gt;
                                &lt;list&gt;
                                    &lt;bean parent=&quot;PrerequisiteConstraint&quot; p:propertyName=&quot;field12&quot; /&gt;
                                    &lt;bean parent=&quot;PrerequisiteConstraint&quot; p:propertyName=&quot;field13&quot; /&gt;
                                &lt;/list&gt;
                            &lt;/property&gt;
                        &lt;/bean&gt;
                    &lt;/list&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
                </programlisting>
      <note>
        <title>Must Occurs Constraint Message</title>
        <para>Because of the complexity that some&#160;MustOccurConstraints can achieve, the
                        message generated by MustOccurConstraint by default may not always be
                        accurate or easy to understand.&#160; It is recommended that you define your own
                        labelKey for complex MustOccurConstraints. </para>
      </note>
    </section>
    <section>
      <title>Case Constraints</title>
      <para>A CaseConstraint provides the ability to only apply a certain constraint when a
                defined case/condition is satisfied.&#160; The constraint or constraints used can be any
                of the above constraints, in addition to nesting another CaseConstraint within
                itself. </para>
      <para>CaseConstraint has the following properties:</para>
      <para>propertyName - the name of the field the case is using in the condition.</para>
      <para>operator - the name of the operator to use in the condition.&#160; By default, this
                operator is EQUALS.&#160; Other operators available are NOT_EQUAL, GREATER_THAN_EQUAL,
                LESS_THAN_EQUAL, GREATER_THAN, LESS_THAN, and HAS_VALUE (the field defined in
                propertyName just has to have any value to trigger the case constraint when
                HAS_VALUE is used).</para>
      <para>caseSensitive - set this to true if the condition should be caseSensitive when
                comparing values.</para>
      <para>WhenConstraint list -&#160; a list of WhenConstraints which define the values for the
                condition to be satisfied.&#160; If one of the values in the “values” property satisfies
                the condition, the constraint defined in this WhenConstraint is applied to this
                field.&#160; Note that the value can also be the value of another field defined by the
                “valuePath” property – however, this does not work client-side in this release.&#160; The
                WhenConstraint also defines the “constraint” to be applied if the condition is
                satisfied with that value.</para>
      <para>In order to define an “ANDed” CaseConstraint, nest another CaseConstraint into a
                WhenConstraint property.&#160; Alternatively, defining multiple WhenConstraints define an
                “ORed” CaseConstraint.&#160; Also, to apply multiple constraints for one value use
                multiple WhenConstraints with the same value defined.</para>
      <para>The following code makes field1 required when field2 is equal to “valueA” or
                “valueB”.&#160; It also makes field1 only allow alphanumeric input when field2 is equal
                to “valueA”.</para>
      <programlisting>
&lt;bean parent=&quot;Uif-InputField&quot; p:propertyName=&quot;field1&quot;&gt;
    &lt;property name=&quot;caseConstraint&quot;&gt;
        &lt;bean parent=&quot;CaseConstraint&quot;&gt;
            &lt;property name=&quot;propertyName&quot; value=&quot;field2&quot; /&gt;
            &lt;property name=&quot;whenConstraint&quot;&gt;
                &lt;list&gt;
                    &lt;bean parent=&quot;WhenConstraint&quot;&gt;
                        &lt;property name=&quot;values&quot;&gt;
                            &lt;list&gt;
                                &lt;value&gt;valueA&lt;/value&gt;
                                &lt;value&gt;valueB&lt;/value&gt;
                            &lt;/list&gt;
                        &lt;/property&gt;
                        &lt;property name=&quot;constraint&quot;&gt;
                            &lt;bean parent=&quot;RequiredConstraint&quot; /&gt;
                        &lt;/property&gt;
                    &lt;/bean&gt;
                    &lt;bean parent=&quot;WhenConstraint&quot;&gt;
                        &lt;property name=&quot;value&quot; value=&quot;valueA&quot; /&gt;
                        &lt;property name=&quot;constraint&quot;&gt;
                            &lt;bean parent=&quot;AlphaNumericPatternConstraint&quot; /&gt;
                        &lt;/property&gt;
                    &lt;/bean&gt;
                &lt;/list&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;
            </programlisting>
    </section>
    <section>
      <title>State-based Validation and Constraints</title>
      <para>State-Based Validation
State based validation allows you to change what validations (in other words, what Constraints) are applied to an object’s fields as it moves through states over time, through user interaction, or any other mechanism that may affect a “state” of an object.  One example of states in practice is workflow status.
</para>
      <para>If you do not setup states, the view is considered stateless and all Constraints that you setup will apply at all times (note: this behavior is unchanged from prior releases).
</para>
      <para><emphasis role="bold">To setup state-based validation you must set the stateMapping property with a StateMapping object.</emphasis> <emphasis role="bold"> The object MUST include a list of states and these states MUST be in order that the states are changed.</emphasis> </para>
      <para> In addition to the states themselves, you can define a map for specifying what the state’s name will be in the text of validation messages.  The map <emphasis role="bold">stateNameMessageKeyMap</emphasis> takes the state as a key and a messageKey as a value for its entries.  The messageKey is used to retrieve the human readable version of the message from the ConfigurationService.
</para>
      <para>The <emphasis role="bold">statePropertyName</emphasis> property of StateMapping allows you to specify the name/path to the property on the form which represents the state.  By default this is set to “state” (meaning on the root form UifFormBase, stateMapping will use the “state” property to determine the state of the object).  This can be changed to anything and is used with the new property of View called stateObjectBindingPath (the path to the “state” property will be determined as stateObjectBindingPath + statePropertyName).
</para>
      <para>The <emphasis role="bold">customClientSideValidationStates</emphasis> property is used strictly to define what state the client-side validation (see corresponding section) should use to validate during user interaction.  By default, client-side validation will always validate against the “n+1” state.  What that means is that client-side validation will always validate against the NEXT state (if one exists, otherwise the current state) of the object because that is what the user is trying to get to. </para>
      <para>To change this behavior the customClientSideValidationStates map can be used to define what client-side validation will be used at each state.  Its entries take the state of the object as the key and the state you want the client-side validation to validate against at that state as the value.  States which don’t have a custom client-side validation state default to the “n+1” case, as normal.</para>
      <para>Example of stateMapping with some of these properties set (note that state names themselves are for example purposes only):</para>
      <para><programlisting>   &lt;property name=&quot;stateMapping&quot;&gt;
      &lt;bean parent=&quot;StateMapping&quot;&gt;
        &lt;property name=&quot;states&quot;&gt;
          &lt;list&gt;
            &lt;value&gt;state1&lt;/value&gt;
            &lt;value&gt;state2&lt;/value&gt;
            &lt;value&gt;state3&lt;/value&gt;
            &lt;value&gt;state4&lt;/value&gt;
            &lt;value&gt;state5&lt;/value&gt;
          &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name=&quot;stateNameMessageKeyMap&quot;&gt;
          &lt;map&gt;
            &lt;entry key=&quot;state1&quot; value=&quot;demo.state1&quot;/&gt;
            &lt;entry key=&quot;state2&quot; value=&quot;demo.state2&quot;/&gt;
            &lt;entry key=&quot;state3&quot; value=&quot;demo.state3&quot;/&gt;
            &lt;entry key=&quot;state4&quot; value=&quot;demo.state4&quot;/&gt;
            &lt;entry key=&quot;state5&quot; value=&quot;demo.state5&quot;/&gt;
          &lt;/map&gt;
        &lt;/property&gt;
        &lt;property name=&quot;customClientSideValidationStates&quot;&gt;
          &lt;map&gt;
            &lt;entry key=&quot;state1&quot; value=&quot;state3&quot;/&gt;
          &lt;/map&gt;
        &lt;/property&gt;
      &lt;/bean&gt;
    &lt;/property&gt;</programlisting></para>
      <para>This example has 5 states, it defines a message key  for each state, and for client-side validation when the view&apos;s object is in &quot;state1&quot; the client will validate against &quot;state3&quot; (it will also validate against &quot;state3&quot; in &quot;state2&quot; as normal).  It is retrieving the current state of the object from the &quot;state&quot; property at the root of the form (default).</para>
      <para>StateMapping also has some helpert methods that can be called:</para>
      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">getCurrentState</emphasis> retrieves what is the current state of the object this stateMapping is for</para>
        </listitem>
        <listitem>
          <para><emphasis role="bold">getNextState</emphasis> which gets the next expected state (this does not take into account customClientSideValidationStates).
</para>
        </listitem>
      </itemizedlist>
      <para>After you have the StateMapping object defined, you need to define states on your validation constraints to use state-based validation. </para>
      <para><section>
          <title>Defining Constraint state Information</title>
        </section>Constraints without states defined fallback to “stateless” and will always apply for all states.
BaseConstraints now have a property called states.  This represents the list of states at which that constraint applies.  If the list is empty or null, the constraint will apply at every state.  If the list contains at least 1 item, the constraint will apply at ONLY the states specified.  To limit the amount of xml required when entering states, there are some helper patterns allowed in this list.  These are:
</para>
      <para><emphasis role="bold">“+”</emphasis>: when entering a state name followed by a plus sign, this means the constraint is applied to that state and every state afterwards. Examples: “state1+”, “I+”
</para>
      <para><emphasis role="bold">“&gt;”</emphasis>: used for ranges.  The constraint will apply from one state to another state, and every state in between. Examples: “state1&gt;state3”, “I&gt;S”
</para>
      <para>Of course, you can just list single states by name in the list as well. </para>
      <para>These patterns can be mixed in the list itself.  Example:  p:states=“state1, state3&gt;state4, state6+”
</para>
      <para>In addition, other than determining if the constraint applies at a specific state or not, Constraints can also change fundamentally over time.  An example of this may be that what is allowed to be input in a field becomes stricter over state transitions.  To accomplish this, constraints (BaseConstraint.java) now have a property called <emphasis role="bold">constraintStateOverrides</emphasis> which contains a list of replacements for the constraint they are configured on.  Constraints in this list must be compatible with the constraint they are replacing; for example, ValidCharacterConstraints should only be replaced with other ValidCharacterConstraints (and its child classes), etc.  Overrides that do not match or are not valid siblings/children classes of the constraint they are overriding will throw an exception.</para>
      <para><emphasis role="bold">Constraints in this list MUST have the states at which they apply defined; the replacement will override the constraint they are configured on at the states they specify. Overrides which do not have states specified will throw an exception. </emphasis></para>
      <para>Rules for constraintStateOverrides:
</para>
      <itemizedlist>
        <listitem>Overrides if configured always take precedence over their parent when they apply. If no overrides match the state or if the constraintStateOverrides list is empty, the parent constraint will apply (if it is applicable for the state). </listitem>
        <listitem>If there are there are 2 overrides that both apply at the same state, the last on the list will always take precedence.</listitem>
      </itemizedlist>
      <para><section>
          <title>State-based Validation at the Controller</title>
        </section>While the client-side validation is automatic (always validates against “n+1” unless configured otherwise), the server-side validation is completely up to the implementer.  If you would like to validate your View (or alternatively DataDictionaryEntry), there are methods provided to do so.  The main point is that server validation is NOT automatic and is application controlled.  These new state-based validation methods are (some overloaded version not noted here):
</para>
      <emphasis role="bold">
        <para>For ViewValidationService (should be used for KRAD views):</para>
      </emphasis>
      <emphasis role="bold">
        <para>
</para>
      </emphasis>
      <itemizedlist>
        <listitem><emphasis role="bold">validateView(View view)</emphasis> - This is the main validation method that should be used when validating Views. This method validates against the current state if state based validation is setup. </listitem>
        <listitem><emphasis role="bold">validateView(View view, ViewModel model, String forcedValidationState)</emphasis> - Validate the view against the specific validationState instead of the default (current state). If forcedValidationState is null, validates against the current state, if state-based validation is setup.</listitem>
        <listitem><emphasis role="bold">validateViewAgainstNextState(View view, ViewModel model) </emphasis>- Validate the view against the next state based on the order of the states in the view’s StateMapping. This will validate against current state + 1. If there is no next state, this will validate against the current state.</listitem>
        <listitem><emphasis role="bold">validateViewSimulation(View view, ViewModel model)</emphasis> - Simulate view validation - this will run all validations against all states from the current state to the last state in the list of states in the view&apos;s stateMapping. Validation errors received for the current state will be added as errors to the MessageMap. Validation errors for future states will be warnings.</listitem>
      </itemizedlist>
      <para><emphasis role="bold">For DictionaryValidationService </emphasis>(recommended only when you don’t have a view.  Also note that state-based validation only works for DataDictionaryEntry backed objects with StateMappings setup):
</para>
      <itemizedlist>
        <listitem><emphasis role="bold">validate(Object object)</emphasis> – Validates against the current state (if state-based validation is set up). </listitem>
        <listitem><emphasis role="bold">validateAgainstState(Object object, String validationState) </emphasis>– validates against the state specified by validationState. </listitem>
        <listitem><emphasis role="bold">validateAgainstNextState(Object object)</emphasis> – validates against the next state as defined by the state mapping. </listitem>
      </itemizedlist>
      <para>What is done in response to validation errors is also completely up to the implementation of the controller logic (it is recommended you halt action and return back the same view passed in, this will automatically display the discovered validation errors for the user).
</para>
      <para>Example of validating and checking errors (this simple example only changes the state on successful validation):
</para>
      <programlisting>//inside a controller method
KRADServiceLocatorWeb.getViewValidationService().validateView(form.getPostedView(), form, &quot;state2&quot;);
if(!GlobalVariables.getMessageMap().hasErrors()){
   //do whatever you need to do on after a successful
   //validation here (save, submit, etc)
   form.setState(&quot;state2&quot;);
}

return getUIFModelAndView(form);</programlisting>
      <figure>
        <title>State-based Validation Server Errors</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../images/KRAD_Guide/statebasedValidation.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>In this image, you may notice the &quot;**&quot; indicator.  In KRAD, this means the field is required for the next state.</para>
      <section>
        <title>State-based Validation helper beans</title>
      </section>
      <para>There are a few beans available for use to help with a couple aspects of state based validation:</para>
      <itemizedlist>
        <listitem><emphasis role="bold">StateMapping</emphasis> - base StateMapping bean to parent from, defaults statePropertyName to &quot;state&quot;</listitem>
        <listitem><emphasis role="bold">WorkflowStateMapping</emphasis> - suggested workflow StateMapping bean properties, for use with documents. Important: use only if you know your state-based validation is tied directly to workflow status.</listitem>
        <listitem><emphasis role="bold">Uif-StateBased-RequiredInstructionsMessage</emphasis> - message that indicates that &quot;**&quot; means required for the next state. May be enhanced in the future to tell the user what the actual next state is.</listitem>
      </itemizedlist>
    </section>
  </section>
  <section>
    <title> Data Dictionary Services </title>
    <para>Coming Soon!</para>
<!-- TODO: Add content here.
          -->  </section>
  <section>
    <title>The DATAOBJECTMETADATASERVICE</title>
    <para>Coming Soon!</para>
<!-- TODO: Add content here.
          -->  </section>
  <section>
    <title> Extending the Data Dictionary </title>
    <para>Coming Soon!</para>
<!-- TODO: Add content here.
          -->  </section>
</chapter>
