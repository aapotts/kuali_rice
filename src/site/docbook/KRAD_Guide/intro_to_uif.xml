<?xml version='1.0' encoding='UTF-8'?> 
<!--

    Copyright 2005-2012 The Kuali Foundation

    Licensed under the Educational Community License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.opensource.org/licenses/ecl2.php

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->
<chapter xml:id="intro_to_uif" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://docbook.org/ns/docbook"  version="5.0">    
    <title>Introduction to the UIF</title>
    <section>
        <title>Overview of the UIF </title>
        <para>The KRAD User Interface Framework (UIF) allows application developers to rapidly
            create rich and powerful user interfaces. KRAD builds on concepts of the KNS (Kuali
            Nervous System) and the KS (Kuali Student) UIF to create a framework capable of
            generating modern Web 2.0 interfaces with simple declarative configuration. In the next
            few chapters, we will explore the architecture and features of the UIF and also see some
            of the exciting possibilities for future growth!</para>
        <para>As mentioned in ‘A Need for KNS Version 2’, the KRAD effort was spawned based on the
            need to expand the current Rice development framework for meeting requirements of the
            Kuali Student project. Although the Rice KNS module has many great concepts that had
            worked well up to date, it was determined in order to meet the new requirements and to
            continue making overall improvements, portions of the framework would need to be
            redesigned and rewritten. The majority of this work focused on UI generation, with some
            enhancements to other feature areas of the KNS. The following list the primary goals of
            this effort:</para>
        <section>
            <title>UIF Goal: Rich UI Support</title>
            <para>Over the past few years, web-based user interfaces have taken off. Many of these
                technologies have leveraged browser-based JavaScript and Cascading Style Sheets to
                create impressive effects or to radically increase interactivity by communicating
                with a web-server in between the normal request/response page cycle. Because of
                these huge advances, today's web application users have much higher expectations of
                interactivity.</para>
            <para>The KRAD UIF aims to allow the development of rich web interfaces by offering a
                variety of rich components and behavior. This includes components like lightbox,
                suggest boxes, menu/tabs, and grid (table) features. Some of the ‘behavioral’
                features include partial page refreshes, progressive disclosure, client side
                validation, and Ajax queries. This is just a subset of the way that richer user
                interface functionality is offered by KRAD. Chapters 8 and 11 cover these features
                and more in detail. </para>
        </section>
        <section>
            <title> UIF Goal: More Layout Flexibility </title>
            <para>One of the features of the Nervous System users pick up on quickly is the fact
                that so many screens can be generated purely through configuration. A business
                object lookup and inquiry, as well as the screen for maintenance documents: all can
                be generated entirely from an XML file. Freeing developers from having to concern
                themselves with the particulars of the HTML generation for these screens makes the
                user interface of Kuali applications more consistent, to say nothing of the boost to
                developer productivity it gives.</para>
            <para>However, there were other screens which could not be so easily generated.
                Transactional documents depended on perhaps several JSP files, supported by
                hierarchies of traditional taglets. Non-document screens had to be coded in JSP as
                well. The KNS provided a standard library of taglets - such as documentPage, tab,
                htmlControlAttribute, and so on - which eased the development task a bit, but the
                hard fact was that developers still had to spend much more time coding these pages. </para>
            <para>It should therefore be of little surprise that one of KRAD's major goals is
                improving this situation. If transactional documents and non-document screens could
                make use of the Rich UI support through configuration, that would make it much
                easier to develop these incredibly important pieces of functionality.</para>
            <para>However, as any KNS developer knows, transactional documents are much more
                flexible than lookups or maintenance documents. Maintenance documents are almost
                always stacks of two or four columns, perhaps broken up by a standard sub-collection
                interface. Conversely, a transactional document can look like practically
                anything.</para>
        </section>
        <section>
            <title> UIF Goal:  Easy for Customizing and Extending </title>
            <para>We have all had the experience of working with development frameworks to meet some
                special need that the framework did not provide ‘out of the box’. In many cases,
                this is a painful process,. R requiring the developer to get inside the ‘black box’
                and figure out many intricate details of the framework. Furthermore, once a solution
                is found, it might require we modify the core of the framework, causing maintenance
                and upgrade issues.</para>
            <para>Similar issues were encountered when using the Rice KNS framework. In particular,
                the use of tags was problematic, in that there was no way to customize tag logic
                without breaking the upgrade path. In addition, the objects used for UI modeling
                were not extensible or customizable without modifying the Rice code. Therefore, an
                important goal for the UIF is to allow new UI features to be added, and current
                features to be modified without modifying Rice code. As we will see later, this is
                accomplished using a component framework and the power of Spring bean
                configuration.</para>
        </section>
        <section>
            <title>UIF Goal: Improved Configuration and Tooling</title>
            <para>A lot of user feedback about the Kuali Nervous System centered on the repetitive
                tasks of setting up configuration. Every business object has an object-relational
                mapping and an entry in the data dictionary; that entry is made up of field
                configurations, which gets tediously long fairly quickly.  And then there's building
                the corresponding Java code to be the actual business  object. Even more pieces are
                added to this recipe when attempting to put together a document. </para>
            <para>KRAD is adopting a series of design principles to alleviate some of the work
                required for this configuration. KRAD intends to introduce a series of simple-to-use
                tools to generate configuration based on defaults, letting developers focus on
                tweaking the configuration to match business logic.</para>
            <para>KRAD is also simplifying configuration in general. The idea of "convention over
                configuration" will mean that standard defaults will be provided for what had to be
                manually configured before. These defaults can be overridden, but if they fit the
                needs of the application, no further configuration will be necessary. This will cut
                down a huge amount on the "XML push-ups" required by KRAD application developers,
                but still provide a great deal of flexibility.</para>
        </section>
        <section>
            <title>UIF Dictionary</title>
            <para>The UIF builds on the KNS concept of using Spring bean XML to build UIs. XML files
                are created to configure and assemble UIF objects (called components). These files
                are then processed and loaded into the Data Dictionary container.</para>
            <para>More Info: Although the UIF configuration is loaded into the same container as the
                Data Dictionary, conceptually we think of them as separate. A current practice
                within Rice is to have a resource directory for data dictionary files, and a
                resource directory for UIF files (per module). In addition, care was taken to allow
                for separate containers to be created if desired at some point.</para>
        </section>
        <section>
            <title>The UIF and UIM</title>
            <para>We will see that technically, using the UIF is very easy, since most things can be
                accomplished by simple XML configuration. However, there is a challenge in knowing
                how to put the pieces together. To accomplish the amount of flexibly necessary, the
                UIF introduces a lot of concepts that will take some time to learn. Taken all
                together, these form a language for how Rice developers and UX leads will discuss,
                prototype, and finally build user interfaces. To help with this process, the UIM
                (User Interaction Model) was developed. The UIM is a collection of pages that
                document how to best make use of the UIF functionality. Such things as when to use
                one component over another, various configurations of a component, and overall UX
                concerns are documented within the UIM. Investing time to read through the UIM will
                help get up to speed with the UIF much quicker. </para>
            <para>You can find the latest version of the UIM at the following URL:  <link
                    xlink:href="https://wiki.kuali.org/display/STUDENT/User+Interaction+Mode"
                    >https://wiki.kuali.org/display/STUDENT/User+Interaction+Mode</link>
            </para>
        </section>
    </section>
    <section>
        <title>Recap</title>
        <itemizedlist>
            <listitem>
                <para>The UIF (User Interface Framework) is the KRAD module used to generate User
                    Interfaces</para>
            </listitem>
            <listitem>
                <para>Goals of the UIF are:<itemizedlist>
                        <listitem>
                            <para>Rich UI Support</para>
                        </listitem>
                        <listitem>
                            <para>More Layout Flexibility</para>
                        </listitem>
                        <listitem>
                            <para>Easy for Customizing and Extending</para>
                        </listitem>
                        <listitem>
                            <para>Improved Configuration and Tooling</para>
                        </listitem>
                    </itemizedlist></para>
            </listitem>
            <listitem>
                <para>The UIM (User Interaction Model) is documentation on how page developers
                    should use the UIF for designing views</para>
            </listitem>
        </itemizedlist>
    </section>
    <section>
        <title>Component Design </title>
        <para>Central to all of the UIF is the component framework. Components provide the mechanism
            for which functionality is implemented in a customizable and extensible fashion. In
            short, they are the bread and butter of KRAD!</para>
        <para>So what is a component? A component to KRAD is anything that can be used to build a
            web page. Many of these have a visual presence on the screen, such as text, however but
            some do not, instead providing and provide behavior with script. Treating all these as
            components, gives us a uniform approach to developing the UIF framework in addition to
            providing a very customizable and easy contribution modal. This section will explore the
            design of components from a high level. Later on in this chapter, we will learn about
            the various types of components, and in chapters 6-9 we will look at the specific
            components KRAD provides out of the box.</para>
        <section>
            <title> Parts of a Component</title>
            <para> A component is made up of three different artifacts (see figure 6). The first of
                these is a Java class. The Java class defines the properties and behavior the
                component can have. As we will see later on, the properties are what we can use to
                configure the component, while the behavior includes things such as how the
                component interacts with other components. As with any class, the properties can be
                primitive or collection types, or types of other objects. In this case of a
                component, these objects may be other components. Therefore components can be nested
                (or a composition). In addition, components may extend from other components to
                inherit properties and behavior. This forms a component hierarchy. The component
                class may exist anywhere on the class path.</para>
            <para><inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="../images/KRAD_Guide/componentParts.png"/>
                    </imageobject>
                </inlinemediaobject></para>
            <para>The second artifact for a component is its rendering template. The template is a
                JSP file that renders JSP/HTML/JS contents for the component instance. The template
                is an optional artifact. Components may ‘self-render’ which means the component
                object will be invoked to return the HTML/JS contents (note JSP content cannot be
                rendered in this mode). However, most Uif UIF components use templates as they are
                much easier and cleaner to implement. We will learn all about templates in the next
                section.</para>
            <para>The final piece of a component is its Spring bean definition. Spring bean XML is
                the mechanism by which developers configure and assemble UIF components. Creating a
                bean definition for the component (sometimes known as the ‘base’ definition) allows
                us to specify defaults for properties, in addition to giving the component a unique
                name within the bean container (note it would be possible to use the component
                without a base definition, but then the class would have to be specified each time
                it is used).</para>
            <para>One important property that is configured with the base definition is the
                template. The template property (available on all components) is the path to the
                template JSP file that will render the component. Specifying the template through
                the bean configuration provides loose coupling of the component class and template.
                This is very important to the flexibility of the system. The template can be located
                anywhere in the web root for the application.</para>
            <para>The base component definition also does a couple more things for us. One of these
                is setting up the component with scope prototype. All UIF components maintain state,
                so they must be marked as prototype within Spring. Finally, it is recommended the
                base definition be setup with an abstract parent bean. This setup looks like the
                following:
                <programlisting>&lt;bean id=”componentName” parent=”componentName-parentBean”/>
&lt;bean id=”componentName-parentBean” abstract=”true” class=”edu.myedu.Sample.Component” scope=”prototype”>
...
&lt;/bean>    </programlisting></para>
            <para>This allows the base definition to be changed without having to copy the entire
                original configuration. Recall that Spring allows us to override a bean definition
                by specifying a bean with the same id. Therefore, if an institution wanted to change
                the default property for a component, they simply would include the following in the
                institutional spring files:
                <programlisting>&lt;bean id=”componentName” parent=”componentName-parentBean”>
    &lt;property name=”propertyName” value=”overrideValue”/>
&lt;/bean>    </programlisting></para>
            <para>Without the abstract parent bean, all of the initial property configuration would
                need to be copied (since setting the parent to “componentName” would cause a
                circular dependency).</para>
            <para>When defining base definitions we are not limited to just one. In many cases it is
                useful to provide different configurations of a component as different bean
                configurations. For example, one component we will learn about is the TextControl.
                The text control renders a HTML input of type text and has a size property which
                configures the display size for the input. First we might setup a bean definition
                that looks like the following:
                <programlisting>&lt;bean id="Uif-TextControl" parent="Uif-TextControl-parentBean"/>
&lt;bean id="Uif-TextControl-parentBean" abstract="true" class="org.kuali.rice.krad.uif.control.TextControl" scope="prototype">
    &lt;property name="template" value="/krad/WEB-INF/jsp/templates/control/text.jsp"/>
    &lt;property name="size" value="30"/>
&lt;/bean>     </programlisting></para>
            <para>The control can then be used by use of bean references or inner beans:
                <programlisting>&lt;property name=”control”>
    &lt;bean parent=”Uif-TextControl” p:size=”10”/>
&lt;/property>    </programlisting></para>
            <para>Notice here we are overriding the size property because we need a small input.
                Seeing this, we might decide we want to have a standard size for small, medium, and
                large inputs. Therefore we set the following bean configurations:
                <programlisting>&lt;bean id="Uif-TextControl" parent="Uif-TextControl-parentBean"/>
&lt;beanid="Uif-TextControl-parentBean" abstract="true" class="org.kuali.rice.krad.uif.control.TextControl" scope="prototype">
    &lt;property name="template" value="/krad/WEB-INF/jsp/templates/control/text.jsp"/>
    &lt;property name="size" value="30"/>
&lt;/bean>
&lt;bean id="Uif-SmallTextControl" parent="Uif-SmallTextControl-parentBean"/>
&lt;bean id="Uif-SmallTextControl-parentBean" abstract="true" parent=”Uif-TextControl”>
    &lt;property name="size" value="10 "/>
&lt;/bean>
&lt;bean id="Uif-MediumTextControl" parent="Uif-MediumTextControl-parentBean"/>
&lt;bean id="Uif-MediumTextControl-parentBean" abstract="true" parent=”Uif-TextControl”>
    &lt;property name="size" value="30 "/>
&lt;/bean>
&lt;bean id="Uif-LargeTextControl" parent="Uif-LargeTextControl-parentBean"/>
&lt;bean id="Uif-LargeTextControl-parentBean" abstract="true" parent=”Uif-TextControl”>
    &lt;property name="size" value="100 "/>
&lt;/bean>     </programlisting></para>
            <para>Now when we need a small text control, we can reference the ‘Uif-SmallTextControl’
                bean and not specify the size:
                <programlisting>&lt;property name=”control”>
    &lt;bean parent=”Uif-SmallTextControl”/>  
&lt;/property>      </programlisting></para>
            <para>Many of the components provided by the UIF have multiple base bean
                definitions.</para>
        </section>
        <section>
            <title>Customizing and Extending the UIF</title>
            <para>We know that a major goal of the UIF is to provide a high level of flexibility.
                Furthermore, we have seen the central concept of components. So how does this
                component design achieve our goal?</para>
            <para>To answer this question, let’s first take a look at what criteria we should look
                for in a highly flexible system.<orderedlist>
                    <listitem>
                        <para>Can we customize all parts of the system, or are there places that are
                            ‘unreachable’?</para>
                    </listitem>
                    <listitem>
                        <para>If we can customize something, can we do that outside of the original
                            codebase so that we do not hinder our upgrade path?</para>
                    </listitem>
                    <listitem>
                        <para>What level of understanding do we need to customize the system? Is
                            each customization different? Does it require us to get deep inside the
                            black box?</para>
                    </listitem>
                    <listitem>
                        <para>Can we add to the system? If so, do those additions act as first class
                            citizens, or require some alternate approach to use?</para>
                    </listitem>
                </orderedlist></para>
            <para>Recall besides the base ‘plumbing’ of the UIF a set of components is provided to
                build pages with. Each of these components brings a piece of functionality to the
                framework. Thus we can think of them as ‘building blocks’ for the framework as shown
                in Figure 7. </para>
            <para><inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="../images/KRAD_Guide/componentBuildingBlocks.png"/>
                    </imageobject>
                </inlinemediaobject></para>
            <para>Now let’s suppose we want to customize a ‘core’ component.  To do this, we simply
                change one of the component parts (class, bean, or template). We saw previously how
                we can change the bean configuration for a component by providing another bean
                configuration with the same id. Using the abstract parent bean, we can inherit all
                of the original configuration and then change or add configuration as needed. </para>
            <para>For an example of this, let’s use the UIF ‘required’ message field which has the
                following definition:
                <programlisting>&lt;bean id="Uif-RequiredMessage" parent="Uif-RequiredMessage-parentBean"/>
&lt;bean id="Uif-RequiredMessage-parentBean" abstract="true" parent="Uif-MessageField" 
    scope="prototype" p:messageText="*" p:messageType="REQUIRED">
...
&lt;/bean>    </programlisting></para>
            <para>We decide for our application we want the required message to actually display the
                text ‘required’ instead of the configured asterisk. To do this we include a bean
                with the same id in our application (or institutional spring) file:
                <programlisting>&lt;bean id="Uif-RequiredMessage" parent="Uif-RequiredMessage-parentBean" p:messageText=”required” />    </programlisting></para>
            <para>Now everywhere the required message field is used the text ‘required’ will display
                instead of ‘*’. </para>
            <tip><para>
                <emphasis role="bold">Adding Spring Files: </emphasis> Adding Spring files to the
                container can be done using the KRADConfigurer. </para></tip>
            <para> Next let’s consider the component template. Remember the template is a JSP file
                located in the web root and generates the JSP/HTML/JS contents for the component. If
                we wish to change this rendering, we can create another template in a web location
                of our choosing. </para>
            <para>Depending on the level of customization we need to implement, we might start by
                copying the current template contents or from scratch. One we have the template that
                renders the component how we want, then we override the bean configuration as
                described previously and override the template property specifying the location for
                the new template:
                <programlisting>&lt;bean id="Uif-TextControl" parent="Uif-TextControl-parentBean"/>
&lt;bean id="Uif-TextControl-parentBean" abstract="true" class="org.kuali.rice.krad.uif.control.TextControl" scope="prototype">
    &lt;property name="template" value="/krad/WEB-INF/jsp/templates/control/text.jsp"/>
    &lt;property name="size" value="30"/>
&lt;/bean>
&lt;bean id="Uif-TextControl" parent="Uif-TextControl-parentBean">
    &lt;property name="template" value="/myapp/WEB-INF/jsp/templates/text.jsp"/>
&lt;/bean>    </programlisting></para>
            <para>The last part of the component we have to customize is the Java class itself.
                Modifying the Java class would allow us to add new properties and behavior to the
                component. For this we can create a new class that extends the original component
                class. This new class can be anywhere in the classpath. New properties can be made
                available by adding properties to our extension class (with getters and setters).
                Customization of behavior can be modified by overriding the various lifecycle
                methods. These methods will be covered in Chapter 9. Once we have the new class, we
                associate it with the component by again overriding the bean definition:
                <programlisting>&lt;bean id="Uif-TextControl" parent="Uif-TextControl-parentBean"/>
&lt;bean id="Uif-TextControl-parentBean" abstract="true" class="org.kuali.rice.krad.uif.control.TextControl" scope="prototype">
    &lt;property name="template" value="/krad/WEB-INF/jsp/templates/control/text.jsp"/>
    &lt;property name="size" value="30"/>
&lt;/bean>
&lt;bean id="Uif-TextControl" parent="Uif-TextControl-parentBean" class=”edu.myedu.Sample.TextControl”>
    &lt;property name="additionalProperty" value="foo”/>
&lt;/bean>    </programlisting></para>
            <para>Now that we have seen how to customize a component, how do we go about adding a
                new component? We can add a component using the same process we saw for
                customization. The difference between adding and customizing are:<orderedlist>
                    <listitem>
                        <para>We will create a new base Spring definition (not overriding an
                            existing)</para>
                    </listitem>
                    <listitem>
                        <para>The Java class will not extend a core component, but one of the
                            provided base classes (described later on in this chapter)</para>
                    </listitem>
                </orderedlist></para>
            <para>Essentially we need to create the three artifacts for the component just like the
                core components. Once created, using custom components is not different than using
                the provided components.  Therefore as depicted in Figure 8, core and custom
                components work together as part of the framework. </para>
            <para><inlinemediaobject>
                    <imageobject>
                        <imagedata fileref="../images/KRAD_Guide/componentBuildingBlock2.png"/>
                    </imageobject>
                </inlinemediaobject></para>
            <tip>
                <para><emphasis role="bold">Planned Feature</emphasis></para>
                <para><emphasis role="bold">Component ‘Drop In’: </emphasis> In the future KRAD might
                    support a plugin facility for ‘dropping’ in new components. A component ‘bundle’
                    could be download and dropped into the plugin directory eliminating the need to copy
                    the base bean definition, template file, and Java class. </para>
            </tip>
        </section>
        <section>
            <title>RECAP</title>
            <itemizedlist>
                <listitem>
                    <para>Components are a central piece to the UIF and are critical for customizing
                        and extending the framework</para>
                </listitem>
                <listitem>
                    <para>Each component is made up of three parts:<itemizedlist>
                            <listitem>
                                <para>Java Class – defines the properties and behavior</para>
                            </listitem>
                            <listitem>
                                <para>JSP Template – renders JSP/HTML/JS content for a component
                                    instance </para>
                            </listitem>
                            <listitem>
                                <para>XML Definition(s) – provides default properties for a
                                    component (including the template) and assigns an ID for using
                                    the component</para>
                            </listitem>
                        </itemizedlist></para>
                </listitem>
                <listitem>
                    <para>KRAD provides several components for use ‘Out of the Box’</para>
                </listitem>
                <listitem>
                    <para>We can customize a component by changing it bean definition, writing a new
                        template, or extending the Java class to add properties or behavior</para>
                </listitem>
                <listitem>
                    <para>We can create our own components by creating the three necessary artifacts
                        (outside of the Rice code)</para>
                </listitem>
            </itemizedlist>
        </section>
    </section>
    <section>
        <title>Building Templates with Apache Tiles </title>
        <para>Given the goal of the UIF is to produce web pages (HTML, Image, and JS content),; the
            component template provides a very important role. This section will help us understand
            templates better and how they are built using Apache Tiles.</para>
        <para>Before looking at templates in KRAD, let’s step back and think about the job of
            building a web UI framework. We know web pages are rendered by a browser from HTML
            markup, along with other resources such as script and image files. So ultimately the
            result from our framework is this markup that will be streamed back as the response to a
            request by the user. This is the output of the framework. The input to the framework
            will be XML configuration provided by an application developer. So how do these get
            connected? </para>
        <para>Based on our Spring knowledge, we know the XML metadata will get used to create
            Objects in the Spring container, so these objects instances now contain the developers
            configuration. We can then expose these objects to the JSP templates, which will combine
            the object values with static contents to produce the resulting markup (see figure
            6).</para>
        <para>Templates within KRAD are created using the Apache Tiles framework. Apache Tiles is a
            templating framework that allows JSP files to be assembled at runtime. To create a
            template in Tiles, we start by creating a standard JSP page:
            <programlisting>&lt;%@ taglib uri="http://tiles.apache.org/tags-tiles" prefix="tiles" %>
&lt;html>
  &lt;head>&lt;title>&lt;tiles:getAsString name="title"/>&lt;/title>&lt;/head>
  &lt;body>
    &lt;table>
      &lt;tr>
        &lt;td colspan="2">&lt;tiles:insertAttribute name="header" />&lt;/td>
      &lt;/tr>
      &lt;tr>
        &lt;td>&lt;tiles:insertAttribute name="menu" />&lt;/td>
        &lt;td>&lt;tiles:insertAttribute name="body" />&lt;/td>
      &lt;/tr>
      &lt;tr>
        &lt;td colspan="2">&lt;tiles:insertAttribute name="footer" />&lt;/td>
      &lt;/tr>
    &lt;/table>
  &lt;/body>
&lt;/html>     </programlisting></para>
        <para>Notice within this JSP file we are using a tag library provided by tiles. This allows
            us to declare points in our JSP file where content can be inserted (called template
            ‘attributes’). Along with each insertion point (where we see the ‘tiles:insertAttribute’
            tag) we specify a name for the attribute using the name attribute.</para>
        <para>Once we have templates created, we can assemble these into definitions. One mechanism
            Tiles provides for this is providing XML metadata. For example, we can configure Tiles
            to read a XML file named ‘titles-def.xml’ (see Apache Tiles documentation for
            instructions on configuring the framework) and add the following XML:
            <programlisting>&lt;?xml version="1.0" encoding="ISO-8859-1" ?>
&lt;!DOCTYPE tiles-definitions PUBLIC 
    "-//Apache Software Foundation//DTD Tiles Configuration 2.1//EN"         
    "http://tiles.apache.org/dtds/tiles-config_2_1.dtd">
&lt;tiles-definitions>
    &lt;definition name="myapp.homepage" template="/layouts/classic.jsp">
        &lt;put-attribute name="title" value="Tiles tutorial homepage" />
        &lt;put-attribute name="header" value="/tiles/banner.jsp" />
        &lt;put-attribute name="menu" value="/tiles/common_menu.jsp" />
        &lt;put-attribute name="body" value="/tiles/home_body.jsp" />
        &lt;put-attribute name="footer" value="/tiles/credits.jsp" />
    &lt;/definition>
&lt;/tiles-definitions>    </programlisting></para>
        <para>In this example the template attribute points to our JSP template file (shown
            previously). Then for each attribute declared in the template file, we can specify a
            value using the put-attribute tag. Notice the attribute values can be other JSP files,
            for which Tiles will insert the contents from that file. The attributes can also be
            assigned a String value.</para>
        <para>The final step is to render the configured definition. This is accomplished by
            creating a JSP that using the tiles insertDefinition tag:
            <programlisting>&lt;%@ taglib uri="http://tiles.apache.org/tags-tiles" prefix="tiles" %>
&lt;tiles:insertDefinition name="myapp.homepage" />    </programlisting></para>
        <section>
            <title> Runtime Composition </title>
            <para>Tiles allows us to bypass the XML definition and insert a template directly into a
                page, known as runtime composition. We can rewrite our previous JSP page (using the
                tiles:insertDefinition) as follows:
                <programlisting>&lt;tiles:insertTemplate template="/layouts/classic.jsp">
    &lt;tiles:putAttribute name="title"value="Tiles tutorial homepage" />
    &lt;tiles:putAttribute name="header"value="/tiles/banner.jsp" />
    &lt;tiles:putAttribute name="menu"value="/tiles/common_menu.jsp" />
    &lt;tiles:putAttribute name="body" value=”/layouts/variable_rows.jsp”/>
    &lt;tiles:putAttribute name="footer" value="/tiles/credits.jsp" />
&lt;/tiles:insertTemplate>    </programlisting></para>
            <para>In this JSP, we have used the insertTemplate tag. This tag accepts the template
                attribute whose value is the path to the JSP template file. Similar to the XML
                definition, we can specify values for the template attributes using the put-attribute
                tag.</para>
        </section>
        <section>
            <title>The KRAD Approach </title>
            <para>KRAD uses the approach of runtime composition for rendering the templates. This is
                essentially because it allows us to insert the templates right from our JSP, instead
                of writing out additional XML.</para>
            <para>Furthermore, KRAD uses a slightly different approach for the templates. Tiles
                provides a tag named ‘useAttribute’ that takes the attribute value and places it
                into a page scoped variable. We can then use JSTL to reference the variable in other
                parts of the JSP. For example let’s rewrite out template with the useAttribute:
                <programlisting>&lt;%@ taglib uri="http://tiles.apache.org/tags-tiles" prefix="tiles" %>
&lt;tiles:useAttribute name=”title”/>
&lt;tiles:useAttribute name=”header”/>
&lt;tiles:useAttribute name=”menu”/>
&lt;tiles:useAttribute name=”body”/>
&lt;tiles:useAttribute name=”footer”/>
&lt;html>
    &lt;head>&lt;title>${title}&lt;title>&lt;/head>
    &lt;body>
        &lt;table>
            &lt;tr>
                &lt;td colspan="2">${header}&lt;/td>
            &lt;/tr>
            &lt;tr>
                &lt;td>${menu}&lt;/td>
                &lt;td>${body}&lt;/td>
            &lt;/tr>
            &lt;tr>
                &lt;td colspan="2">${footer}&lt;/td>
            &lt;/tr>
        &lt;/table>
    &lt;/body>
&lt;/html>     </programlisting></para>
            <para>By default, the variable will be exported with the same name as the attribute
                (specified by the name attribute). A different variable name can be given using the
                id attribute.</para>
            <para>The benefit of using this alternate template approach is that we can clearly see
                the attributes a template expects and also allows us to manipulate the attribute
                value using JSTL. </para>
            <tip><para>
                <emphasis role="bold">Why Not Tags? </emphasis> Why not just use JSP 2 tags? The
                KRAD templates look very similar to JSP 2 tags, and so a reasonable question would
                be why not use tags instead of Apache Tiles.? Remember, the actual template that
                gets included is configured with the bean XML,, therefore it is not possible to
                statically include the template from JSP (it must be a variable). The problem with
                this is the JSP specification does not support a variable tag name! However, the
                jsp:include tag does support a variable (e.g. &lt;jsp:include
                page=”${template}”/&gt;). Apache Tiles is essentially a wrapper for JSP include that
                gives us a more formal way of passing parameters. In addition to the variable
                problem, the restriction on tag file location (tags are required to be under
                WEB-INF/tags) was a factor in the decision. KRAD still makes use of tag files to
                provide utility functions for the JSP templates. </para></tip>
        </section>
        <section>
            <title>Coarse-Grained Parameters</title>
            <para>An important consideration when setting up a template is how to setup the
                parameters. To help explain this, let’s take a look at a snippet from a KRAD
                template:
                <programlisting>&lt;form:input id="${id}" path="${path}" disabled="${disabled}" size="${size}" maxlength="${maxLength}"/>    </programlisting></para>
            <para>This snippet is outputting the Spring form input tag, which will then in turn
                generate the HTML input tag. We see some of the attributes this tag provides are id,
                path, disabled, size, and maxlength. Since this template is generic, in the sense
                that it should render all instances of the TextControl, the values for these
                attributes need to be variable. Now based on our knowledge of Tiles, we can great
                useAttribute tags which will allow values for these variables (or attributes) to be
                specified by the calling JSP. This would look like the following:
                <programlisting>&lt;tiles:useAttribute name="id"/>
&lt;tiles:useAttribute name="path"/>
&lt;tiles:useAttribute name="disabled"/>
&lt;tiles:useAttribute name="size"/>
&lt;tiles:useAttribute name="maxLength"/>
&lt;form:input id="${id}" path="${path}" disabled="${disabled}" size="${size}" maxlength="${maxLength}"/>    </programlisting></para>
            <para>The calling JSP would then be:
                <programlisting>&lt;tiles:insertTemplate template="/templates/text.jsp">
    &lt;tiles:putAttribute name="id" value="${component.id}" />
    &lt;tiles:putAttribute name="path" value="${component.path}” />
    &lt;tiles:putAttribute name="disabled" value="${component.disabled}" />
    &lt;tiles:putAttribute name="size" value=”${component.size}”/>
    &lt;tiles:putAttribute name="maxlength" value="${component.maxlength}" />
&lt;/tiles:insertTemplate>    </programlisting></para>
            <para>Here the component variable is the component instance that has been exported to
                the page. </para>
            <para>Now let’s suppose that a developer wishes to override the component class and
                template to provide a ‘readonly’ property. The template now looks like this:
                <programlisting>&lt;tiles:useAttribute name="id"/>
&lt;tiles:useAttribute name="path"/>
&lt;tiles:useAttribute name="disabled"/>
&lt;tiles:useAttribute name="size"/>
&lt;tiles:useAttribute name="maxlength"/>
&lt;tiles:useAttribute name="readonly"/>
&lt;form:input id="${id}" path="${path}" disabled="${disabled}" size="${size}" maxlength="${maxlength}" readonly=”${readonly}”/>    </programlisting></para>
            <para>In order for the readonly attribute to be passed in, the developer must also
                change the calling JSP adding the putAttribute tag. This not only adds to the amount
                of work required for customizing a component but also leads to general maintenance
                issues within the framework.</para>
            <para>To solve this problem, KRAD passes the full component to the templates and not the
                individual properties of the component. Passing the full component makes changes our
                original template to:
                <programlisting>&lt;tiles:useAttribute name="component" classname="org.kuali.rice.krad.uif.control.TextControl"/>
&lt;form:input id="${component.id}" path="${component.path}" disabled="${component.disabled}" size="${component.size}"/>    </programlisting></para>
            <para>Now for the custom template, we simply make use of the new property without any
                changes to the calling JSP:
                <programlisting>&lt;tiles:useAttribute name="component" classname="org.kuali.rice.krad.uif.control.TextControl"/>
&lt;form:input id="${component.id}" path="${component.path}" disabled="${component.disabled}" size="${component.size}" readonly=”${readonly}”/>    </programlisting></para>
            <para>Notice though the addition of the classname attribute. Since we are passing an
                object now instead of a primitive type, we must specify the class for the
                object.</para>
            <para>In addition to providing more template flexibility, using the course grained
                parameters gives us a uniform way of invoking templates. As we will see in a bit,
                the framework provides a generic tag that can be used to invoke any template for a
                tag.</para>
        </section>
        <section>
            <title>TLD Includes</title>
            <para>Although components are rendered using Apache Tiles, tags are still widely used in
                KRAD. Foremost among these are the Spring tags, JSTL, and KRAD tags that provide
                utility functions. KRAD simplifies including the tag libraries by providing a JSP
                file that perform all includes. Template developers just need to include this one
                JSP file which will bring in all necessary tag libraries. Furthermore, the addition
                of tag libraries can be made with the one include JSP without modifying all
                templates. The following code snippet shows this JSP include:</para>
            <programlisting>
&lt;%@ include file="/krad/WEB-INF/jsp/tldHeader.jsp"%&gt;
            </programlisting>
        </section>
        <section>
            <title>Template Tag</title>
            <para>In Chapter 8 we will learn how to assemble UIF components into a View. The View is
                a component itself that among other things encapsulates all other components for our
                UI. It can also be thought of as a tree of components. The rendering processes
                starts by invoking the configured view template. The view template then in turn
                renders its child components and so on until the complete tree has been traversed.
                Therefore, the responsibility of a template is not only render the necessary markup,
                but to invoke rendering for its child components. To help with this, KRAD provides
                the template tag.</para>
            <para>The template tag requires the component attribute to be specified. This is the
                child component that should be rendered:</para>
            <programlisting>
&lt;krad:template component=”${component.childComponent}”/&gt;
            </programlisting>
            <tip>
                <title>KRAD Tags</title>
                <para>All KRAD tags belong to the KRAD namespace.</para>
            </tip>            
            <para>The template tag will then create the tags from Tiles for invoking the template
                and passing the component parameter. Some types of components require additional
                parameters to be passed. These will be covered in the section ‘Types of Components’.
                The figure below depicts the rendering process.</para>
            <figure>
                <title>KRAD Rendering Process</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="../images/KRAD_Guide/KRAD_Rendering_Process.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <para>Besides invoking the template for the child component, the template tag does many
                more useful things for us. These things will be explained as the corresponding
                topics are covered.</para>
        </section>
        <section>
            <title>Recap</title>
                <itemizedlist>
                    <listitem>
                    <para>JSP templates mix component variables with static content to
                        produce the final HTML markup for a page</para>
                </listitem>
                    <listitem>
                    <para>The Apache Tiles framework is used for creating the
                        templates</para>
                </listitem>
                    <listitem>
                    <para>Tiles provides us a mechanism to pass content to the template with
                        a named attribute</para>
                </listitem>
                    <listitem>
                    <para>KRAD uses Tiles runtime composition which does not make use of XML.
                        In addition, templates declare parameters at the beginning of the file with
                        the Tiles useAttribute tag</para>
                </listitem>
                    <listitem>
                    <para>All templates take in the component instance as a parameter</para>
                </listitem>
                    <listitem>
                    <para>KRAD provides a common JSP include to bring in all needed tag
                        libraries</para>
                </listitem>
                    <listitem>
                    <para>Templates generate the necessary markup, and make invocations to
                        render child components</para>
                </listitem>
                    <listitem>
                    <para>The template tag can be used to render components. One of the many things
                        this tag does is invoke the template for the component</para>
                </listitem>
                </itemizedlist>
        </section>
    </section>
    <section>
        <title>The Component Interface </title>
        <para>Over the next few sections, we will look deeper into UIF components and the properties
            they have. These components are defined by their Java class. The class declares how a
            component can be used and how it works with other components. As in all object-oriented
            design, these classes model the domain objects in our problem area, which is building
            web pages! Thus the component classes found should be mostly familiar to anyone who has
            worked with the web (controls, labels, containers, buttons, links, ...). </para>
        <para>To become a UIF component, a class must implement the
            org.kuali.rice.krad.uif.component.Component interface. This interface defines standard
            getter/setters for properties all components should have, in addition to methods that
            are invoked during the view lifecycle. Along with the Component interface, the abstract
            implementation org.kuali.rice.krad.uif.component.ComponentBase is provided which can be
            extended for building new components. Other than default implementations for lifecycle
            methods which we will explore later, this class is essentially a POJO (Plain Old Java
            Object) for the common properties. </para>
        <section>
            <title>Common Component Properties </title>
            <para>We have already learned about one very important property that all components have
                – the template. The template is the path to the JSP file that will perform the
                rendering process (creating of HTML markup) for the component. Now let’s look at
                some other properties that we get from ComponentBase:</para>
            <para><emphasis role="bold">Id</emphasis> – All components must have a unique identifier
                within a view. This id plays a critical role both server side and on the client. On
                the server, the id is used to pull a component from it containing view. A view can
                contain many components that are deeply nested. Iterating through this tree to find
                a particular component can require a lot of coding and add up to many wasted cycles.
                With the id we can ‘index’ the view such that a component can be retrieved in a
                single call. </para>
            <para>On the client, the id becomes even more important. As is the case for many of the
                server side component properties, the id is used to populate the id attribute on the
                HTML element. This results in unique ids for all elements on the page. These ids can
                then be referenced by script created by the framework or by the developer.
                Furthermore it is also possible to build CSS based on the ids (although this is not
                the recommend strategy). </para>
            <para>For generating the id values there are a few options KRAD provides. First, the id
                can be assigned by the developer, or it can by generated by the framework. Manual
                assignment can furthermore be done in one of two ways. The first is to set the id by
                using the bean property tag. For example:
                <programlisting>&lt;bean parent=”Component”>
    &lt;property name=”id” value=”ks34”/>  </programlisting></para>
            <para>The second way to manual assign the component id is by using the bean id
                attribute:
                <programlisting>&lt;bean id=”ks34” parent=”Component”&gt;  </programlisting></para>
            <para>Since the id bean attribute is already required in most beans (top level beans),
                it is often most convenient to take this approach. If both the bean id attribute and
                the id property are specified, the id property value will be used. </para>
            <para>Note that when a bean inherits a bean definition, an id specified with the
                property tag will be inherited, while the id attribute of the bean tag will not. </para>
            <programlisting>&lt;bean id=”ks34” parent=”Component”>
...
&lt;/bean>

&lt;!-- this bean will not have a configured id -->
&lt;bean parent=”ks34”>
...
&lt;/bean>   </programlisting>
            <para>If an id is not configured by one of the above mechanisms, the framework will
                generate and assign a unique id for the component. Ids are generated using a
                sequence that starts at 1 each time the view lifecycle is run (each request) and
                prepended with ‘u’. For example, the first few generated ids would be ‘u1’, ‘u2’,
                and ‘u3’. </para>
            <para>The component ids are assigned by the framework at the beginning of the lifecycle
                (the ‘initialize’ phase). This guarantees all components will have an id throughout
                the view lifecycle (important for script generation in addition to many other
                things). There is one twist, however. Some components are dynamically created while
                processing the view data (the ‘applyModel’ phase). For example, all collection row
                fields cannot be created until the collection data is available. In these cases, the
                configured component represents a ‘prototype’ for creating the dynamic components.
                The prototype will have an id that was manually or automatically assigned. For
                creating the dynamic component, the prototype is copied and then adjusted. This
                means the id value will be copied as well. In order to give the copy a unique id,
                the id is suffixed. In the example of collection rows, each id is suffixed with the
                line (‘l0’, ‘l1’, ‘l2’...). For example, if the prototype has an id of ‘u56’, the
                field in the first collection line will have id ‘u56_l0’, in the second ‘u56_l1’,
                and so on. Other id suffixes used in the framework will be discussed in the various
                component sections. </para>
            <tip><para><emphasis role="bold">Factory Id:</emphasis> Another property we find on ComponentBase is
                        <emphasis role="bold">factoryId</emphasis>. This is _ used to hold the
                    original id for components that are copies of prototypes (dynamically) created.
                    The property is necessary when we need to get a new instance of component using
                    the ComponentFactory. Because the component was dynamically created, the
                    ComponentFactory is not aware of it. However, it is aware of its prototype.
                    Using the factoryId, we can get a new instance of the prototype and then adjust
                    as necessary. </para></tip>
            <para><emphasis role="bold">Title</emphasis> – For most components, we can specify the
                title property. This property gives extra information for the component that will be
                available in the user interface. This is an example of a property that many
                components have, but is used differently between components. For example, one of the
                component types we will learn about in the next section is a <emphasis role="bold"
                    >Container</emphasis>. Components generally begin with a header (using the HTML
                header tag) and use the title property for the header text. Other types of
                components include <emphasis role="bold">Fields</emphasis> and <emphasis role="bold"
                    >Controls</emphasis>. The component types use the title property as the title
                attribute on the corresponding element they produce:
                <programlisting>&lt;element title=”component title property value”/&gt;  </programlisting></para>
            <para>The title attribute value is most often shown as a tooltip when the user hovers
                over the element. </para>
            <para><emphasis role="bold">Title Property:</emphasis> The reason we say title property
                can be specified for ‘most’ components is that there are some that do not use this.
                Since the overwhelming majority do, it was adding to ComponentBase for convenience. </para>
            <para><emphasis role="bold">Render</emphasis> – The render property is a Boolean that
                indicates whether the HTML markup should be generated for the component. When this
                is set to false, the configured template will not be invoked during the rendering
                process. By using conditional expressions to set the render property, we can make
                our view much more dynamic. Essentially the render property allows us to display or
                not display a component based on runtime conditions. </para>
            <para> For example in the following configuration only field1 will be rendered:
                <programlisting>&lt;bean parent=”Uif-InputField”
    p:propertyName=”field1”/> &lt;bean parent=”Uif-InputField”
    p:propertyName=”field2” p:render=”false”/>  </programlisting></para>
            <para>The default value for render is true, so if the render property is not specified
                the component will be rendered. </para>
            <para><emphasis role="bold">Hidden</emphasis> – The hidden property is similar to the
                render property in that it configures whether or not the component is displayed.
                However, when a component is hidden (and render is set to true), the corresponding
                template will be invoked to generate markup. The content is then surrounded with a
                div that contains a style of display none. This keeps the content from being
                visible. The content can be displayed by changing the CSS display style through
                script. This provides a mechanism for toggling the display of a component on the
                client. Later on, we will learn about jQuery, which among many other things, allows
                us to flip the visibility of an element by invoking the show or hide function. </para>
            <para><emphasis role="bold">ReadOnly</emphasis> – It is common to use the UIF for
                building forms that will collect data and perform a process on behalf of the user.
                There are a variety of components, such as controls and widgets, that allow the user
                to input data. These components have a state of editable (user input is allowed) or
                read only (user input is not allowed). To indicate a component should be in the read
                only state we can set the readOnly property to true. Again, this is a property that
                expressions are generally used for that sets the state based on a condition. </para>
            <para>Since it varies how components allow user input, the impact of setting a component
                as read only as various. For example, read-only controls simply display the control
                value as HTML text. An action field, on the other hand (button, link, image), will
                not render when set to read only. </para>
            <para><emphasis role="bold">More Info:</emphasis> Components such as controls and action
                fields also support the _ disabled property. When these components are disabled they
                are in a read only state (no user input is allowed), however they are presented
                differently. Although the disabled appearance can be modified, generally the
                component appears as it does when editable (for example the actual control or button
                appears) but appears dimmed. The UIM provide guidelines for when to use disabled
                over readOnly. </para>
            <para>By default, the component base bean definitions have the readOnly property set as
                a condition on the read only status of the parent. Recall that our View represents a
                tree of components, where each component contains zero or more child components.
                This is often referred to as a parent-child relationship. All components with the
                exception of the View have a parent. Thus if the parent is read only, the child will
                be as well. </para>
            <para>One example of the parent-child relationships is the Container component. The
                purpose of a container is to hold other components and provide a layout. Therefore,
                the components in the container are child components and the container is the parent
                component.Setting the container component as read only will make all components
                within the contain read only. This is a convenient feature that simplifies
                configuration. For example, if we needed to make a group of fields read only, we can
                add the readOnly=”true” property to the container component instead of adding the
                property to each field. Furthermore, since the View contains all the components, we
                can add readOnly=”true” to make our entire web page read only. </para>
            <para>Some views are always read only. One example of this is the Inquiry view which
                displays information about a data object instance. The InquiryView base bean has the
                readOnly property set to true. Therefore all components add to a view of this type
                will be read only without having to specify the property. </para>
            <para><emphasis role="bold">Required</emphasis> – When a component allows user input,
                the required property indicates whether the user must provide a value (or complete
                the input/action). This is most typically used with input fields that have a control
                but can also be used with a container (group) to indicate a section must be
                completed (fields in the section must have input). Other components may use the
                required attribute in a way that is appropriate for the component. </para>
            <para>In the case of input fields, setting required to true will do a couple of things.
                First, a message will be displayed to the user indicating if it is required (by
                default an asterisk ‘*’). Second, the framework will perform validation client side
                and/or server side that checks a value was given. If the value is empty, an error
                message is created and presented to the user. </para>
            <para><emphasis role="bold">Style and Style Classes</emphasis> – KRAD provides a lot of
                flexibility to make your web applications look great! All UIF components have a
                configured style class that performs the visual treatment. These style classes are
                provided within the CSS files that come with KRAD. However, if needed, using the
                style properties we can add or override CSS configuration for each component. </para>
            <para>Inline style configuration can be specified using the style property. The value is
                then placed as the style attribute value for the corresponding HTML element.
                Likewise, style classes can be specified using the styleClasses property. This
                property is a list type with each list item specifying a style class. The configured
                style classes are concatenated into a string using a space delimiter, then outputted
                as the class attribute value for the corresponding element. </para>
            <para><emphasis role="bold">Progressive and Refresh</emphasis> – Component base contains
                several properties that related to configuring progressive disclosure or component
                refresh functionality. This is covered in detail in Chapter 11. </para>
            <para><emphasis role="bold">Order</emphasis> – KRAD adds some abilities to the Spring
                configuration system, including more control over collection merging. In a base bean
                definition that contains a collection, each component in the collection can have an
                order specified. When inheriting the collection property in child beans, components
                can be specified with the same order to replace items in the parent list or given an
                order that inserts the component between two items of the parent collection. This
                feature in covered in more detail at the end of this chapter. </para>
            <tip><para><emphasis role="bold">Read Only</emphasis>: As stated above, the feature of read
                only inheritance is done by s_ setting an expression on the readOnly property which
                is inherited. This configuration is as follows:
                <programlisting>&lt;property name="readOnly" value="@{#parent.readOnly}"/&gt;     </programlisting></para>
            <para>However the readOnly property can be overridden to specify another condition or to
                explicitly make the component editable. This can useful for cases when a few of the
                child components need to be editable, but the majority should be read only. We can
                set the parent as readOnly=”true” which will make all child component read only.
                Then we can add readOnly=”false” to the few components that should be editable. </para>
            </tip>
            <para><emphasis role="bold">Skip In Tab Order</emphasis> – By default, tabbing will
                follow the natural order of the elements and include each element that can accept
                focus. When needed, the element corresponding to the KRAD component can be taken out
                of the tab order (will not be tabbed to) by setting the skipInTabOrder Boolean to
                true. An example of where this might be needed is a widget. The widget might contain
                several elements that work together as one focusable item. Within the item, keyboard
                shortcuts can be provided for navigating to the various elements. The user can
                simply tab again to get out of the widget (instead of having to tab possibly several
                times). </para>
            <para>Finer grain control over the tabbing order can be configured as well using the
                tabIndex property of Control. </para>
            <para><emphasis role="bold">Finalize Method To Call</emphasis> – Although you can do a
                great number of things using XML, you also have the option of assembling components
                with code. One way to invoke code is with the finalizeMethodToCall. This is the name
                of a method on the ViewHelperServiceImpl that should be called during the finalize
                phase of the view lifecycle. Standard arguments to this method are the component
                instance and the model (view data). Two additional properties,
                finalizeMethodAdditionalArguments and finalizeMethodInvoker, exist for greater
                flexibility on invoking a method. Code support is covered in detail in Chapter 10. </para>
            <para><emphasis role="bold">Self-Render and Render Output</emphasis> – As described in
                the section on templates and Apache Tiles, most components are rendered by a JSP
                file that combines parameters from the components with static content to produce
                HTML markup. Components may render without a template by generating the markup
                through code. This is done by setting the selfRender flag to true. When this flag is
                turned on, instead of invoking a template, the method getRenderOutput will be
                invoked on the component instance to return the markup that should be outputted. </para>
            <tip><para><emphasis role="bold">Self-Rendered Content</emphasis>: The markup returned by a
                self-rendered component may not include JSP. The String is written directly to the
                response without going through JSP processing, therefore HTML markup must be
                returned. </para></tip>
            <para><emphasis role="bold">Component Security</emphasis> – KRAD allows for fine-grained
                security to be defined which integrates with the KIM (Kuali Identity Management)
                module. Security restrictions are indicated by setting a flag on an <emphasis
                    role="bold">org.kuali.rice.krad.uif.component.ComponentSecurity</emphasis>
                instance. When a flag is set, the framework will check a KIM permission (setup for
                that restriction type) and, if not granted to the user, the restriction will be
                activated. Particular security flags will be discussed while looking at each
                component. </para>
            <para><emphasis role="bold">Component Modifiers</emphasis> – Component modifiers are
                classes that can be configured on a component to modify its properties through code.
                A component may have one or more component modifiers that get applied in the order
                they are configured. Modifiers can be useful in many cases. For example, the
                maintenance framework supports a comparison view where an ‘old’ and ‘new’ field is
                presented for each field. To achieve this, a component modifier was created that
                reads the configured group fields copying each to make the ‘old’ field. Then a base
                bean was created with the component modifier configured. All maintenance groups then
                extend this bean and inherited the comparison feature. </para>
            <para>Component modifiers can also have a condition that determines whether it should
                run (the <emphasis role="bold">runCondition</emphasis>). In the example of the
                maintenance modifier, we only want to show the comparison when doing an edit
                operation (not for a new or copy). Therefore, the run condition is setup to check
                the maintenance action is edit. The framework will evaluate this condition and only
                invoke the modifier if the condition succeeds. </para>
            <para>There are many other things that can be done with component modifiers which will
                be covered in Chapter 10. </para>
            <para><emphasis role="bold">Template Options</emphasis> – Besides the properties a
                component class has, some component templates support options that can be configured
                using the <emphasis role="bold">templateOptions</emphasis> map. These can be thought
                of as ‘pass-through’ parameters since the component class is not aware of them. </para>
            <para>Template options are used primarily with Widgets that invoke a jQuery plugin. All
                jQuery plugins have a standard options map (or object since this is JavaScript) that
                configures the plugin options. This options map is created from the template
                options. </para>
            <tip><para><emphasis role="bold">Template Options</emphasis>: The generic template options
                map allows parameters to be _ added by the template without modifying the class.
                This can be useful when creating custom templates with options not originally
                supported by the component. In addition, this allows us to change our plugin
                implementations more easily. The options for the new plugin can be configured
                through the XML without having to change the class</para></tip>
            <para><emphasis role="bold">Property Replacers</emphasis> – Another tool provided by the
                UIF for component configuration are property replacers. A property replacer allows
                us to exchange the value for a bean (component) property based on a condition. For
                example, we can change the control for a field from a text control to a checkbox
                control if some condition is true. Or we might want to change out a complete list of
                container fields with another. In a sense, property replacers give us the capability
                to have if statements in our XML. </para>
            <para>A component may have one or more property replacers defined. In addition, one or
                more property replacers can be configured for the same property. Each property
                replacer whose condition passes will be applied, so the order in which they are
                configured can matter. Property replacers will be covered in Chapter 10. </para>
            <para><emphasis role="bold">Context</emphasis> – One very powerful of the UIF is the
                ability to use EL (Expression Language) statements in XML. The expressions are
                evaluated using the Spring EL framework. Spring EL allows us to define variables
                that can be referenced within the expressions. The UIF provides these variables from
                the component context map. </para>
            <para>Each entry of the context map represents a variable, where the map key is the name
                of the variable (how it will be referenced in the expression), and the map value is
                the value Spring should use for the variable. The framework adds standard variables
                to the context for all components. Some examples include the ‘view’ and ‘component’
                variables. Additional variables are added based on the component. For example,
                components within a collection group receive the variables ‘line’ and ‘index’ for
                referring to the current line. Finally, custom variables can be added to the context
                through the XML configuration for a component or by code. More information on
                expressions will be covered in Chapter 10. </para>
        </section>
        <section>
            <title> Script Event Support </title>
            <para>In addition to implementing the Component interface, ComponentBase implements the
                org.kuali.rice.krad.uif.component.ScriptEventSupport interface. This allows a
                component to specify whether a given jQuery event is supported and to retrieve or
                set the JavaScript code for that event. For example, let’s take the onblur event. If
                a component supports this event, it will implement the getSupportsOnBlur method and
                return true. Script for the onblur event can then be set through the XML by using
                the onBlurScript property. Finally, when rendering the component, the template tag
                will retrieve the onBlurScript and associate with the onblur event. A listing of all
                events and examples will be given in Chapter 11. </para>
        </section>
        <section>
            <title>Recap</title>
            <itemizedlist>
                <listitem>
                    <para>A UIF Component is anything that can be used to build a the application
                        user interface </para>
                </listitem>
                <listitem>
                    <para>To become an UIF component, a class must implement the interface
                        org.kuali.rice.krad.uif.component.Component </para>
                </listitem>
                <listitem>
                    <para>The component interface defines properties and behavior all components
                        must provide </para>
                </listitem>
                <listitem>
                    <para>Components can extend org.kuali.rice.krad.uif.component.ComponentBase
                        which provides properties and default implementations for the component
                        interface </para>
                </listitem>
                <listitem>
                    <para>The id property is an unique identifier for the component which can be
                        assigned in the xml with the property tag or by the bean id attribute
                    </para>
                </listitem>
                <listitem>
                    <para>The component id is used as the id for the element that is generated from
                        the component. On the client it can be used for scripting and styling
                    </para>
                </listitem>
                <listitem>
                    <para>The render property specifies whether html output for the component should
                        be generated. When set to false the component template is not invoked.
                    </para>
                </listitem>
                <listitem>
                    <para>The render property along with expressions give us the ability to
                        conditionally determine how a page will be displayed </para>
                </listitem>
                <listitem>
                    <para>For components that allow the user to interact with them, such as form
                        controls, the readOnly property can be set to not allow user interaction.
                    </para>
                </listitem>
                <listitem>
                    <para>By default, the read-only state is inherited by a component from its
                        parent. This allows us to easily set a group of components or the entire
                        page as read-only. </para>
                </listitem>
                <listitem>
                    <para>Any component can be styled by using the style and styleClasses
                        properties. The style property allows an inline style to be applied, while
                        the styleClasses allows us to apply one or more css class to the component.
                    </para>
                </listitem>
                <listitem>
                    <para>Component base contains properties for configuring progressive disclosure
                        and component refresh functionality </para>
                </listitem>
                <listitem>
                    <para>Although many things can be accomplished just with xml, code can be used
                        to set the component state by specifying a finalize method to call. </para>
                </listitem>
                <listitem>
                    <para>Components can output their html marked directly instead of using a
                        template. This is done by setting the selfRender property to true. </para>
                </listitem>
                <listitem>
                    <para>Component modifiers are classes that perform a modification on component
                        state. One or more modifiers can be configured for a component. </para>
                </listitem>
                <listitem>
                    <para>In addition to the properties defined by a component, the template can
                        have options that are passed through using the template options map. </para>
                </listitem>
                <listitem>
                    <para>Property replacers can be used to replace the value for a component
                        property based on a condition. </para>
                </listitem>
                <listitem>
                    <para>All components hold a context map which contains variables that can be
                        used for expressions that are evaluated for properties of that component.
                    </para>
                </listitem>
                <listitem>
                    <para>Components can indicate they support a jQuery (JavaScript) event which
                        allows script to be configured for that event. </para>
                </listitem>
            </itemizedlist>
        </section>
    </section>
    <section>
        <title>Types of Components </title>
        <para>Within the UIF component landscape, there are groupings of components which share
            similar properties and behaviors. With each component grouping, the framework provides
            an interface (extending Component) and base class. This allows sharing of properties and
            behavior for components within these grouping. In particular the base classes are
            important for the view processing, known as the view lifecycle. </para>
        <para>Another way to think of these component types is how we use them to build our web
            page. Recall each component is rendered to produce HTML markup (including script) thus
            our components are really a model HTML. Therefore, to understand the how the component
            groupings are formed it is helpful to first breakdown the various HTML tags and how they
            are assembled. </para>
        <section>
            <title>Content Elements </title>
            <para>HTML provides us tags (known as ‘elements’) we can specify that will be read by
                the browser to render some type of content. Examples of this include: <itemizedlist>
                    <listitem>
                        <para>&lt;a&gt; tag - Defines a hyperlink </para>
                    </listitem>
                    <listitem>
                        <para>&lt;button&gt; tag - Defines a clickable button </para>
                    </listitem>
                    <listitem>
                        <para>&lt;h1&gt; to &lt;h6&gt; tag - Defines HTML headings </para>
                    </listitem>
                    <listitem>
                        <para>&lt;img&gt; tag - Defines an image </para>
                    </listitem>
                    <listitem>
                        <para>&lt;label&gt; tag - Defines a label for an input element </para>
                    </listitem>
                </itemizedlist></para>
            <para>As we see by the tag descriptions, these tags and others like them generate some
                content that is visible to the user. The components that represent these tags (or
                will render these tags) are known as Content Elements. The following is a mapping of
                the above tags to its UIF component: <itemizedlist>
                    <listitem>
                        <para>&lt;a&gt; - ActionLink </para>
                    </listitem>
                    <listitem>
                        <para>&lt;button&gt; - ActionButton </para>
                    </listitem>
                    <listitem>
                        <para>&lt;h1&gt; to &lt;h6&gt; - Header </para>
                    </listitem>
                    <listitem>
                        <para>&lt;img&gt; - Image </para>
                    </listitem>
                    <listitem>
                        <para>&lt;label&gt; - Label </para>
                    </listitem>
                </itemizedlist></para>
        </section>
        <section>
            <title>Controls </title>
            <para>A special type of content element is one that allows the user to provide data
                input. These elements are known as Form Elements or Controls. Controls are only
                valid within an HTML form which will collect the data and post to a configured
                server location. Controls come in different types that determine how the user can
                provide data. Some HTML control examples are as follows: <itemizedlist>
                    <listitem>
                        <para>&lt;input&gt; - a control that allows the user to input data by typing
                            the value. Several different types of input controls are provided which
                            are configured by using the type attribute. Some available types include
                            ‘checkbox’, ‘file’, ‘hidden’, ‘image’, ‘radio’, ‘submit’, and ‘text’.
                        </para>
                    </listitem>
                    <listitem>
                        <para>&lt;textarea&gt; - a special type of input that renders a multi-line
                            text input </para>
                    </listitem>
                    <listitem>
                        <para>&lt;select&gt; - a control that allows the user to select a value from
                            a list of options </para>
                    </listitem>
                </itemizedlist></para>
            <para>Within the UIF, these types of components are also known as controls. Unlike the
                previous content elements, there is not a one-to-one mapping between the tag and
                control component. Instead, the UIF provides a component for each input type. Some
                examples include: <itemizedlist>
                    <listitem>
                        <para>&lt;input type=”text”&gt; - TextControl </para>
                    </listitem>
                    <listitem>
                        <para>&lt;input type=”file”&gt; - FileControl </para>
                    </listitem>
                    <listitem>
                        <para>&lt;input type=”checkbox”&gt; - CheckboxControl </para>
                    </listitem>
                    <listitem>
                        <para>&lt;textarea&gt; - TextAreaControl </para>
                    </listitem>
                    <listitem>
                        <para>&lt;select&gt; - SelectControl </para>
                    </listitem>
                </itemizedlist></para>
            <para>Controls all implement the org.kuali.rice.krad.uif.control.Control interface,
                which has the base class org.kuali.rice.krad.uif.control.ControlBase. </para>
        </section>
        <section>
            <title>Fields </title>
            <para>Besides the various content elements HTML provides us, we also can use tags that
                allow us to group content for layout purposes. One such element is the span. The
                span element defines a section of the document and includes one or more content
                elements. Essentially, it is a wrapper for other elements. </para>
            <para>Spans are very important for layout purposes. They give us the ability to put
                together more than one element and have it treated as a ‘block’ in the layout being
                employed. A good example of this is the pairing of a label and control, where the
                label should appear above the control. If we wanted several of these pairings to
                align in a horizontal row, we would need to resort to a table. Wrapping each pairing
                in a span, however, tells the browser these elements work together and should take
                up one place in the layout. Furthermore, the default display property for span
                elements in inline, so additional spans will align in a horizontal row. </para>
            <para>In the UIF, these span wrappers are known as Fields. There are several different
                Field components provided which have preset content elements, therefore you don’t
                have to do the work of composing a content element with a Field. Some examples
                include: <itemizedlist>
                    <listitem>
                        <para>InputField – Field that contains a control, information text, and
                            several other elements </para>
                    </listitem>
                    <listitem>
                        <para>ActionField – Field that contains an action button or action link
                        </para>
                    </listitem>
                    <listitem>
                        <para>LinkField – Field that contains a link </para>
                    </listitem>
                </itemizedlist></para>
            <para>In addition to wrapping content elements, the Field component also provides a
                label. This is a label for the span contents and its placement is configurable. </para>
            <para>All Fields implement the org.kuali.rice.krad.uif.field.Field interface, which has
                the base class org.kuali.rice.krad.uif.field.FieldBase. </para>
        </section>
        <section>
            <title>Containers </title>
            <para>So far in this section, we learned about the basic HTML content elements and the
                span wrapper. We could write a page with these elements, and the browser would
                render based on the order of these elements and their styling. However, in many
                cases we want to form larger groupings with their own layouts. For this, HTML
                provides the div element. </para>
            <para>The div element is similar to span in that it wraps elements. However, div
                elements are generally used to divide larger sections of the page and can include
                content elements, along with the span element. The UIF generates the div element
                using the <emphasis role="bold">Group</emphasis> component. </para>
            <para>The group component is an implementation of a more general type of UIF component
                named <emphasis role="bold">Container</emphasis>. The main job of container
                components is to hold a configured list of components and render them using a
                layout. A container is divided into three parts: the header, the body, and the
                footer. Generally, these appear in the user interface as show by the figure below: </para>
            <figure>
                <title>KRAD Containter Parts</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="../images/KRAD_Guide/KRAD_Container_Parts.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <para>Besides the group component, another type of container is a View. Views do many
                things in the framework that will be discussed throughout this manual, including the
                container duty. A view instance actually contains all other components of an
                interface. That is, a view is at the root of the component tree and is not contained
                within any other component. In addition, the container items we configure for a view
                must be groups (conceptually known as ‘Pages’). </para>
            <para>Containers may restrict the types of components they can hold. For example, KRAD
                provides a LinkGroup which is a type of group that only allows link components to be
                configured. Generally, these containers restrict the components they can hold so
                that they can provide more specialized properties and behavior. </para>
            <tip><para><emphasis role="bold">How do groups differ from fields?</emphasis> A field
                produces a span that wraps content _ elements and a group produces a div element
                that wraps content and span elements. They seem very similar! The important
                difference is a field is a preset composition of elements with a preset layout,
                while the group component and its layout can be configured. It is helpful to think
                of the field components as our palette to choose from, and the group component as
                our canvas! </para></tip>
        </section>
        <section>
            <title>Widgets </title>
            <para>Today we have the ability to do a lot more in our web applications, beyond using
                the basic HTML elements. With the use of JavaScript and frameworks such as jQuery,
                we can have features such as menus, tabs, trees, and dialogs in our user interface.
                These features are achieved by composing the HTML elements with script. Within the
                UIF components that generate such content are known as Widgets. </para>
            <tip><para><emphasis role="bold">Widget Templates:</emphasis> Although the majority of
                delivered widgets use jQuery, a _ widget template may invoke any script method or
                make use of other frameworks. </para></tip>
            <para>This is a component type that has a lot of variety. However, the commonality is we
                typically create widgets not by rendering HTML elements and attributes, but instead
                by invoking script. To be more specific, most widget templates invoke a jQuery
                plugin passing in parameters from the templateOptions map. </para>
            <para>We can also think of widgets as client side components. Unlike the other UIF
                components that generate their HTML markup server side, widgets generate content on
                the client during page load. Widgets are explained further in Chapter 8. </para>
        </section>
        <section>
            <title>Composition and Containers </title>
            <para>Just as HTML elements can be composed, so can the UIF components. These
                compositions can be fixed based on the property type, or variable. For example, the
                LinkField is a fixed composition of a Link component with the Field component:
                <programlisting>public class LinkField extends FieldBase {
    ...
    private Link link;
}   </programlisting></para>
            <para>An example of a variable composition is the Group container with the items list
                that can accept any component:
                <programlisting>public class Group extends ComponentBase { 
    ...
    private List&lt;Component> items;
}</programlisting></para>
            <para>Although it is possible to have any composition of components between the various
                types, there are certain guidelines: </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>Fixed Composition <itemizedlist>
                                <listitem>
                                    <para>All components can be composed of groups, fields,
                                        elements, and widgets </para>
                                </listitem>
                                <listitem>
                                    <para>Input fields can be composed of controls </para>
                                </listitem>
                            </itemizedlist></para>
                    </listitem>
                    <listitem>
                        <para>Variable Composition (Container) <itemizedlist>
                                <listitem>
                                    <para>Views are top level components and may not be contained in
                                        other components </para>
                                </listitem>
                                <listitem>
                                    <para>View can contain one or more groups </para>
                                </listitem>
                                <listitem>
                                    <para>Group can contain one or more groups, one or more fields,
                                        and one or more content elements with the exception of
                                        controls </para>
                                </listitem>
                                <listitem>
                                    <para>Group and views may NOT contain widgets </para>
                                </listitem>
                                <listitem>
                                    <para>Group and views may NOT contain controls </para>
                                </listitem>
                            </itemizedlist></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>The below figure depicts the composition of components.</para>
            <figure>
                <title>KRAD Component Hierarchy</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="../images/KRAD_Guide/KRAD_Component_Hierarchy.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </section>
        <section>
            <title>Recap</title>
            <itemizedlist>
                <listitem>
                    <para>The UIF contains groupings of components that have similar properties and
                        behavior </para>
                </listitem>
                <listitem>
                    <para>Each component grouping has an interface and base class </para>
                </listitem>
                <listitem>
                    <para>Content elements are components that generate an html content element
                    </para>
                </listitem>
                <listitem>
                    <para>A control is a special type of element component that allows the user to
                        provide data input </para>
                </listitem>
                <listitem>
                    <para>A field is a component that produces wraps a content element with a span
                    </para>
                </listitem>
                <listitem>
                    <para>Fields have an associated label </para>
                </listitem>
                <listitem>
                    <para>A container is a component that holds other components and applies a
                        layout </para>
                </listitem>
                <listitem>
                    <para>A container is divided into three parts: header, body, and footer </para>
                </listitem>
                <listitem>
                    <para>A group is a type of container that generates a div and lays out its
                        components using a layout manager </para>
                </listitem>
                <listitem>
                    <para>A view is the top most component and among many things holds groups known
                        as pages </para>
                </listitem>
                <listitem>
                    <para>A widget is a component that invokes script to create the UI elements
                        client side </para>
                </listitem>
                <listitem>
                    <para>Widgets are typically implemented using jQuery </para>
                </listitem>
                <listitem>
                    <para>Components may be composed with components of other types </para>
                </listitem>
            </itemizedlist>
        </section>
    </section>
    <section>
        <title>UIF Constants </title>
        <para>Besides the component classes, the UIF contains other services and utility classes
            that are helpful to be aware of. One of these is the UifConstants class. This contains
            constants that are used through the UIF. Some of these are constants that represent
            configuration options while others are used by the code. For those that can be used for
            configuration, the constant can be referenced using an expression and the ‘UifConstants’
            variable. For example @{#UifConstants.Placement.LEFT} refers to the LEFT enum value in
            the UifConstants class. </para>
        <para><emphasis role="bold">Position</emphasis> – The Position enum has values BOTTOM, LEFT,
            RIGHT, and TOP. This is used to configure where an element such be placed in relation to
            another. One use of this is for the field label. We can choose to put the label to the
            left of the contained field element, on top, to the right, or on the bottom. </para>
        <para><emphasis role="bold">Orientation</emphasis> – The Orientation enum has values
            HORIZONTAL and VERTICAL. This is used primarily by the Box layout manager to configured
            whether the elements should be aligned in a horizontal or vertical row. </para>
        <para><emphasis role="bold">View Type</emphasis> – The View Type enum gives the available
            types of view. A View Type (discussed in 13 is a subclass of the View or FormView
            components that provides specialized behavior. The out of the box view types are
            DEFAULT, DOCUMENT, INQUIRY, LOOKUP, MAINTENANCE, and INCIDENT. </para>
        <para><emphasis role="bold">Control Type</emphasis> – The Control Type enum gives the
            available controls and is used primarily when creating components through code. </para>
        <para><emphasis role="bold">Workflow Action</emphasis> – The Workflow Action enum gives
            available workflow document actions and is used primarily within the Document
            controllers. Values are SAVE, ROUTE, BLANKETAPPROVE, APPROVE, DISAPPROVE, CANCEL, FYI,
            and ACKNOWLEDGE. </para>
        <para><emphasis role="bold">Method To Call Names</emphasis> – This is an inner constants
            class that specifies the name of methodToCall parameter values (which map to controller
            names). </para>
        <para><emphasis role="bold">Action Events</emphasis> – This is an inner constants class that
            specifies action event names. Action events are a way of grouping types of actions that
            can be then used for logic or authorization. An example action event is “addLine”. </para>
        <para><emphasis role="bold">Id Suffixes</emphasis> – This is an inner constants class that
            declares id suffixes that are used throughout the framework. </para>
        <para><emphasis role="bold">View Phases</emphasis> – This is an inner constants class the
            names the three view phases: INITIALIZE, APPLY_MODEL, and FINALIZE. </para>
        <para><emphasis role="bold">View Status</emphasis> – This is an inner constants class the
            names the three view states: C (CREATED), I (INITIALIZED), and F (FINAL). </para>
        <para><emphasis role="bold">Context Variables Names</emphasis> – This is an inner constants
            class the holds the names for variables that can be used in expressions. These variables
            are listed in Appendix E. </para>
        <para><emphasis role="bold">Refresh Caller Types</emphasis> – This is an inner constants
            class the holds names of refresh callers. These can be used in return method to
            determine what type of view called the refresh. Values are LOOKUP, MULTI_VALUE_LOOKUP,
            and QUESTION. </para>
        <para><emphasis role="bold">EL Placeholder Prefix and Suffix</emphasis> – These constants
            specify the placeholders that indicate an expression in the XML. </para>
        <para><emphasis role="bold">Binding Prefixes</emphasis> – These constants specify prefixes
            that can be used within expressions for binding paths. Options are covered in Chapter
            10. </para>
        <para><emphasis role="bold">Other Constant Files</emphasis> - In addition to UifConstants
            there are the following constant files:<itemizedlist>
                <listitem>
                    <para>CssConstants – Constants for CSS strings </para>
                </listitem>
                <listitem>
                    <para>UifParameters – Constants for request parameter names. Some examples
                        include methodToCall, formKey, viewId, and pageId. </para>
                </listitem>
                <listitem>
                    <para>UifPropertyPaths – Constants for property binding paths. </para>
                </listitem>
                <listitem>
                    <para>KRADConstants – General constants for the KRAD module. These constants can
                        be referenced in XML by using the Constants variable. </para>
                </listitem>
            </itemizedlist>
        </para>
        <section>
            <title>Recap</title>
            <itemizedlist>
                <listitem>
                    <para>UifConstants provides enums and constant classes for configuration and
                        code strings </para>
                </listitem>
                <listitem>
                    <para>UifParameters contains constants for request parameter names </para>
                </listitem>
                <listitem>
                    <para>KradConstants provides constants for the KRAD module </para>
                </listitem>
                <listitem>
                    <para>UifConstants can be references in XML by using the UifConstants variable
                        (@{#UifConstants.constantname}), likewise KradConstants can be referenced
                        using the Constants variable (@{Constants.constantname}. </para>
                </listitem>
            </itemizedlist>
        </section>
    </section>
    <section>
        <title>UIF Bean Files </title>
        <para>As we learned in the UIF overview, each component has at least one base Spring bean
            definition and in many cases has more than one. KRAD ships with several base beans that
            are divided into files for better management and easier browsing. All of these ‘base
            bean’ files are located in the resource folder (src/main/resources) of the KRAD web
            module. Within the resources folder they are contained in the package
            org.kuali.rice.krad.uif. The below screen shot shows this package in the Intellij
            project pane. </para>
        <figure>
            <title>KRAD Intellij Project Pane</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="../images/KRAD_Guide/kradProjectPane.png"/>
                </imageobject>
            </mediaobject>
        </figure>
        <section>
            <title>UIF Configuration Definitions </title>
            <para>This file contains bean definitions that are related to component configuration.
                That is, the beans don’t represent components but classes that are used to configure
                a component. Some examples include component modifiers, history, binding info, and
                filters. </para>
        </section>
        <section>
            <title>UIF Control Definitions </title>
            <para>This file contains bean definitions for control components. Examples include
                TextControl, CheckboxControl, FileControl, and the SelectControl. </para>
        </section>
        <section>
            <title>UIF Document Definitions </title>
            <para>This file contains bean definitions that are related to the Document view type.
                This includes the Document View bean, common document group and field beans. </para>
        </section>
        <section>
            <title>UIF Field Definitions </title>
            <para>This file contains bean definitions for the various field components. Examples
                include DataField, InputField, ActionField, and ImageField. </para>
        </section>
        <section>
            <title>UIF Group Definitions </title>
            <para>This file contains bean definitions for the various group components. Multiple
                bean definitions are provided for the group component that different layout manager
                configuration. Examples include VerticalBoxGroup and HorizontalBoxGroup. In addition
                bean definition exist for the group level (page, section, and sub-section). Finally
                beans exist for the disclosure option and special types of groups like the
                TreeGroup. </para>
        </section>
        <section>
            <title>UIF Header Footer Definitions </title>
            <para>This file contains bean definitions for header and footer groups. Headers and
                footers are defined for various group levels (page, section, and sub-section), along
                with collection groups. Finally the basic h1 through h6 header components are
                defined. </para>
        </section>
        <section>
            <title>UIF Incident Report Definitions </title>
            <para> This file contains bean definitions that are related to incident report view.
            </para>
        </section>
        <section>
            <title> UIF Inquiry Definitions </title>
            <para>This file contains bean definitions that are related to Inquiry view. This
                includes the Inquiry View bean, and definitions for inquiry groups. </para>
        </section>
        <section>
            <title>UIF Layout Managers Definitions </title>
            <para>This file contains bean definitions for the provided layout managers. In addition,
                common layout manager configurations are provided as separate beans. </para>
        </section>
        <section>
            <title>UIF Lookup Definitions </title>
            <para>This file contains bean definitions for the Lookup view. This includes the Lookup
                View bean, and definitions for lookup groups. </para>
        </section>
        <section>
            <title>UIF Maintenance Definitions </title>
            <para>This file contains bean definitions for the Maintenance view. This includes the
                Maintenance View bean, and definitions for the maintenance groups. </para>
        </section>
        <section>
            <title>UIF Rice Definitions </title>
            <para>This file contains bean definitions for other Rice modules. Examples include the
                KIM person and KIM Group controls. </para>
        </section>
        <section>
            <title>UIF View Page Definitions </title>
            <para>This file contains bean definitions for the various view and page components. This
                includes the default View, Form View, and Page beans. Also included is the
                configuration for the base theme. </para>
        </section>
        <section>
            <title>UIF Widget Definitions </title>
            <para>This file contains bean definitions for the various widget components. Examples
                include DatePicker, Lightbox, Breadcrumbs, and Tree. </para>
            <para> Note a full listing of beans contained in the above files is given in Appendix A.
            </para>
        </section>
        <section>
            <title>Recap</title>
            <itemizedlist>
                <listitem>
                    <para> The UIF provides several bean definitions that are divided into files
                        based on type </para>
                </listitem>
            </itemizedlist>
        </section>
    </section>
    <section>
        <title>Styling and themes </title>
        <para>KRAD doesn’t stop with just rendering the HTML markup but also provides CSS to make
            your web applications look great! With the 2.0 release, you can choose to use one of two
            look-and– feels (known as <emphasis role="bold">Themes</emphasis>). Each theme has been
            created with default styling for all the delivered components. However, if you wish to
            change styling or create new components, all the hooks are provided for doing so. This
            section will explore the themes and how custom styling can be added. </para>
        <section>
            <title>View Theme </title>
            <para>The UIF provides the class org.kuali.rice.krad.uif.view.ViewTheme which contains a
                list of style sheet and script file paths. The ViewTheme is then set as a property
                of the View and its corresponding properties are referenced when rendering the HTML
                CSS and Script links. Thus it provides the base theme (or ‘Look and Feel’) for our
                page. </para>
            <para> In XML view themes can be created using the ‘Uif-ViewTheme’ bean:
                <programlisting>&lt;bean id="Uif-MyTheme" parent="Uif-ViewTheme">
    &lt;property name="stylesheets">
        &lt;list>
            &lt;value>/css/my.css&lt;/value> 
            ...
        &lt;/list>
    &lt;/property>
    &lt;property name="jsFiles">
        &lt;list>
            &lt;value>/script/my.js&lt;/value>
              ...
        &lt;/list>
    &lt;/property>
&lt;/bean>   </programlisting></para>
            <para>The 2.0 version of KRAD comes with two themes that can be used. The first of these
                is based on the previous KNS development framework and aims to achieve the same
                look. The main reason for developing this theme is so that existing application
                screens can be converted to KRAD while some remain in the KNS. The look and feel was
                updated to not use images (including the buttons); it also has various other
                improvements that allow for easier visual treatment (for instance changing the color
                scheme). </para>
            <para>The second theme is based on the Kuali Student open look with modifications for
                KRAD. By default, this is the theme configured in the base view definition. Both
                themes are defined in <emphasis role="bold">UifViewPageDefinitions.xml</emphasis>. </para>
            <tip><para><emphasis role="bold">Planned Feature: Dense Theme</emphasis> - For the 2.2 release a new
                    theme will be developed for KRAD that will be the replacement for the KNS
                    (legacy) theme. </para></tip>
        </section>
        <section>
            <title>Modifying Themes </title>
            <para>Themes can be easily modified on an application bases, view basis, or component
                basis. There are two ways to modify a theme. First we can create additional style
                sheets and script files that are included with our views. These files may set
                anywhere within the application web directory or be accessed through a different web
                server. To add the additional files, we use the additionalCssFiles and
                additionalScriptFiles properties on the view component:
                <programlisting>&lt;bean id=”MyView” parent=”Uif-FormView”> 
    ...
    &lt;property name=”additionalCssFiles”>
        &lt;list>
            &lt;value>/css/myView.css&lt;value> &lt;value>http://server.com/css/myView.css&lt;/value>
        &lt;/list>
    &lt;/property>
    &lt;property name=”additionalScriptFiles”>
    &lt;list>
        &lt;value>/script/myView.js&lt;/value>
        &lt;value>http://server.com/script/myView.js&lt;/value> 
     &lt;/list>
    &lt;/property>
&lt;/bean>    </programlisting></para>
            <para>Using bean inheritance, we can setup a new base view with the additional CSS
                and/or script files that other views inherit. Furthermore, individual views can add
                files as needed. </para>
            <para>Within the additional style sheets, we can override the provided style classes
                (see ‘Base Styles and Conventions’) or add new style classes. For example, we might
                want to add a new style class to all input fields, or buttons, or a new component we
                have developed. Once we have defined the style class, we must then associate it with
                a component. We can do this by using the styleClasses property. </para>
            <para>The styleClasses property is provided for all components and holds a list of class
                names that should be applied for that component. We can configure this property
                using the Spring list tag:
                <programlisting>&lt;bean id=”MyActionButton” parent=”Uif-PrimaryActionButton”>
    ...
    &lt;property name=”styleClasses”>
        &lt;list merge=”true”>
            &lt;value>customStyleClass&lt;value>
        &lt;/list>
    &lt;/property>
&lt;/bean>   </programlisting></para>
            <para>Recall that in order to inherit collection configuration from a parent bean, we
                must using the Spring tags and add merge=”true”. It is recommended that the default
                style classes always be inherited. </para>
            <para>The configured styleClasses are then specified as the class attribute on the
                rendered HTML element:
                <programlisting>&lt;button id=”MyActionButton” class=”uif-primaryActionButton customStyleClass”  ... /&gt;  </programlisting></para>
            <para>Notice the uif-primaryActionButton class. This was inherited from the
                Uif-PrimaryActionButton bean. </para>
            <para>The second way to modify themes is by providing inline styling information. This
                is accomplished by using the style property that is available on all components.
                This property is then used to set the corresponding style attribute on the rendered
                HTML element (known as inline styling). </para>
            <programlisting>&lt;bean parent=”Uif-BoxGroupSection” p:style=”border: 1px;”&gt; 
...    </programlisting>
        </section>
        <section>
            <title> Base Styles and Conventions </title>
            <para>All of the provided components have a style class configured by default. These
                style classes are configured in the base bean definition(s) for the component.
                Similar to the naming convention employed for the bean ids (starting with ‘Uif-‘),
                the class names all begin with ‘uif-‘. After the prefix the class names closely
                match the bean name (with the exception of casing). As an example let’s look at a
                few of the provided action definitions:
                <programlisting>&lt;bean id="Uif-ActionImage" ...
    &lt;property name="styleClasses">
        &lt;list merge="true">
            &lt;value>uif-actionImage&lt;/value>
        &lt;/list>
    &lt;/property>

&lt;bean id="Uif-PrimaryActionButton" ... 
    &lt;property name="styleClasses">
        &lt;list merge="true">
            &lt;value>uif-primaryActionButton&lt;/value>
        &lt;/list>
    &lt;/property>

&lt;bean id="Uif-SecondaryActionButton" ...
    &lt;property name="styleClasses">
        &lt;list merge="true">
            &lt;value>uif-secondaryActionButton&lt;/value>
        &lt;/list>   
    &lt;/property>      

&lt;bean id="Uif-ActionLink" ... 
    &lt;property name="styleClasses">
        &lt;list merge="true">
            &lt;value>uif-actionLink&lt;/value>
        &lt;/list>
    &lt;/property>     </programlisting></para>
            <para>Notice the style class configured for each bean. </para>
            <para>In addition to providing the style class per component, the base beans are also
                setup to inherit classes from the parent (with the merge=”true”). A good example of
                this is the stacked collection group section:
                <programlisting>&lt;bean id="Uif-StackedCollectionSection" parent="Uif-StackedCollectionGroup">
    &lt;property name="styleClasses">
        &lt;list merge="true">
            &lt;value>uif-stackedCollectionSection&lt;/value>
        &lt;/list>
    &lt;/property>   </programlisting></para>
            <para>As in the previous examples, we are applying a style class for the component named
                ‘uif- stackedCollectionSection’. Now, let’s walk up the bean hierarchy and look at
                the style classes we are adding:
                <programlisting>&lt;bean id="Uif-StackedCollectionGroup" parent="Uif-CollectionGroupBase">
    &lt;property name="styleClasses">
        &lt;list merge="true">
            &lt;value>uif-stackedCollectionGroup&lt;/value>
        &lt;/list>
    &lt;/property>
    
&lt;bean id="Uif-CollectionGroupBase" parent="Uif-GroupBase"/>
    &lt;property name="styleClasses">
        &lt;list merge="true">
            &lt;value>uif-collectionGroup&lt;/value>
        &lt;/list>
    &lt;/property>

&lt;bean id="Uif-GroupBase">
    &lt;property name="styleClasses">
        &lt;list>
            &lt;value>uif-group&lt;/value>
        &lt;/list>
    &lt;/property>    </programlisting></para>
            <para>So we can see the combined list of style classes applied will be ‘uif-group
                uif-collectionGroup uif-stackedCollectionGroup uif-stackedCollectionSection’. This
                gives a lot of tremendous amount of flexibility for styling since we have many
                levels at which to define styling. We can configure styling that applies to all
                groups (uif-group), then all collection groups (uif- collectionGroup), then all
                collection groups that have the stacked layout (uif- stackedCollectionGroup) and
                finally all collection groups with stacked layouts that are rendered at the section
                level (uif-stackedCollectionSection). At each level, we can add or modify styling. </para>
            <para>Suppose we had declared the following styles in our CSS file:
                <programlisting>uif-group { 
    padding : 10px;
    margin : 10px;
}

uif-collectionGroup {
    padding : 20px; 
}

uif-stackedCollectionGroup {
    border : 1px;  
}   </programlisting></para>
            <para>The applied styling for the generated element will then have a padding 20px,
                margin 10px, and border 1px. </para>
            <tip><para><emphasis role="bold">Do we need all these style classes?</emphasis> As you have
                likely determined by _ now, there are a lot of these bean definitions provided by
                KRAD, and therefore that means there are many style classes applied. Many of these
                style classes do not have a corresponding definition within the CSS files. However
                they are provided to give greater flexibility for custom CSS. For example, suppose
                the default theme did not add styling for action link therefore a style class was
                not declared in the bean. Now a KRAD application wishes to add styling for action
                links. They would first need to override the bean definition to add the class for
                the component. Instead with it already being provided, they can just add the
                declaration in their custom style sheets without any modifications to the
                application code!</para></tip>
        </section>
        <section>
            <title>Fluid Skinning System </title>
            <para>KRAD also comes bundled with the Fluid Skinning System
                <link xlink:href="http://www.fluidproject.org/">(http://www.fluidproject.org/</link>). The skinning system contains a set
                of CSS files with classes that can be used for styling and layout. For example there
                are many useful classes for text styling (size, color). Any of these may be used by
                adding the class name in the styleClasses property. More information on using Fluid
                for CSS layouts will be covered in Chapter 7. </para>
        </section>
        <section>
            <title>Recap</title>
            <itemizedlist>
                <listitem>
                    <para>A base set of CSS and script files is configured in a view theme object
                        which is then set on the view component </para>
                </listitem>
                <listitem>
                    <para>KRAD provides two themes in the 2.0 release. One is a legacy theme based
                        on the KNS framework. The second is a new theme based on the KNS open look
                        and feel </para>
                </listitem>
                <listitem>
                    <para>Additional CSS and script files can be added to the view using the
                        additionalCssFiles and additionalScriptFiles properties </para>
                </listitem>
                <listitem>
                    <para>A list of style classes that should be applied are configured on the
                        component using the styleClasses property </para>
                </listitem>
                <listitem>
                    <para>Inline styles can be declared for a component using the style property
                    </para>
                </listitem>
                <listitem>
                    <para>Each UIF base bean has a style class configured by default. Each class
                        name begins with ‘UIF-‘</para>
                </listitem>
                <listitem>
                    <para>Style classes are inherited by parent bean definitions resulting in
                        multiple applied classes </para>
                </listitem>
                <listitem>
                    <para>The multiple style classes provide flexibility to configure styling at
                        different levels (corresponding to the bean inheritance) </para>
                </listitem>
                <listitem>
                    <para>KRAD includes the fluid skinning system which can be used for additional
                        styling needs and CSS layouts </para>
                </listitem>
            </itemizedlist>
        </section>
    </section>
    <section>
        <title>KRAD Spring Extensions </title>
        <para>KRAD implements a few extensions to the Spring configuration system that allow for
            easier configuration of collections and more flexibility on merging. As we saw in
            Chapter 1 configuring collections requires the use of special Spring tags. These
            additional tags add a lot to the overall verboseness of the XML and the time spent
            writing it. KRAD helps with this problem by allowing List and Map values to be specified
            as a string using established delimiters. </para>
        <para>For populating a list with a single string value the individual entries are delimited
            using a comma. For example:
            <programlisting>p:listProperty=”item1,item2,item3”    </programlisting> or
            <programlisting>&lt;property name=”listProperty” value=”item1,item2,item3”/&gt;</programlisting>
            is equivalent to:
            <programlisting>&lt;property name=”listProperty”>
    &lt;list>
        &lt;value>item1&lt;/value>
        &lt;value>item2&lt;/value>
        &lt;value>item3&lt;/value>
    &lt;/list>
&lt;/property>     </programlisting></para>
        <para>As a consequence of using the comma delimiters, list entries that contain a comma may
            not use the shorthand configuration but must instead using the Spring list tag. </para>
        <para>Maps can also be populated using the shorthand string configuration. Similar to a
            list, each entry is delimited by a comma. For each entry, the key and value parts are
            separated using a colon. For example:
            <programlisting>p:mapProperty=”key1:value1,key2:value2,key3:value3”    </programlisting>
            or
            <programlisting>&lt;property name=”mapProperty” value=”key1:value1,key2:value2,key3:value3” /&gt;     </programlisting>
            is equivalent to:
            <programlisting>&lt;property name=”mapProperty”>
    &lt;map>
        &lt;entry key=”key1” value=”value1”/>
        &lt;entry key=”key2” value=”value2”/>
        &lt;entry key=”key3” value=”value3”/>
    &lt;/map>
&lt;/property>   </programlisting></para>
        <para>If any of the map keys or values contains a comma or colon, we must use the Map tag
            instead of the shorthand configuration. </para>
        <para>When using the shorthand notation two other limitations should be understood. The
            first is when this is used on a child bean, any entries specified on a parent bean will
            be overridden. That is, this is like leaving the merge attribute of the collection tag
            or specifying merge=”false”. Therefore when entries need to be merged with the parent
            bean definition, the Spring collection tags must be used. </para>
        <para>The second limitation is with generics (Java 1.5). When populating a collection,
            Spring will read generic information to determine how to convert the configured value.
            For example, suppose we had a List&lt;Integer> property type. Spring will then attempt
            to convert each list value to an Integer type. When using the shorthand string
            configuration, no type conversion on the entries is performed. Therefore, only
            collections of string type are supported (for example List&lt;String> or just List). </para>
        <tip><para><emphasis role="bold">Property Value Type Conversion</emphasis>: The shorthand
            configuration being _ described here was implemented using a feature of Spring that
            allows us to specify PropertyEditor classes that can be used to convert values
            configured in the XML. A PropertyEditor is a core Java interface that is invoked to
            convert a value of one type to another type. Two property editor implementations were
            created and configured with the bean container. The first converting a String to List,
            and the second converting a String to Map. Property editors are also used to provide
            formatting of values in the UI. This will be discussed in Chapter 6. </para></tip>
        <section>
            <title>Merge Ordering </title>
            <para>When inheriting configuration from a parent bean definition (using the parent
                attribute), we can merge collection entries from the child to parent definition by
                adding merge=”true” to the collection tag. Spring performs the merging by adding the
                entries on the child definition to the end of the entries of the parent. For example
                if our parent bean specifies entries ‘item1’ and ‘item4’, then the child specifies
                items ‘item3’ and ‘item5’, the resulting collection will have entries with the
                following order: ‘item1’,‘item4’,’item3’,’item5’. In the majority of cases this is
                fine. However when the order of items within the collection make a functional
                difference, only being able to merge entries at the end of the collection can be a
                hindrance. </para>
            <para>Within the UIF, many collections do represent a case where the order matters. One
                example is the Group component which has a list of component items and a Layout
                Manager. These items will be rendered on the page based on the order in which they
                appear in the collection. </para>
            <para>Therefore a property named ‘order’ was added to all components (ComponentBase)
                that can be used to declare where the component should be placed in the collection
                when merging. </para>
            <para>To make use of this functionality, we must first setup the collection items in the
                base bean to have an order value:
                <programlisting>&lt;bean id=”MyPage” parent=”Uif-Page”>
    ...
    &lt;property name=”items”>
        &lt;list>
            &lt;bean id=”Section1” parent=”Uif-GridSection” p:order=”100”>
            &lt;bean id=”Section2” parent=”Uif-GridSection” p:order=”200”>
            &lt;bean id=”Section3” parent=”Uif-GridSection” p:order=”300”>
        &lt;/list>
    &lt;/property>
    &lt;property name=”itemOrderingSequence” value=”101”/>   </programlisting></para>
            <para>Notice a couple of things here. First the order was specified for each item such
                that there is a range of integers that fall between each (&lt;100, 100-200, 200-300,
                >300). The second is the property value of 101 for itemOrderingSequence. </para>
            <para>Now, let’s assume we want to create a page that extends from ‘MyPage’. For our
                page, we need to add two sections. However, when these sections are rendered, the
                first section should be between ‘Section1’ and ‘Section2’, and our second section
                should be after ‘Section3’. This can be done as follows:
                <programlisting>&lt;bean id=”AnotherPage” parent=”MyPage”>
    ...
    &lt;property name=”items”>
        &lt;list merge=”true”>
            &lt;bean id=”Section4” parent=”Uif-GridSection”>
            &lt;bean id=”Section5” parent=”Uif-GridSection” p:order=”320”>
        &lt;/list>
    &lt;/property>   </programlisting></para>
            <para>That’s it! So what happened? First we need to understand the rules of merging when
                the order property is given: <orderedlist>
                    <listitem>
                        <para>If a component item does not have an order value, it will be assigned
                            a value starting with the specified itemOrderingSequence. This sequence
                            gets incremented by one each time it is used to assign an order value.
                        </para>
                    </listitem>
                    <listitem>
                        <para>The combined collection of items is then sorted by ascending order
                            values. </para>
                    </listitem>
                    <listitem>
                        <para>If an item from the child bean has the same order as an item from the
                            parent bean, it will replace that item. </para>
                    </listitem>
                </orderedlist></para>
            <para>Applying these rules to our example we see that ‘Section4’ will get an assigned
                order value or ‘101’, thus it will be placed between ‘Section1’ and ‘Section2’ which
                have order values of 100 and 200 respectively. Finally ‘Section5’ will be placed
                after ‘Section3’ since it has an order of 320 which is greater than 300. The final
                ordering is ‘Section1, Section4, Section2, Section3, Section5’. </para>
        </section>
        <section>
            <title>Recap</title>
            <itemizedlist>
                <listitem>
                    <para>KRAD provides extensions to spring that allow for easier configuration of
                        collections and more flexibility.</para>
                </listitem>
                <listitem>
                    <para>List and map property values can be specified using a string value </para>
                </listitem>
                <listitem>
                    <para>For lists, each entry is delimited using a comma </para>
                </listitem>
                <listitem>
                    <para>For maps, each entry is delimited using a comma, with each key/value pair
                        delimited using a colon </para>
                </listitem>
                <listitem>
                    <para>Shorthand string configuration cannot be used if merging is required
                    </para>
                </listitem>
                <listitem>
                    <para>Shorthand string configuration cannot be used if list or map entry types
                        are non-string </para>
                </listitem>
                <listitem>
                    <para>For lists of component, the order property can be given to control where
                        in the merged list the component will be placed </para>
                </listitem>
                <listitem>
                    <para>Component items from a parent bean can be overridden with a child item by
                        using the same order value </para>
                </listitem>
            </itemizedlist>
        </section>
    </section>
</chapter>
