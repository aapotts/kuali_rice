<?xml version='1.0' encoding='UTF-8'?>
<!--

    Copyright 2005-2012 The Kuali Foundation

    Licensed under the Educational Community License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.opensource.org/licenses/ecl2.php

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->
<chapter xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://docbook.org/ns/docbook" xml:id="groups" version="5.0">
  <title>Groups </title>
  <section>
    <title>Groups </title>
    <para>In the last chapter we learned a great deal about the Content Element and Field
            component types. These types are essentially KRAD representations of the HTML content
            markup. They form the palate from which to paint our picture. </para>
    <para>In this chapter, we will move on to the Group component. This is one of the general
            Container types in KRAD. These allow us to bundle our fields together and structure them
            for layout purpose. In other words, they allow us organize our content into the top most
            container, the view.</para>
    <para>A group component is represented by the org.kuali.rice.krad.uif.container.Group class.
            This is the ‘general’ group component, meaning there are no restrictions on the type of
            fields or content elements we can put into the group. Other special group types exist
            that allow only a subset of fields and elements. They do this to target a more specify
            behavior. For example, the LinkGroup only supports adding Link components. These group
            types have a class that extends the Group class and add properties specific to the
            behavior or rendering they provide.</para>
    <para>Besides holding fields and content elements, groups can also contain other groups.
            This means we can nest groups within each other. Although a simple concept, it becomes
            very powerful in terms of building our view. Essentially we can break complete web page
            up into several group layers. This process will be discussed more in the next
            section.</para>
    <para>As we stated in the UIF Overview, there are common properties for all containers. The
            first of these is of course the container ‘items’. This is the list of components that
            belong to the container. By itself, the items lists just performs grouping of the
            components, it tells us nothing about how the items should be arranged on the page. For
            this information, an object called a Layout Manager is associated with the group. The
            layout manager encapsulates the information for how to arrange and decorate the items.
            Therefore, the same group can be reused and presented in different ways we changing its
            associated layout manager. A large part of this chapter will discuss the concept of
            layout managers and the particular managers provided by KRAD out of the box.</para>
    <para>The items that are rendered form the majority of the group’s contents. However, we can
            configure additional content before and after the container items. The before content is
            known as the group’s header, while the after content is known as the group’s footer. In
            code the corresponding objects found on group are the Header and Footer groups. The
            Header component contains another group itself. But in addition containing a group with
            configurable items, it also generates a HTML header tag (h tag) using the Header content
            element. The header generally indicates visually the beginning of the group
            presentation. The footer is just a standard group. It adds nothing special and is simply
            known as the footer because of if falls after the main group content.</para>
    <para>The group also allows an instructional text message to be configured. Similar to the
            input field instructional message, this gives directions to the user for completing the
            form. However, this applies to the group as a whole and not to an individual field.
            Finally, also similar to the input field, the group contains an errors field component.
            This is used for presenting error/warning/info messages that apply to the group
            contents, or to display message counts.</para>
    <para>The group template controls how these various pieces are rendered. Basically the
            rendering order is: header group, instructional message, errors field, container items
            (delegate to layout manager), and footer. </para>
    <para>Ok, so where’s the beans? There are several base beans provided for group (they
            actually have their own file ‘UifGroupDefinitions.xml’). These correspond to various
            layout manager configurations and the special types of groups. Therefore we will cover
            the beans with each subsequent section. </para>
    <note>
      <title>Group Base Bean</title>
      <para>An abstract bean with name ‘Uif-GroupBase’ is provided&#160;from which all the group
                beans extend. This sets the class, template, base style, errors field setup, and
                some disclosure options. The use of abstract base beans is done throughout the
                framework to match the abstract classes. Included in this is a top level bean named
                ‘Uif-ComponentBase’. Therefore the bean hierarchy closely resembles the actual class
                hierarchy. </para>
    </note>
    <section>
      <title>Recap</title>
      <itemizedlist>
        <listitem>
          <para>The group component allows us to bundle together components for layout
                            purposes</para>
        </listitem>
        <listitem>
          <para>The base group component is generic and can hold any field or content
                            element</para>
        </listitem>
        <listitem>
          <para>More special groups exist the extend group and restrict the type of
                        components that can be added. They do so to target more specific behavior or
                        rendering. An example is the link group</para>
        </listitem>
        <listitem>
          <para>Groups can nest within each other, therefore we can organize our entire
                        view with groups</para>
        </listitem>
        <listitem>
          <para>Groups have an associated object called a layout manger. The layout
                        manager encapsulates information on how to present the group’s
                        items</para>
        </listitem>
        <listitem>
          <para>We can easily reuse a group and change it presentations by switching
                        layout managers</para>
        </listitem>
        <listitem>
          <para>Groups also allow content to be added before the group items and after.
                        The before content is configured with a header group, and the after content
                        with a group footer</para>
        </listitem>
        <listitem>
          <para>Instructional text message can also be configured for the group. It gives
                        the users directions on how to complete the set of fields within the
                        group</para>
        </listitem>
        <listitem>
          <para>Like input fields, groups have an associated errors group. This errors
                        group display error/warning/info messages related to the group in general
                        (or display message counts)</para>
        </listitem>
        <listitem>
          <para>The group template controls how the various group parts are rendered. The
                        default template rendering order is: header group, instructional message,
                        errors field, group items (delegates to layout manager), and the
                        footer</para>
        </listitem>
        <listitem>
          <para>Several group base beans are provided that correspond to various
                        configurations with various layout managers</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>
  <section>
    <title>Page Decomposition with Groups </title>
    <para>Let’s look more closely at how we use groups to organize our user interface contents
            into one single view. So far we have learned that the view and group components are
            container types. Let’s think of a container as an area of the screen enclosed by a box
            shape. With this in mind, we are going to work through the process of reverse
            engineering an interface (assume we have a mock or wireframe) into the view and group
            containers.</para>
    <para>First we start with one large box that will cover the entire interface (everything in
            the window, with the exception of any application header or footer such as the portal
            wrapper).</para>
    <figure>
      <title>One Large Box</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="../images/KRAD_Guide/pageLargeTextbox.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>This top level box will be our view container. The view is always at the top of the
            hierarchy (not nested within any other component). To do the further breakdown, we need
            to know the parts of a view component. We will cover this more in 9, but besides the
            standard container properties (header, footer, items) we also have a navigation and
            breadcrumbs component that take up space within the view ‘box’. In the ‘classic’ view
            template provided with KRAD the navigation can be a left vertical menu or a top
            horizontal row of tabs. The view breadcrumbs are rendered at the top of the page,
            followed by the view header. The view footer will be the very last thing rendered.
            Assuming our mock has all of these (which we can take out as needed) let’s then block
            off those areas:</para>
    <figure>
      <title>Full View Page</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="../images/KRAD_Guide/fullViewPage.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>Notice after we mark off the pieces of the view we have an area left for content. This
            is where we can add content with a Group component. This top level group (with view
            parent) is known as a <emphasis role="bold">Page</emphasis> and has a base bean named
            ‘Uif-Page’. Since each item in our view navigation will replace the page contents, we
            can have multiple Page components associated with the view. These page components are
            thus configured through the view’s items list (from the Container interface). </para>
    <para>At this point, we could start adding field or content elements to our page group.
            However, unless our page is very simple, we likely want to provide further groupings on
            the page contents. This will allow the user to clearly see fields that go together and
            provide a cleaner organization to our page. So to do this we break our page into a set
            of vertical boxes, each known as a section:</para>
    <figure>
      <title>Vertical Sections</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="../images/KRAD_Guide/verticalSections.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>Here we see we have divided the page into three groups. A group at this level is known
            as a <emphasis role="bold">Section</emphasis>. Again we could now add content to one or
            all of our sections, but there might be a case where we need to divide again. Thus we
            can break each section into a set of vertical boxes. These are known as
            sub-sections:</para>
    <figure>
      <title>Vertical SubSections</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="../images/KRAD_Guide/verticalSubSections.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>The first section we have divided into two groups and likewise for the third section.
            A group at this level is called a <emphasis role="bold">Sub-Section</emphasis>.</para>
    <para>There are a couple of things that should be noted from the example. First, each group
            breakdown (section, sub-section) does not necessary have the same height. The heights
            can vary based on the contents. Furthermore, they do not necessary have to stack
            vertically one on top of another. This depends on the layout manager we use for the
            parent group. Finally, the actual type of group (whether it the base group, collection
            group, or whatever) does not matter. It is the level at which the group is at that makes
            the different in our conceptual naming. Below gives us another picture of the conceptual
            groupings. </para>
    <figure>
      <title>Conceptual Groupings</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="../images/KRAD_Guide/KRAD_Conceptual_Groupings.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>So what is the point of this? These are all just group components so why not just call
            them that? That is a true point. However, recall we can have multiple bean definitions
            for the same component. Therefore the UIF provides a set of bean definitions with names
            that correspond to these levels. These do various things for us. For example:</para>
    <orderedlist>
      <listitem>
        <para>Set up the correct header level for the corresponding group level. That way,
                    by correctly using the group levels for nesting, the generated headers will
                    reflect the nested group (will not end up with an h2 header within a group with
                    an h4 header).</para>
      </listitem>
      <listitem>
        <para>Defaults for the group’s errors field will be setup based on best
                    practice.</para>
      </listitem>
      <listitem>
        <para>Additional style classes are added for the group level so that padding and
                    other visual treatments can be given.</para>
      </listitem>
    </orderedlist>
    <para>In general, it gives us a hook to treat groups different based on where they are at in
            the view. Besides the technical benefits, these names help to create a language between
            page designers and developers for working together to create the user interface. </para>
    <note>
      <title>Levels Past Sub-Section</title>
      <para>There is no limit enforced for how deep groups can&#160;nest. Therefore if needed you
                can nest groups within a sub-section and further down. However, base beans are not
                provided in these cases so you need to take care to set the header levels, error
                configuration, and styling for these levels (or develop the base beans to represent
                them).</para>
    </note>
    <section>
      <title>Recap</title>
      <itemizedlist>
        <listitem>
          <para>Our entire interface can be broken down with the view component and a set
                        of groups</para>
        </listitem>
        <listitem>
          <para>We can decompose our page by drawing boxes and dividing</para>
        </listitem>
        <listitem>
          <para>We start by drawing a box around the window content (excluding any
                        application header and footer such as portal navigation). This first box
                        makes up the view content area.</para>
        </listitem>
        <listitem>
          <para>Besides the standard container parts (header, items, footer), the view
                        also contains a navigation and breadcrumbs component that takes up a ‘box’
                        of the view </para>
        </listitem>
        <listitem>
          <para>After boxing the view header, footer, navigation, and breadcrumbs, the
                        remaining content area is a group known as the page. </para>
        </listitem>
        <listitem>
          <para>If we have navigation, the page contents can change for each navigation
                        link. Thus the view can contain multiple page components which are set in
                        the view’s items property</para>
        </listitem>
        <listitem>
          <para>If we have a simple page, we can start adding fields directly to the page
                        group. However generally we want make grouping of the page content. This is
                        done by dividing the page into multiple groups. A group at this level is
                        known as a section.</para>
        </listitem>
        <listitem>
          <para>We can continue by dividing a section into groups. A group at this level
                        is called a sub-section.</para>
        </listitem>
        <listitem>
          <para>Although these different levels are all still a group component, KRAD
                        provides different bean definitions corresponding to the levels.</para>
        </listitem>
        <listitem>
          <para>Using the correct bean definition for a level ensures the header order
                        will be correct for nested headers. In addition defaults for the associated
                        errors fields at each level have been setup, and style classes are provided
                        to provide indenting and other visual cues.</para>
        </listitem>
        <listitem>
          <para>You can nest groups down as many levels as needed. However going past the
                        sub-section level care needs to be taken to correct set the header levels,
                        error configuration, and styling.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>
  <section>
    <title>Headers </title>
    <para>The Header component is used to render the various HTML header tag (h1, h2, h3, ..
            h6).&#160; Similar to the errors field component, there are header component instances
            already associated and configured for containers (view and group). These are generally
            used to indicate the start of a container on the page and to give a title for that
            container. If needed, the header component can be used in other places of the view as
            well (for instance in a group’s items list). However it is generally better to create
            nested groups in those situations.</para>
    <para>Besides rendering the HTML ‘h’ tag, the header element contains a nested group that
            can be used to add field components. Thus with this group we can configure links or
            other content type to display within the header part of the group. </para>
    <note>
      <title>Header Container</title>
      <para>HTML 5 provides the header tag which is meant to&#160;represent a block of content that
                introduces the main content. This gives more semantic meaning that use of just the
                div tag. The KRAD Header component is more in line with header tag than the h tag,
                although it generates a h tag as well.</para>
    </note>
    <para>The Header content element contains two custom properties. The first of these is the
                <emphasis role="bold">headerText</emphasis> property. This property gives the text
            that will display as the header. The second property is <emphasis role="bold">headerLevel</emphasis>. This is a string that corresponds one of the header levels
            supported by HTML (‘h1’, ‘h2’, .. ‘h3’).</para>
    <para>Base bean definitions for the header components are found in
            UifHeaderFooterDefinitions.xml. For the Header component, a base bean is provided for
            each of the header levels 1-6. These are named: ‘Uif-HeaderOne’, ‘Uif-HeaderTwo’,
            ‘Uif-HeaderThree’, ‘Uif-HeaderFour’, ‘Uif-HeaderFive’, and ‘Uif-HeaderSix’. To create a
            header component, we add a new bean using one of these as our parent. For
            example:</para>
    <programlisting>
&lt;bean parent=”Uif-HeaderOne’ p:headerText=”Big Header”/&gt;
        </programlisting>
    <para>This would result in the following HTML markup:</para>
    <programlisting>
&lt;h1 class=”uif-header”&gt;Big Header&lt;/h1&gt;
        </programlisting>
    <para>The use of one of the other beans would change the h tag to the corresponding h tag
            for that level.</para>
    <para>As mentioned at the start of this section, we generally work with header components
            through a container (the view or group containers). Within the container is a nested
            header component. This allows us to not only generate a header element, but also to
            configure content that will render within the header area. For each container level,
            there are header component bean configured. However, instead of being named by the
            header level, they are named by the container level they are associated with. These
            include:</para>
    <para>Uif-ViewHeader – Header associated with the view container. Uses a header one and adds
            the style class ‘uif-viewHeader’ to the group div.</para>
    <para>Uif-PageHeader – Header associated with the page container. Uses a header two and adds
            the style class ‘uif-pageHeader’ to the group div.</para>
    <para>Uif-SectionHeader – Header associated with the section container. Uses a header three
            and adds the style class ‘uif-sectionHeader’ to the group div.</para>
    <para>Uif-SubSectionHeader – Header associated with the sub-section container. Uses a header
            four and adds the style class ‘uif-subSectionHeader’ to the group div.</para>
    <para>By default the header components are already initialized in the corresponding group
            definition. Therefore we can use the nested syntax to set properties like in the
            following example:</para>
    <programlisting>
&lt;bean id=”MySection” parent=”Uif-VerticalBoxSection” p:header.headerText=”Section 1 Title”&gt;
        </programlisting>
    <para>For specifying the header text, containers give us a special property named title.
            When this is set the value will be pushed to the headerText property on the nested
            header element:</para>
    <programlisting>
&lt;bean id=”MySection” parent=”Uif-VerticalBoxSection” p:title=”Section 1 Title”&gt;
        </programlisting>
    <para>The resulting header is shown below. </para>
    <figure>
      <title>Header Text Example</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="../images/KRAD_Guide/headerTextExample.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>Now suppose we want to add other content to the header group. For example we might
            want to display links or buttons to the right of the header text. We do this just like
            adding content to any other group, using the items property:</para>
    <programlisting>
&lt;bean id=”MySection” parent=”Uif-VerticalBoxSection” p:title=”Section 1 Title”&gt;
    &lt;property name=”header.items”&gt;
&#160;&#160;&#160;     &lt;list&gt;
&#160;&#160;&#160;&#160;&#160;&#160;      &lt;bean parent=”Uif-ActionLink&quot; p:actionLabel=&quot;copy&quot; p:methodToCall=”copy”/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;      &lt;bean parent=”Uif-ActionLink&quot; p:actionLabel=&quot;edit&quot; p:methodToCall=”edit”/&gt;
&#160;&#160;&#160;     &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
        </programlisting>
    <para>Note we set the items directly on the header component instead of its nested group. We
            can do this because the header component provides a convenience getter and setter that
            uses the nested group items property.</para>
    <para>With the use of a style class, we can make our header group contents push to the far
            right of the header area (likewise we can flush it next to the header text, wrap to a
            new line, or use another of the many possible visual treatments). </para>
    <para>We can accomplish a lot with the use of header items. The following Screen Shot shows
            a couple more examples. One the standard view header for document views, which contains
            a group that displays information about the document. The second header is a page header
            that contains buttons for expanding or collapsing all the disclosure groups on the page
            (notice in this case there is no actual header text) Besides the different items, notice
            the difference in styling between the header areas based on their associated container
            level. </para>
    <figure>
      <title>Additional Header Examples</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="../images/KRAD_Guide/additionalHeaderExamples.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <section>
      <title>Recap</title>
      <itemizedlist>
        <listitem>
          <para>The header component is used to generate the various HTML header tags (h1,
                        h2, h3..h6). </para>
        </listitem>
        <listitem>
          <para>We generally don’t need to create a header component, since they are
                        associated with a container and initialized as a nested component. However,
                        they can be added in other places (in the groups items for instance) if
                        needed.</para>
        </listitem>
        <listitem>
          <para>Besides rendering the html header tag, the header component also contains
                        a nested group. This group can be used to display content (such as links or
                        buttons) in the header area of the group.</para>
        </listitem>
        <listitem>
          <para>The header element contains the properties headerText and headerLevel. The
                        header text specified the actual text that will display as the header. The
                        header level corresponds with the html header level that should be generated
                        (h1-h6).</para>
        </listitem>
        <listitem>
          <para>The UIF provides base bean definitions for each of the six header levels.
                        To create a header component we use one of these are our bean parent.</para>
        </listitem>
        <listitem>
          <para>Also provided are header beans that correspond with each container level
                        (view, page, section, sub-section). In addition to setting the header level,
                        these add a style class corresponding to the level so that we can add
                        different visual treatment (a view header will display differently than a
                        section header).</para>
        </listitem>
        <listitem>
          <para>We can add items to the header by setting the header.items property. With
                        CSS we can make our content display next to the header, to the far right,
                        wrap to a new line, or use another of the many possible visual
                        treatments).</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>
  <section>
    <title>Footers </title>
    <para>Unlike the header area for a group, the footer does nothing special. It is simply
            another group instance that is rendered after the group’s items. It is called a footer
            because of being rendered at the ‘foot’ of the group. The actual component type is just
            a standard group (at least in the default group definition, subclasses of group could
            have a subclass ‘footer’ group).</para>
    <para>Since footer is just a group, we can populate the property using any of the provided
            group beans. However, there are a few group beans that are target the footer area.
            Generally since the footer group is below the group’s main content, it is a great place
            to add buttons, links, or other content that applies the presented group. In the footer,
            we want to just display this content, note another header and footer (since the footer
            is a group, it also has a nested header and footer, and the nesting can continue). The
            UIF provides the following base bean for footer groups:</para>
    <programlisting>
&lt;bean id=&quot;Uif-FooterBase&quot; parent=&quot;Uif-HorizontalBoxGroup&quot; scope=&quot;prototype&quot;&gt;
    &lt;property name=&quot;styleClasses&quot; value=&quot;uif-footer&quot;/&gt;
&lt;/bean&gt;
        </programlisting>
    <para>Notice the footer base bean extends ‘Uif-HorizontalBoxGroup’. We will learn more about
            this bean later on, but essentially it is a group definition with no header and footer
            (both set to render false) and using a box layout with horizontal orientation. This
            means the items configured in the group will be rendered in a horizontal row. When
            setting the header property, we can create an inner bean that extends the footer
            base:</para>
    <programlisting>
&lt;bean id=”MyGroup” parent=”Uif-VerticalBoxSection” p:title=”My Group”&gt;
&#160;   &lt;property name=”footer”&gt;
&#160;&#160;&#160;     &lt;bean parent=”Uif-FooterBase”&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;property name=”items&gt;
                &lt;list&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;          &lt;bean parent=&quot;Uif-PrimaryActionButton&quot; p:methodToCall=&quot;calculate&quot; p:actionLabel=&quot;calculate&quot;/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;          &lt;bean parent=&quot;Uif-PrimaryActionButton&quot; p:methodToCall=&quot;clear&quot; p:actionLabel=&quot;clear&quot;/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;         &lt;/list&gt;
            &lt;/property&gt;
&#160;&#160;&#160;&#160;    &lt;/bean&gt;
&#160;   &lt;/property&gt;
&lt;/bean&gt;
        </programlisting>
    <para>In this example we have configured our group to have two buttons (‘calculate’ and
            ‘clear’) by setting the group’s footer property. To set the property we used the
            provided footer base bean and added two action components through the footer’s items
            property. Below shows the “MyGroup” bean. </para>
    <figure>
      <title>Group Footer Example</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="../images/KRAD_Guide/myGroupFooter.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>It is common for the View and Page footers to have buttons. For these containers the
            footer is already initialized and we can use the nested notation:</para>
    <programlisting>
&lt;bean id=”MyPage” parent=”Uif-Page” p:title=”My Page”&gt;
    &lt;property name=”footer.items&gt;
&#160;&#160;&#160;&#160;    &lt;list&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;     &lt;bean parent=&quot;Uif-PrimaryActionButton&quot; p:methodToCall=&quot;save&quot; p:actionLabel=&quot;save&quot;/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;     &lt;bean parent=&quot;Uif-PrimaryActionButton&quot; p:methodToCall=&quot;cancel&quot; p:actionLabel=&quot;cancel&quot;/&gt;
&#160;&#160;&#160;&#160;    &lt;/list&gt;
&#160;&#160;  &lt;/property&gt;
&lt;/bean&gt;
        </programlisting>
    <tip>
      <title>Common Button Groupings</title>
      <para>If you have common button groupings it is helpful&#160;to create a top level bean (with
                an id) for those so they can be reused. For example, the UIF provides the footer
                bean ‘Uif-FormFooter’ which includes actions or save, close, and cancel. If these
                are the buttons you need you can simply do the following:</para>
      <programlisting>
&lt;bean id=”MyPage” parent=”Uif-Page” p:title=”My Page”&gt;
    &lt;property name=”footer”&gt;
        &lt;bean parent=”Uif-FormFooter”/&gt;
&#160;   &lt;/property&gt;
&lt;/bean&gt;
            </programlisting>
      <para>The UIF also contains a common footer for document views that contains the various </para>
    </tip>
    <section>
      <title>Recap</title>
      <itemizedlist>
        <listitem>
          <para>The footer is simply another group that is rendered at the ‘foot’ of a
                        parent group</para>
        </listitem>
        <listitem>
          <para>Generally in the footer we want to just display contents (not another
                        header and footer)</para>
        </listitem>
        <listitem>
          <para>The footer is a great place to add buttons, links, or other content that
                        apply to the whole group (for example page buttons)</para>
        </listitem>
        <listitem>
          <para>The UIF provides a base bean named ‘Uif-FooterBase’ that uses a group
                        configured to not render a header and footer, and to use a horizontal box
                        layout</para>
        </listitem>
        <listitem>
          <para>Since it is common to add have footer contents for the view and page, a
                        footer is already initialized and we can simply set the <emphasis role="bold">footer.items</emphasis> property</para>
        </listitem>
        <listitem>
          <para>Common button groups can be configured in a footer definition with an id
                        so that they can be reused. The UIF provides one such grouping for the
                        standard save, close, and cancel actions named ‘Uif-FormFooter’</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>
  <section>
    <title>Introduction to Layout Managers </title>
    <para>We know a group bundles together multiple components as a container, but the group
            itself has no knowledge on how these components should be positioned on the page.
            Instead, KRAD provides an object called a Layout Manager. For those who have developed
            applications in Java with Swing, GWT, or used the .Net Framework the concept of Layout
            Managers will be familiar. Basically a Layout Manager encapsulates an algorithm on how
            to position a group of components by their relative positions. You might say it is the
            blueprint for a group’s items.</para>
    <para>To become a layout manager a class must implement the interface
            org.kuali.rice.krad.uif.layout.LayoutManager or extend the base class
            org.kuali.rice.krad.uif.layout.LayoutManagerBase. A layout manager is not a Component
            itself (does not implement the Component interface), however it does have some of the
            same properties. These include:</para>
    <para>id – A unique identifier for the layout manager instance. This is unique among all
            layout managers and components of a view instance. If the layout manager renders some
            HTML element that needs to be referenced client side, the id value can be used for the
            corresponding element id attribute. The id assignment for layout managers follows the
            same rules as components.</para>
    <para>template – Unlike layout managers in Swing and others that build the layouts in code,
            the KRAD layout managers operate through templates (although this is not required, a
            layout manger can build the layout in code as well). These generally follow the basic
            pattern of:</para>
    <orderedlist>
      <listitem>
        <para>Add starting markup (for example &lt;table&gt;)</para>
      </listitem>
      <listitem>
        <para>Iterate through each of the groups items wrapping with markup and then
                    invoking template tag (for example
                    &lt;tr&gt;&lt;td&gt;template&lt;/td&gt;..&lt;td&gt;template&lt;/td&gt;&lt;/tr&gt;</para>
      </listitem>
      <listitem>
        <para>Add finishing markup (for example &lt;/table&gt;)</para>
      </listitem>
    </orderedlist>
    <para>Since layout managers use templates, they can be customized the same way as a
            component (switching the template, extension and so on).</para>
    <para>style and styleClasses – Similar to component these properties hold style
            configuration or a list of style classes that should be applied to a layout manager
            wrapper (for example a div or table).</para>
    <para>context – Map of context objects that can be used for expressions configured on layout
            manager properties</para>
    <para>A layout manager by default supports any group instance. However, a layout manager can
            be built to only support specific group types. One example of this is the layout
            managers that work with Collection Groups. We will see these later on in the chapter. A
            layout manager can declare the type of group supported by implementing (or overriding)
            the following method:</para>
    <programlisting>
public Class&lt;? extends Container&gt; getSupportedContainer();
        </programlisting>
    <para>For example, a layout manager may be setup to work only with TreeGroups as
            follows:</para>
    <programlisting>
public Class&lt;? extends Container&gt; getSupportedContainer() {
    return TreeGroup.class;
}
        </programlisting>
    <para>In the rendering process, the layout managers will then invoke the rendering of the
            group’s items. What then invokes the layout manager? Well the group of course! Recall at
            the beginning of this chapter that basic group template:</para>
    <itemizedlist>
      <listitem>
        <para>Render header</para>
      </listitem>
      <listitem>
        <para>Render instructional text</para>
      </listitem>
      <listitem>
        <para>Render errors field</para>
      </listitem>
      <listitem>
        <para>Invoke layout manager passing group items</para>
      </listitem>
      <listitem>
        <para>Render footer</para>
      </listitem>
    </itemizedlist>
    <para>Since the group template controls the invocation of the layout manager, a group
            template may choose to not do so and instead layout the items itself. There are a couple
            examples of this we will learn about later on in this chapter.</para>
    <para>Moving on, let’s learn more about these layout managers!</para>
    <section>
      <title>Recap</title>
      <itemizedlist>
        <listitem>
          <para>A group has no knowledge regarding the positioning of the
                            components</para>
        </listitem>
        <listitem>
          <para>KRAD provides the concept of layout mangers. This concept can also be
                            seen in frameworks such as Java Swing, GWT, and .NET.</para>
        </listitem>
        <listitem>
          <para>A layout manager encapsulates an algorithm on how to position a set of
                            components by their relative position. It is a blueprint for rendering
                            the group’s items.</para>
        </listitem>
        <listitem>
          <para>To become a layout manager, a class must implement the interface
                            org.kuali.rice.krad.uif.layout.LayoutManager or extend the base class
                            org.kuali.rice.krad.uif.layout.LayoutManagerBase.</para>
        </listitem>
        <listitem>
          <para>Layout managers are not components, but share similar properties.
                            These include:</para>
          <itemizedlist>
            <listitem>
              <para>id – unique identifier for the layout manager</para>
            </listitem>
            <listitem>
              <para>template – jsp template file for the layout manager that
                                        performs the layout logic</para>
            </listitem>
            <listitem>
              <para>style and style classes – CSS treatment for the&#160; layout
                                        manger wrapper (such as a div or table)</para>
            </listitem>
            <listitem>
              <para>context – map of objects available for property
                                        expressions</para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para>A layout manager can support all general groups, or subsets by
                            implementing the method getSupportedContainer().</para>
        </listitem>
        <listitem>
          <para>Collection layout mangers are a type that only work with collection
                            groups</para>
        </listitem>
        <listitem>
          <para>The layout manger is invoked by the group template</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>
  <section>
    <title>Group Layout Managers </title>
    <para>Let’s being our exploration of layout managers by looking at those that work with
            basic groups. That is, we have a group containing items 1..n, that need to be positioned
            onto the page. Out of the box KRAD provides two such layout managers, the Grid Layout
            and the Box Layout.</para>
    <para>To help explain the algorithm employed by each layout manager, it is helpful to think
            of our ‘box’ areas again. We know our default group template renders starting content
            (header, instructions) and then invokes the layout manger and finally the footer.
            Therefore the layout manager positions the group items in the box between the group
            header and footer.</para>
    <figure>
      <title>Group Layout</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="../images/KRAD_Guide/groupLayoutDiagram.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <section>
      <title>Grid Layout</title>
      <para>The Grid Layout manager divides the layout area
                into a grid (n by m blocks) and then places the group components into the ‘slots’
                based on the order in which they are found in the group’s items list. The most
                important configuration property for this layout manager is the number of columns
                our grid should have. For example, if we use a grid layout with number of columns
                equal to two, two items will be positioned on each row. New rows will be created
                until all the items are positioned. Assuming we had five items in our group, they
                would be positioned as shown here: </para>
      <figure>
        <title>Grid Layout</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../images/KRAD_Guide/gridLayout.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>The group layout manager can then be
                configured to meet any grid configuration. We could take our same group of five
                items with a one column grid which would stack all the items on top of each other.
                Or we could use a 5 column grid would be put all the items on one horizontal row.
                The next figure depicts the general N columns by M rows layout. </para>
      <figure>
        <title>Grid Layout Examples</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../images/KRAD_Guide/KRAD_Grid_Layout.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>The
                default template for the grid layout uses HTML tables to achieve the grid
                positioning. A single table is created for the group items, with each item being
                rendered in a table cell (and table rows created as necessary). Because tables are
                used, this is sometime referred to as ‘table based’ layout, opposed to the Box
                Layout we will learn about next which is ‘div based’. There are advantages and
                disadvantages to the table layout. The advantages are easier alignment of content
                and the ability to do things such as row and column span. The disadvantages are the
                table is ‘non-fluid’ (does not adjust as the window resizes) and accessibility
                concerns. Many of the accessibility concerns are addressed in KRAD with the use of
                ARIA (see Chapter 11).</para>
      <para>The UIF provides a base bean named ‘Uif-GridLayoutBase’ that all grid layout
            beans should extend. This bean configures the grid template, adds a style class of
            ‘uif-gridLayout’, and sets defaults for some of the grid properties we will learn about
            in a bit. We can create a new grid layout manger instance using this as our bean parent:
            </para>
      <programlisting>
&lt;bean parent=”Uif-GridLayoutBase” p:numberOfColumns=”2”/&gt;
            </programlisting>
      <para>The UIF also provides beans preconfigured with the number of columns for typical
                cases. These include ‘Uif-TwoColumnGridLayout’ (2 columns),
                ‘Uif-FourColumnGridLayout’ (4 columns), ‘Uif-SixColumnGridLayout’ (6 columns).
                Therefore if we wanted a four column grid we can just do the following:</para>
      <programlisting>
&lt;bean parent=”Uif-FourColumnGridLayout”/&gt;
            </programlisting>
      <para>To associate a layout manager with a group, we use the group property named
                    <emphasis role="bold">layoutManager</emphasis>:</para>
      <programlisting>
&lt;bean id=”MyGroup” parent=”Uif-GroupBase” p:title=”Group with Grid Layout”&gt;
    &lt;property name=”layoutManager”&gt;
&#160;&#160;&#160;     &lt;bean parent=”Uif-FourColumnGridLayout”/&gt;
&#160;   &lt;/property&gt;
&lt;/bean&gt;
            </programlisting>
      <para>This is made even easier for us though, because there are beans that extend
                ‘Uif-GridBase’ and have a layout manger already configured for us. These beans
                are:</para>
      <para>Uif-GridGroup&#160; - General group configured with a grid layout. Also adds a style
                class of ‘uif-gridGroup’ to the group component.</para>
      <para>Uif-GridSection&#160; - Section level group configured with a grid layout. Also adds a
                style class of ‘uif-gridSection’ to the group component.</para>
      <para>Uif-GridSubSection&#160; - Sub-Section level group configured with a grid layout. Also
                adds a style class of ‘uif-gridSubSection’ to the group component.</para>
      <para>Using these beans we can rewrite our previous example as follows:</para>
      <programlisting>
&lt;bean id=”MyGroup” parent=”Uif-GridGroup” p:title=”Group with Grid Layout” p:layoutManger.numberOfColumns=”4”/&gt;
            </programlisting>
      <para>Since the layoutManager property is initialized by the base bean, we can use
                nested notation to set the numberOfColumns property. By default numberOfColumns is
                set to two.</para>
      <section>
        <title>Row, Col Span, Width</title>
        <para>Since the grid layout manager creates an HTML table, it supports the row and
                    col span options available from the table cell element. These properties are not
                    set on the layout manager, but instead set on the group component itself using
                    the properties colSpan and rowSpan. The column span can be set to specify an
                    item should take up more than one ‘slot’. That is, setting the span to two means
                    the item will take up the position of two slots. The row span is similar, but
                    the slots are counted vertically instead of horizontally. Thus a row span of two
                    means an items will take up the vertical space of two items. Let’s take the
                    following example:</para>
        <programlisting>
&lt;bean id=”MyGroup” parent=”Uif-GridGroup” p:title=”Group with Grid Layout” p:layoutManager.numberOfColumns=”3”&gt;
    &lt;property name=”items”&gt;
&#160;&#160;&#160;     &lt;list&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;bean parent=”Uif-InputField” p:propertyName=”field1” p:colSpan=”2”/&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;bean parent=”Uif-InputField” p:propertyName=”field2”/&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;bean parent=”Uif-InputField” p:propertyName=”field3” p:rowSpan=”2”/&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;bean parent=”Uif-InputField” p:propertyName=”field4” p:colSpan=”2”/&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;bean parent=”Uif-InputField” p:propertyName=”field5” p:colSpan=”2”/&gt;
&#160;&#160;&#160;     &lt;/list&gt;
&#160;   &lt;/property&gt;
&lt;/bean&gt;
                </programlisting>
        <para>This configuration would result in the following table structure:</para>
        <programlisting>
&lt;table&gt;
    &lt;tr&gt;&lt;td colSpan=”2”&gt;field1&lt;/td&gt;&lt;td&gt;field2&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td rowSpan=”2”&gt;field3&lt;/td&gt;&lt;td colSpan=”2”&gt;field4&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td colSpan=”2”&gt;field5&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
                </programlisting>
        <para>Note for items without the row or col span properties set, they receive a
                    default of one. The following figure shows the corresponding blocks for each
                    item.</para>
        <figure>
          <title>Row, Col Span Layout</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="../images/KRAD_Guide/rowColSpanLayout.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>Using row and col span, along with the ability to nest grid groups (nested
                    tables), we have a great amount of flexibility in the layouts we can achieve.
                    Below shows what a grid group with different row and col spans looks like in the
                    legacy look and feel. </para>
        <figure>
          <title>Row, Col Span Example</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="../images/KRAD_Guide/rowColSpanExample.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>As you might have noticed the previous figures depict even widths for each
                    cell. This is the default behavior for the grid layout (the area will be divided
                    by the number of columns to set a percentage width for each column). We can
                    adjust the widths of each column by setting the width property on the group
                    items. For example let’s take the previous three column grid layout and set
                    varying widths for the columns:</para>
        <programlisting>
&lt;bean id=”MyGroup” parent=”Uif-GridGroup” p:title=”Group with Grid Layout” p:layoutManager.numberOfColumns=”3”&gt;
    &lt;property name=”items”&gt;
&#160;&#160;&#160;     &lt;list&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;bean parent=”Uif-InputField” p:propertyName=”field1” p:width=”50%”/&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;bean parent=”Uif-InputField” p:propertyName=”field2” p:width=”25%”/&gt;/&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;bean parent=”Uif-InputField” p:propertyName=”field3” p:width=”25%”/&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;bean parent=”Uif-InputField” p:propertyName=”field4”/&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;bean parent=”Uif-InputField” p:propertyName=”field5”/&gt;
&#160;&#160;&#160;     &lt;/list&gt;
&#160;   &lt;/property&gt;
&lt;/bean&gt;
                </programlisting>
        <para>Here we are setting the first column to span 50% of the total table width, and
                    25% for the second and third columns. Since we are only using three columns, we
                    do not need to set the width on the remaining group items (field4 and field5).
                    Essentially we just need to set the widths for the first row. The width can be
                    given as a percentage of the table or a fixed width (for example pixels). For
                    controlling the full table width, we can apply a style setting (which will
                    render as the style attribute on the table element) or add a style class to the
                    layout manager. </para>
      </section>
      <section>
        <title>Label Separator</title>
        <para>When working with a grid layout it can be useful for alignment purposes to
                    render the field label in a separate column. Recall our discussion in Chapter 6
                    regarding fields and label positioning. Let’s assume we have a group containing
                    input fields with the label configured to render in the left position (the
                    default). For this group we are using a grid layout configured with one column
                    (therefore each field will stack vertically). Our labels and controls will then
                    look something like the following:</para>
        <para>Label One: ___________</para>
        <para>Second Label: ______</para>
        <para>Third Field Label: ______________</para>
        <para>Here the field labels were chosen to be different lengths, which is likely to
                    happen with real label text. Notice with the variable label length, were the
                    control begins varies from field to field and thus we do not have alignment
                    vertically. If we were to put the labels in their own column, the cell width
                    would expand to cover the longest label, and our controls would all start in the
                    next column. Thus we would have alignment:</para>
        <para>Label One:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ___________</para>
        <para>Second Label:&#160;&#160;&#160;&#160;&#160;&#160;&#160; ______</para>
        <para>Third Field Label:&#160; ______________</para>
        <para>The framework provides the option for doing this through a Component Modifier.
                    Component modifiers are classes that perform some modification to the component
                    they are configured on. Each component may have one or more such modifiers
                    configured. Thus they give us a way to encapsulate some functionality in a piece
                    of code that can be applied to multiple components, and in addition can be
                    conditionally applied. Chapter 10 covers this concept in more detail.</para>
        <para>One component modifier provided with KRAD is the LabelFieldSeparateModifier.
                    This modifier operates on a group component by iterating through the group items
                    and pulling out the label as a separate item. Thus it appears to the layout
                    manager that we configured the label as a separate group item, and the layout
                    manager will then in turn render the label in its own cell. The Uif-GridGroup
                    bean we have been working with has this modifier configured by default:</para>
        <programlisting>
&lt;bean id=&quot;Uif-GridGroup&quot; parent=&quot;Uif-GroupBase&quot; scope=&quot;prototype&quot;&gt;
    ...
&#160;&#160;&#160; &lt;property name=&quot;layoutManager&quot;&gt;
&#160;&#160;&#160;&#160;&#160;   &lt;bean parent=&quot;Uif-GridLayoutBase&quot;/&gt;
    &lt;/property&gt;
&#160;&#160;&#160; &lt;property name=&quot;componentModifiers&quot;&gt;
        &lt;list&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;     &lt;bean parent=&quot;Uif-LabelFieldSeparator-Modifier&quot; p:runPhase=&quot;FINALIZE&quot;/&gt;
&#160;&#160;&#160;&#160;&#160;   &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
                </programlisting>
        <para>Notice this bean sets the componentModifiers list property adding the label
                    field separator, whose UIF bean is named ‘Uif-LabelFieldSeparator-Modifier’. The
                    runPhase is one property modifiers have that determines when in the view
                    lifecycle the modifier will be executed. The available phases are INITIALIZE,
                    APPLY_MODEL, and FINALIZE.</para>
        <para>If we inherit from a bean with one or more modifiers configured, we can choose
                    note to use the modifiers by setting the property to null (using the Spring null
                    tag):</para>
        <programlisting>
&lt;property name=&quot;componentModifiers&quot;&gt;
    &lt;null/&gt;
&lt;/property&gt;
                </programlisting>
      </section>
      <section>
        <title>Other Grid Layout Options</title>
        <para>The Grid Layout Manager also supports the following properties:</para>
        <para>suppressLineWrapping – By default once the configured number of columns is
                    reached the layout manager will wrap to a new row. If this property is set to
                    true, the layout manager will ignore the number of columns property and instead
                    continue to render all group items in one row. This is useful if the number of
                    group items is unknown and you wish to have them in a single line. The number of
                    columns property does not need to be specified when use line wrap
                    suppressing.</para>
        <para>applyAlternatingRowStyles – Boolean that indicates whether alternating row
                    styles of ‘odd’ and ‘even’ should be applied to each tr element. This allows
                    alternating row styles that is common on data grids.</para>
        <para>applyDefaultCellWidths – Boolean that indicates whether default widths should
                    be calculated for each cell. If set to true the total width will be divided by
                    number of columns to determine the default width as a percentage for each cell.
                    If the width is configured for an item it will not be overridden.</para>
        <para>renderAlternatingHeaderColumns – Boolean that indicates whether cells should
                    alternate between table header and table cells (th and td). This is generally
                    set to true when using the label separator so the label cells appear with
                    different styling. The appropriate scopes are added by the framework (th with
                    scope equal to column for the header row, and th with scope equal to row for
                    table headers within a data row).</para>
      </section>
    </section>
    <section>
      <title>Box Layout</title>
      <para>Next let’s take a look at the other provided group layout called the Box Layout.
                Unlike the grid layout which creates a grid of blocks, the box layout creates just a
                single row of blocks in either the horizontal or vertical direction. It will keep
                creating blocks in a direction until all items of the group have been rendered. The
                first item configured in the group will receive the first position, on to the last
                group item which will receive the last position.</para>
      <para>Within the layout area we can think of the box layout as dividing the area
                horizontally (in the case of horizontal orientation):</para>
      <figure>
        <title>Horizontal Box Layout</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../images/KRAD_Guide/horizontalBoxLayout.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>The box layout manager contains a property named orientation that determines the
                direction of the rendered items. The valid values for this property are HORIZONTAL
                and VERTICAL. The following figure shows an example of each orientation. </para>
      <figure>
        <title>Box Layout Manager</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../images/KRAD_Guide/KRAD_Box_Layout_Manager.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>To accomplish these layouts the box manager uses CSS display styles. Recall our
                component types and their HTML output:</para>
      <para>Groups – div element </para>
      <para>Field – span element </para>
      <para>Content Element – content element</para>
      <para>Each of these inherits the style and styleClasses properties from ComponentBase.
                Therefore the box layout manager manipulates these properties in code to achieve the
                desired layout through CSS. For the horizontal orientation, the manager applies a
                style class of boxLayoutHorizontalItem to each item. This adds a float left to each
                item style making the items align in a horizontal row. For the vertical orientation,
                the manager applies a style class of boxLayoutVerticalItem. This style class simply
                adds a display style of block, making each item wrap to a new row and the items
                stacking to form a vertical row.</para>
      <para>Like grid layout, the box layout had advantages and disadvantages. One advantage
                is the ability for the layout to adjust as the window resizes (items will
                automatically wrap down to new lines as needed instead of forcing a scrollbar). With
                the increasing need to support mobile devices, this can be a big win. In addition
                div based layouts are better for accessibility support. However, aligning content
                (such as the label/control alignment in the grid layout) is much harder to
                accomplish. Furthermore cross-browser rendering issues occur more often than when
                using basic tables.</para>
      <para>For XML configuration the box layout manager has a base bean with name
                ‘Uif-BoxLayoutBase’. This sets the box layout template and adds the style class of
                ‘uif-boxLayout’. Then extending this we have beans for each orientation. First is
                ‘Uif-HorizontalBoxLayout’ which sets the orientation as HORIZONTAL and adds a style
                class of ‘uif-horizontalBoxLayout’. Likewise there is a bean with name
                ‘Uif-VerticalBoxLayout’ that sets the orientation to VERTICAL and adds a style class
                of ‘uif-verticalBoxLayout’. We can apply one of these to a group as we did for the
                grid layout, using the group’s layoutManager property:</para>
      <programlisting>
&lt;bean id=”MyGroup” parent=”Uif-GroupBase” p:title=”Group with Box Layout”&gt;
    &lt;property name=”layoutManager”&gt;
&#160;&#160;&#160;     &lt;bean parent=”Uif-VerticalBoxLayout”/&gt;
&#160;   &lt;/property&gt;
&lt;/bean&gt;
            </programlisting>
      <para>However, the UIF again provides us with group definitions with box layouts already
                configured. These are as follows:</para>
      <para>Uif-VerticalBoxGroup – General group configured with a vertical box layout. Adds a
                style class of ‘uif-verticalBoxGroup’ to the group.</para>
      <para>Uif-VerticalBoxSection – Section level group configured with a vertical box
        layout. Adds a style class of ‘Uif-VerticalBoxSection’ to the group.</para>
      <para>Uif-VerticalBoxSubSection – Sub-Section level group configured with a vertical box
        layout. Adds a style class of ‘Uif-VerticalBoxSubSection’ to the group.</para>
      <para>Uif-HorizontalBoxGroup - General group configured with a horizontal box layout.
                Adds a style class of ‘uif-horizontalBoxGroup’ to the group.</para>
      <para>Uif-HorizontalBoxSection - Section level group configured with a horizontal box
        layout. Adds a style class of ‘Uif-VerticalBoxSection’ to the group.</para>
      <para>Uif-HorizontalBoxSubSection - Sub-Section level group configured with a horizontal
        box layout. Adds a style class of ‘Uif-VerticalBoxSubSection’ to the group.</para>
      <para>Using these beans we can rewrite our previous example as:</para>
      <programlisting>
&lt;bean id=”MyGroup” parent=”Uif-VerticalBoxGroup” p:title=”Group with Box Layout”/&gt;
            </programlisting>
      <para>When looking at the grid layout the examples shown were all fields. Recall though
                that we can also nest groups within groups, and just like fields they need a layout
                manager to position them. The box layout manager is generally the layout of choice
                in this case. In particular, because groups such as section and sub-section
                typically span the full width available, the vertical box layout is used to ‘stack’
                the groups.</para>
      <para>As an example let’s build a page group with sections:</para>
      <programlisting>
&lt;bean id=”BookInfoPage” parent=”Uif-Page” p:title=”Book Info”&gt;
    &lt;property name=”items”&gt;
        &lt;list&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;bean parent=”BookInfoSection”/&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;bean parent=”BookDetailsSection”/&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;bean parent=”BookRefSection”/&gt;
&#160;&#160;&#160;     &lt;/list&gt;
&#160;   &lt;/property&gt;
&lt;/bean&gt;
            </programlisting>
      <para>Here we are creating a page with three items. Each item is a reference to another
                bean that is a section group. How will these sections be positioned? It turns out
                that because it is so common for the sections to be vertical stacked that the
                default layout defined in Uif-Page is Uif-VerticalBoxLayout! Therefore each section
                will divide the page vertically.</para>
      <tip>
        <title>Sections and Sub-Sections</title>
        <para>There is no requirement that sections and sub-sections divide the page
                    vertically. In fact, in our previous example we could override the layout manage
                    to be UIF-HorizontalBoxLayout. This would result in three section columns. We
                    could furthermore for each section using a horizontal layout, which would result
                    in sub-section columns. Of course we can also switch between horizontal and
                    vertical layout between group levels, or use another layout such as grid.</para>
      </tip>
      <section>
        <title>Other Box Layout Options</title>
        <para>The Box Layout Manager also supports the following properties:</para>
        <para>padding – The box layout essentially is just using CSS to perform layouts, and
                    using the style and style classes properties you can modify the CSS applied.
                    However the box layout provides a couple of properties for convenience. The
                    first of these is the <emphasis role="bold">padding</emphasis> property. When
                    positioning items side by side, or one below another, a typical visual concern
                    is the padding (or space) between each item. Too little space and the item
                    content might run together as one, and too much will waste space and not look
                    visually appealing. Therefore the padding can be set to specify the exact amount
                    of space between each item. Note the manager will take the value given and use
                    to set the corresponding CSS property (either padding-right for horizontal
                    layout or padding-bottom for vertical layout). The value can be a fixed amount
                    (px, pt, cm, etc) or as a percentage of the parent container. Note the default
                    styles applied have a default setting for padding that should be acceptable in
                    most cases.</para>
        <para>itemStyle and itemStyleClasses – These have similar purpose the style and
                    styleClasses properties we have already learned about. The difference in this
                    case is the given style or class will be applied not to the layout manager but
                    each group item that layout manager positions. Note we could accomplish the same
                    thing by setting the style or styleClasses property on the group item itself,
                    however it is more convenient to set in this one place instead of each item.
                    Also, if we are inheriting a group and changing the layout, setting the
                    properties for each item would require us to redefine each item.</para>
        <para>As an example here is a group bean with the style classes set on each
                    item:</para>
        <programlisting>
&lt;bean parent=”Uif-HorizontalBoxSection”&gt;
    &lt;property name=”items”&gt;
&#160;&#160;&#160;     &lt;list&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;bean parent=”Uif-DataField” ...&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;         &lt;property name=”styleClasses”&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;           &lt;list merge=”true”&gt;
&#160; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;          &lt;value&gt;fssLayoutItem&lt;/value&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;           &lt;/list&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;         &lt;/property&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;/bean&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;bean parent=”Uif-DataField” ...&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;         &lt;property name=”styleClasses”&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;           &lt;list merge=”true”&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;           &lt;value&gt;fssLayoutItem&lt;/value&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;           &lt;/list&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;         &lt;/property&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;/bean&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;bean parent=”Uif-DataField” ...&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;         &lt;property name=”styleClasses”&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;           &lt;list merge=”true”&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;           &lt;value&gt;fssLayoutItem&lt;/value&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;           &lt;/list&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;         &lt;/property&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;/bean&gt;
&#160;&#160;&#160;&#160;    &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
                </programlisting>
        <para>Since we want to keep the inherited style classes for Uif-DataField, we must
                    use the Spring list tags with merge=”true”. Now we can accomplish the same thing
                    using the box layout manager’s itemStyleClasses property:</para>
        <programlisting>
&lt;bean parent=”Uif-HorizontalBoxSection”&gt;
    &lt;property name=”layoutManager.itemStyleClasses” value=”fssLayoutItem”/&gt;
&#160;   &lt;property name=”items”&gt;
&#160;&#160;&#160;     &lt;list&gt;
&#160;&#160;&#160;&#160;        &lt;bean parent=”Uif-DataField” ...&gt;
&#160;&#160;&#160;&#160;        &lt;bean parent=”Uif-DataField” ...&gt;
&#160;&#160;&#160;&#160;        &lt;bean parent=”Uif-DataField” ...&gt;
&#160;       &lt;/list&gt;
&#160;   &lt;/property&gt;
&lt;/bean&gt;
                </programlisting>
        <para>Since the layout manager property is initialized by the parent bean, we can
                    use the nested notation. Now that is much better! </para>
        <tip>
          <title>CSS Layouts</title>
          <para>You can achieve many layouts using the box layout manager and&#160;using the
                        styleClasses properties. It is your gateway for doing CSS based layouts. In
                        particular KRAD comes bundled with the Fluid CSS layout engine which allows
                        you to create various layouts by adding the appropriate Fluid classes. You
                        can also explore such things as CSS3 grid layouts or bring in other CSS
                        layout engines. For quick layout adjustments, just use the style property to
                        specify a CSS float value: p:style=”float: right;”.</para>
        </tip>
      </section>
    </section>
    <section>
      <title>Recap</title>
      <itemizedlist>
        <listitem>
          <para>For basic groups KRAD provides two layout managers, the Grid layout and
                        the Box layout</para>
        </listitem>
        <listitem>
          <para>The grid layout manager positions the group items in table cells. </para>
        </listitem>
        <listitem>
          <para>When using the grid layout manager we must specify the number of columns
                        for each row. The manager will then fill in the slots with the group items
                        wrapping to new rows once the column count is reached</para>
        </listitem>
        <listitem>
          <para>The UIF provides the base bean ‘Uif-GridLayoutBase’ for the grid layout
                        manager, in addition to beans with a preconfigured number of columns (such
                        as ‘Uif-TwoColumnGridLayout’)</para>
        </listitem>
        <listitem>
          <para>A layout manager is associated with a group using the <emphasis role="bold">layoutManager</emphasis> property</para>
        </listitem>
        <listitem>
          <para>Instead of setting the layout manager property on a group, we can use the
                        base beans that are already configured to use a grid layout. These
                        correspond to the various group levels:</para>
          <itemizedlist>
            <listitem>
              <para>Uif-GridGroup</para>
            </listitem>
            <listitem>
              <para>Uif-GridSection</para>
            </listitem>
            <listitem>
              <para>Uif-GridSubSection</para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para>The grid layout allows us to change the number of ‘slots’ (cells) a item
                        take up by setting the row and col span. In addition we can specify a custom
                        width for each item (by default the manager will divide by the number of
                        columns to set the width equally)</para>
        </listitem>
        <listitem>
          <para>A typical requirement is for the labels and controls to align between
                        fields. Since labels can vary in length, this is difficult to achieve
                        without using tables. KRAD provides a label separator modifier that can be
                        used with a grip layout to place the field label in a separate cell. This is
                        enabled by default (through the base beans)</para>
        </listitem>
        <listitem>
          <para>The grid layout manager also supports options for applying alternate row
                        styles (‘odd’ and ‘even’ style classes) and rendering alternating header
                        columns (th elements with scope ‘row’)</para>
        </listitem>
        <listitem>
          <para>The box layout manager places the group items into a row using CSS
                        styling</para>
        </listitem>
        <listitem>
          <para>The direction of the layout row can be set using the <emphasis role="bold">orientation</emphasis> property. The options are HORIZONTAL and
                        VERTICAL</para>
        </listitem>
        <listitem>
          <para>The UIF provides the base bean named ‘Uif-BoxLayoutBase’ for the box
                        layout manager. In addition base beans are provided for the two
                        orientations: ‘Uif-HorizontalBoxLayout’ and ‘Uif-VerticalBoxLayout’</para>
        </listitem>
        <listitem>
          <para>Similar to the case of grid layout, beans are provided for groups
                        configured with a box layout manager. These include both orientations at
                        each of the group levels:</para>
          <itemizedlist>
            <listitem>
              <para>Uif-VerticalBoxGroup</para>
            </listitem>
            <listitem>
              <para>Uif-VerticalBoxSection</para>
            </listitem>
            <listitem>
              <para>Uif-VerticalBoxSubSection</para>
            </listitem>
            <listitem>
              <para>Uif-HorizontalBoxGroup</para>
            </listitem>
            <listitem>
              <para>Uif-HorizontalBoxSection</para>
            </listitem>
            <listitem>
              <para>Uif-HorizontalBoxSubSection</para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para>The box layout is generally used for positioning groups (such as sections)
                        and rows of buttons (action fields)</para>
        </listitem>
        <listitem>
          <para>The <emphasis role="bold">padding</emphasis> property can be specified to
                        custom the space between the group items (either the space to the right for
                        horizontal orientation or space below for vertical orientation)</para>
        </listitem>
        <listitem>
          <para>CSS styling can be applied to the group items to achieve other layouts.
                        For example using the Fluid styles to make various grids or left/right
                        panels. Instead of adding the style class(s) to each group item, we can use
                        the layout manager properties <emphasis role="bold">itemStyle</emphasis> and
                            <emphasis role="bold">itemStyleClasses</emphasis>. The layout manager
                        will then apply them to each item for us</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>
  <section>
    <title>Field Groups </title>
    <para>There is one type of Field that we didn’t cover in Chapter 6 which is the Field Group.
            This is merely a field that contains a group! Why do we need that? We need this because
            fields have something groups don’t, a label! Let’s consider the following group using a
            grid layout:</para>
    <programlisting>
&lt;bean id=”MyGroup” parent=”Uif-GridGroup” p:title=”Group with Grid Layout” p:layoutManager.numberOfColumns=”4”&gt;
    &lt;property name=”items”&gt;
&#160;&#160;&#160;     &lt;list&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;bean parent=”Uif-InputField” p:propertyName=”field1” p:label=”Field 1”/&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;bean parent=”Uif-InputField” p:propertyName=”field2” p:label=”Field 2”/&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;bean parent=”Uif-InputField” p:propertyName=”field3” p:label=”Field 3”&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;         &lt;property name=”control”&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;           &lt;bean parent=”Uif-CheckboxControl”/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;         &lt;/property&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;/bean&gt;
&#160; &#160;&#160;&#160;&#160;      &lt;bean parent=”Uif-InputField” p:propertyName=”field4” p:label=”Field 4”&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;         &lt;property name=”control”&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;           &lt;bean parent=”Uif-CheckboxControl”/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;         &lt;/property&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;/bean&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;bean parent=”Uif-InputField” p:propertyName=”field5” p:label=”Field 5”/&gt;
&#160;&#160;&#160;     &lt;/list&gt;
&#160;   &lt;/property&gt;
&lt;/bean&gt;
        </programlisting>
    <para>This result of this is show below. </para>
    <figure>
      <title>Field Group Checkbox</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="../images/KRAD_Guide/fieldGroupCheckboxes.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>Notice here the labels appear in separate cells due to the label field separator being
            enabled. What if we wanted the two checkboxes (field3 and field4) to appear in one cell
            together instead of two separate cells? We could add a nested group in our items but
            then there would not be a label for the corresponding label cell. This is where field
            groups help us. </para>
    <para>For creating field group components the base bean with name ‘Uif-FieldGroupBase’ is
            provided. This adds a style class of ‘uif-fieldGroup’ to our field. Extending this are
            the following two beans:</para>
    <para>Uif-VerticalFieldGroup – Initialized the nested group component to
            Uif-VerticalBoxGroup. This means the nested group will use a vertical box layout. In
            addition this bean adds the style class of ‘uif-verticalFieldGroup’ to the field.</para>
    <para>Uif-HorizontalFieldGroup – Initialized the nested group component to
            Uif-HorizontalBoxGroup. This means the nested group will use a horizontal box layout. In
            addition this bean adds the style class of ‘uif-horizontalFieldGroup’ to the
            field.</para>
    <para>The most common use case for a field group is to combine a set of fields into one, and
            then use the label property of the field to label the group. In these cases the header
            and footer on the nested group are not used and thus turned off by default (in the base
            beans).</para>
    <para>Now let’s create a field group for our checkboxes. We’ll use the vertical field group
            so they appear on top of each other within the cell:</para>
    <programlisting>
&lt;bean id=”MyGroup” parent=”Uif-GridGroup” p:title=”Group with Field Groups” p:layoutManager.numberOfColumns=”4”&gt;
&#160;   &lt;property name=”items”&gt;
&#160;&#160;&#160;     &lt;list&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;bean parent=”Uif-InputField” p:propertyName=”field1” p:label=”Field 1”/&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;bean parent=”Uif-InputField” p:propertyName=”field2” p:label=”Field 2”/&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;bean parent=”Uif-VerticalFieldGroup” p:label=”Checkboxes”&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;         &lt;property name=”items”&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;           &lt;list&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;             &lt;bean parent=”Uif-InputField” p:propertyName=”field3” p:label=”Field 3”&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;               &lt;property name=”control”&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;                  &lt;bean parent=”Uif-CheckboxControl”/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;                &lt;/property&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;              &lt;/bean&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;              &lt;bean parent=”Uif-InputField” p:propertyName=”field4” p:label=”Field 4”&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;                &lt;property name=”control”&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;                 &lt;bean parent=”Uif-CheckboxControl”/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;                &lt;/property&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;              &lt;/bean&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;           &lt;/list&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;         &lt;/property&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;/bean&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;bean parent=”Uif-InputField” p:propertyName=”field5” p:label=”Field 5”/&gt;
&#160;&#160;&#160;     &lt;/list&gt;
&#160;   &lt;/property&gt;
&lt;/bean&gt;
        </programlisting>
    <para>Notice here we are setting the label property on our field group, this will be the
            label that displays the in the label cell. Also notice to set the items on the nested
            group we just specified “items” instead of “group.items”. This is because the field
            group class provides a convenience getter and setter that worked with the nested group.
            The result of the above is shown below.</para>
    <figure>
      <title>Nested Field Groups</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="../images/KRAD_Guide/nestedFieldGroup.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <section>
      <title>Recap</title>
      <itemizedlist>
        <listitem>
          <para>A Field Group is simply a field that contains a nested group</para>
        </listitem>
        <listitem>
          <para>Field groups are useful for grouping fields that such act as a set (for
                        example a group of checkboxes) and need to be labeled as a set</para>
        </listitem>
        <listitem>
          <para>The UIF provides the base bean named ‘Uif-FieldGroupBase’ for field group
                        components. Extending from these are beans that use a box layout for the
                        nested group: ‘Uif-VerticalFieldGroup’ and ‘Uif-HorizontalFieldGroup’</para>
        </listitem>
        <listitem>
          <para>Generally when using a field group the header and footer for the nested
                        group is not needed, therefore these are turned off (render property is
                        false) in the base beans</para>
        </listitem>
        <listitem>
          <para>Field groups are also helpful for achieving complex layouts</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>
  <section>
    <title>Link Group </title>
    <para>One special type of group provided in KRAD is the <emphasis role="bold">LinkGroup</emphasis> component. A link group may be used to create such things as a
            link tool bar or a group of links (such as a menu group). As implied by its name, only
            link components may be placed into a link group.</para>
    <para>To create a link group, a bean with parant of Uif-LinkGroup is used.</para>
    <programlisting>
&lt;bean parent=”Uif-LinkGroup” p:headerText=”Link Group”&gt;
        </programlisting>
    <para>To position the contained links, the link group does not use a layout manager but
            instead a specified delimiter. This delimiter is rendered between each link pair. To
            configure the delimiter string, the property <emphasis role="bold">linkSeparator</emphasis> is given.</para>
    <programlisting>
&lt;bean parent=”Uif-LinkGroup” p:headerText=”Link Group” p:linkSeparator=”|”&gt;
        </programlisting>
    <para>In addition we can specify a string that will render before the group of links, and a
            string that will render after the group. The begin string is given using the <emphasis role="bold">groupBeginDelimiter</emphasis>. Likewise the end string is given using
            the <emphasis role="bold">groupEndDelimiter</emphasis>.</para>
    <programlisting>
&lt;bean parent=”Uif-LinkGroup” p:headerText=”Link Group” p:linkSeparator=”|” p:groupBeginDelimiter=”[“ p:groupEndDeimiter=”]”&gt;
        </programlisting>
    <para>Now to complete the link group we add links through the group items property:</para>
    <programlisting>
&lt;bean parent=”Uif-LinkGroup” p:headerText=”Link Group” p:linkSeparator=”|” p:groupBeginDelimiter=”[“ p:groupEndDeimiter=”]”&gt;
&#160;   &lt;property name=”items”&gt;
&#160;&#160;&#160;     &lt;list&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;bean parent=”Uif-Link” p:href=”http:myapp/home” p:linkLabel=”Home”/&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;bean parent=”Uif-Link” p:href=”http:myapp/register” p:linkLabel=”Register”/&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;bean parent=”Uif-Link” p:href=”http:myapp/about” p:linkLabel=”About”/&gt;
&#160;&#160;&#160;     &lt;/list&gt;
&#160;   &lt;/property&gt;
&lt;/bean&gt;
        </programlisting>
  </section>
  <section>
    <title>Navigation Group </title>
    <para>Coming Soon!</para>
<!-- TODO: Add content here.
          -->  </section>
  <section>
    <title>Collection Groups </title>
    <para>Time to tackle the dragon! If you have followed
            everything up to this point, you are ready to go, if no, well this would be a good time
            to review! The next component type we are going to look at is the Collection Group. This
            component is inherit with complexity due to the many responsibilities it has.&#160; First as
            its name implies, it as a type of group. However, similar to data field it is also a
            DataBinding component (is backed by a model property). But in both cases the collection
            group has significant differences. </para>
    <para>Let’s start by looking at the data
            binding aspect of collection group. We know from our work with data field this means our
            component is going to point to a property somewhere in the model. The purpose of doing
            so is to provide IO (Input/Output) with the application model. Consider our model we
            used in Chapter 6:</para>
    <programlisting>
public class TestForm {
    private String field1;
&#160;   private Test1Object test1Object;
}

public class Test1Object {
&#160;   private String t1Field;
&#160;   private Test2Object test2Object;
&#160;   private List&lt;Test2Object&gt; test2List;
}

public class Test2Object {
&#160;   private String t2Field;
&#160;   private String t2Field2;
&#160;   private String t2Field3;
&#160;   private Map&lt;String, String&gt; t2Map;
}
        </programlisting>
    <para>All of the data (or input) field examples we showed pointed to
            properties that had primitive types (String, Integer, Boolean, List&lt;String&gt;).
            Although the property path might have been nested, it eventually pointed to a primitive
            property. So in Test1Object, how would we give the ability to edit or display properties
            from each item of the test2List property? Notice the type for this property is a List of
            data objects. This is the type of property our collection group will bind to. We use the
            same approach as data field for configuring the collection property. That is by using
            the propertyName property and the nested bindingInfo property (when
            needed).</para>
    <para>We will learn about the collection group beans later on, but for
            now let’s create a bean that uses the collection group base bean with name
            ‘Uif-CollectionGroupBase’:</para>
    <programlisting>
&lt;bean parent=”Uif-CollectionGroupBase” p:title=”My First Collection” p:propertyName=”test1Object.test2List”/&gt;
        </programlisting>
    <para>Collection group is
            a type of group (which is a container) therefore we can specify the title property which
            will be used for the group header text. Then we are pointing our collection to the
            test1Object.testList List property. Now let’s add some input fields to our collection
            group:</para>
    <programlisting>
&lt;bean parent=”Uif-CollectionGroupBase” p:title=”My First Collection” p:propertyName=”test1Object.test2List”&gt;
&#160;   &lt;property name=”items”&gt;
&#160;&#160;&#160;     &lt;list&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;bean parent=”Uif-InputField” p:propertyName=”t2Field”/&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;bean parent=”Uif-InputField” p:propertyName=”t2Field2”/&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;bean parent=”Uif-InputField” p:propertyName=”t2Field3”/&gt;
&#160;&#160;&#160;     &lt;/list&gt;
&#160;   &lt;/property&gt;
&lt;/bean&gt;
        </programlisting>
    <para>Notice the property names for our input fields point to
            properties on Test2Object. Unlike general group fields that are assumed to be relative
            to the root model object (form) or a binding object path, the property names given for a
            collection field are assumed to be on the collection item class. What do we mean by
            collection item class? This refers to the type for each of our list items, which in our
            example is Test2Object. All collection items must contain properties (with valid getter
            and setters) for the fields configured. </para>
    <note>
      <title>Collection Field Binding</title>
      <para>Recall our discussion on data binding in Chapter 6&#160;and the binding info
                ‘bindByNamePrefix’. This property is set automatically for each field in the
                collection group to be the path to the collection item (collection binding path plus
                the item index).</para>
    </note>
    <para>So this collection group looks very
            similar to the basic groups we have looked at, so what is the difference? A good way to
            think of the difference is our basic group renders one set of fields, while our
            collection groups renders multiple sets of fields. That is, for each item that exists in
            the list property, the set of fields configured will be generated. Let’s assume our
            test2List property has three items, then the corresponding fields generated will
            be:</para>
    <para>Collection Item 1 (test2List[0]):</para>
    <para>Fields:
            test2List[0].t2Field, &#160;test2List[0].t2Field2,
            &#160;test2List[0].t2Field3</para>
    <para>Collection Item 2 (test2List[1]):</para>
    <para>Fields:
            test2List[1].t2Field, &#160;test2List[1].t2Field2,
            &#160;test2List[1].t2Field3</para>
    <para>Collection Item 3 (test2List[2]):</para>
    <para>Fields:
            test2List[2].t2Field, &#160;test2List[2].t2Field2, &#160;test2List[2].t2Field3</para>
    <para>And so
            on for further collection items. This requires the framework to dynamically create new
            fields in code to expand to the number of collection items present in the model. This
            process is described in the upcoming section ‘Component Prototypes’.</para>
    <section>
      <title>Collection Object Class</title>
      <para>The collection item class is critical for much of the functionality collection
                groups provide. Therefore when creating a collection group we must specify the item
                class type using the <emphasis role="bold">collectionObjectClass</emphasis>
                property:</para>
      <programlisting>
&lt;bean parent=”Uif-CollectionGroupBase” p:title=”My First Collection”
    p:propertyName=”test1Object.test2List”
    p:collectionObjectClass=”edu.myedu.sample.Test2Object”/&gt;
            </programlisting>
      <para>The class given must be a concrete (non-abstract) class that follows the JavaBean
                specification.</para>
    </section>
    <section>
      <title>Add Line</title>
      <para>Collection groups provide data IO at two different
                levels: One for the individual collection item fields, and two at the collection
                level itself. Data IO at the collection level is done in terms of adding and
                removing items (data objects). Therefore a general facility provided by the
                collection group is the add line configuration.</para>
      <para>First to specify we want to have an add line for our collection group, we set the <emphasis role="bold">renderAddLine</emphasis> property to true. This is true by default
                in our collection group base, however in code there is also the condition that the
                collection group not be read-only (when in read only state the add line will not be
                rendered). This behavior can be modified by a collection helper class called the
                Collection Group Builder which we will learn about later in this section.</para>
      <para>Currently the UIF implements the add line functionality using a separate property. This means
                the object that holds the add line data is not part of the collection property
                itself. Once the line is added the add object is interested in collection. Thus the
                collection group needs to have a property to store the add line object. This can be
                done in one of two ways. First, if no configuration is provided and the UifFormBase
                is being used for a base form class (the recommendation), a generic property of Map
                type will be used. The full collection path is used to key the map, with the actual
                add line object as the Map value. The framework will then take care of setting the
                binding paths appropriately. You can also choose to specify the path for the add
                line through the collection group. This works similar to specifying other property
                paths. We can do this by setting the <emphasis role="bold">addLinePropertyName</emphasis> and if needed the <emphasis role="bold">addLineBindingInfo</emphasis> properties. As an example let’s assume we want to
                use our test2Object property to hold the add line:</para>
      <programlisting>
public class Test1Object {
&#160;   private String t1Field;
&#160;   private Test2Object test2Object;
&#160;   private List&lt;Test2Object&gt; test2List;
}
            </programlisting>
      <para>We can configure this as follows:</para>
      <programlisting>
&lt;bean parent=”Uif-CollectionGroupBase” p:title=”My First Collection”
    p:propertyName=”test1Object.test2List”
    p:collectionObjectClass=”edu.myedu.sample.Test2Object”&gt;
&#160;   &lt;property name=”addLinePropertyName” value=”test1Object.test2Object”/&gt;
&lt;/bean&gt;
            </programlisting>
      <para>Note unlike the field property names, the add line is not assume to be on the
                collection item. Therefore it follows the standard rules as other non-collection
                fields. In this casing (assuming the view has no default object binding path), we
                set the full path from the form to our add line property, which is
                ‘test1Object.test2Object”.</para>
      <para>The configured collection group items will be used to generate the add line as
                well. Therefore they must all exist for the add properties type (generally this is
                the same type as the collection items). If it is desired to have a different set of
                fields for the add line (for example, some fields might get defaulted or are not
                necessary to show until the line has been added), an alternate set of items can be
                specify using the <emphasis role="bold">addLineItems</emphasis> property. This
                property holds a list of components similar to the generic group’s items
                property.</para>
      <para>Lastly the collection group provides a nested Label component for the add line
                named <emphasis role="bold">addLineLabel</emphasis>. This is not used by the
                collection group itself but is made available to the collection layout managers (for
                example the table layout manager uses this to label the add line row). </para>
    </section>
    <section>
      <title>Collection Add Blank Line</title>
      <para>Collections can be configured to allow the user to add blank editable lines to the collection.
              This way the user is forced to add the line to the collection before entering data. In this case
              the blank line will already be part of the collection data.</para>
      <para>To enable this feature the <emphasis role="bold">renderAddBlankLineButton</emphasis> property
              on CollectionGroup must be set to true. This can be set on stacked as well as table collection layouts.
              This will cause the default add line actions not to be rendered inside the items and instead an Add Line
              action button will be rendered once for the collection.</para>
      <para>The placement of this button can be set using the <emphasis role="bold">addLinePlacement</emphasis>
              property. Valid values are 'TOP' and 'BOTTOM'. The default will always be 'TOP'. This will also
              determine where the blank will be added to the collection, 'TOP' will insert the line first and
              'BOTTOM' will insert the line last.</para>
      <para>The newly added line will be highlighted until the collection
              is saved in order to differentiate it from the original items.</para>
      <para>Example configuration (NOTE : the addLinePlacement does not need to specified if 'TOP')...</para>
      <programlisting>
        &lt;bean id="Collections-AddBlankLine-TableLayout" parent="Uif-Disclosure-TableCollectionSection" p:layoutManager.numberOfColumns="4"&gt;
            ...
            &lt;property name="renderAddBlankLineButton" value="true" /&gt;
            &lt;property name="addLinePlacement" value="TOP" /&gt;
            ...
        &lt;/bean&gt;
      </programlisting>
      <figure>
        <title>Collection Add Blank Line Example - TableLayout with TOP add line placement</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../images/KRAD_Guide/KRAD_Collection_AddBlank.png"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
    <section>
      <title>Collection Add Via Lightbox</title>
      <para>Collections can be configured to allow the user to add items to the collection via a modal dialog.</para>
      <para>The add button in the dialog will execute client side checks just like the add action in normal collection
          setup would do and not allow the user to add invalid content.</para>
      <para>To enable this feature the <emphasis role="bold">addViaLightBox</emphasis> property
        on CollectionGroup must be set to true. This can be set on stacked as well as table collection layouts.
        This will cause the default add line actions not to be rendered inside the items and instead an Add Line
        action button will be rendered once for the collection.</para>
      <para>The placement of this button can be set using the <emphasis role="bold">addLinePlacement</emphasis>
        property. Valid values are 'TOP' and 'BOTTOM'. The default will always be 'TOP'. This will also
        determine where the blank will be added to the collection, 'TOP' will insert the line first and
        'BOTTOM' will insert the line last.</para>
      <para>The newly added line will be highlighted until the collection
        is saved in order to differentiate it from the original items.</para>
      <para>Example configuration (NOTE : the addLinePlacement does not need to specified if 'TOP') : </para>
      <programlisting>
        &lt;bean id="Collections-AddViaLightBox-TableLayout" parent="Uif-Disclosure-TableCollectionSection" p:layoutManager.numberOfColumns="4"&gt;
            ...
            &lt;property name="addViaLightBox" value="true" /&gt;
            &lt;property name="addLinePlacement" value="TOP" /&gt;
            ...
        &lt;/bean&gt;
      </programlisting>
      <figure>
        <title>Collection Add Via Lightbox Example - TableLayout with TOP add line placement</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../images/KRAD_Guide/KRAD_Collection_AddViaLightbox.PNG"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
    <section>
      <title>Line Actions</title>
      <para>In Chapter 6 we learned about the action component which is used to render buttons
                or links for our view. These allow the user to perform some action such as making a
                server call or invoking client side script. The collection group provides us the
                ability to configure actions that operate on a collection line. Examples of this are
                the add action (present with the add line to invoke the line addition), and the
                delete action (to remove an item from the collection). These are standard action we
                think about with collections, but others can be added as well. For example, we might
                choose to have a copy action, or a perform detail action. In short, actions can be
                configured for whatever the functional needs are.</para>
      <para>We specify the line actions using the collection group’s <emphasis role="bold">lineActions</emphasis> property. The property holds a list of Action components
                that are rendered when the collection group <emphasis role="bold">renderLineActions</emphasis> property is true (this property gives us a way to
                turn off all actions conditionally). Similar to add line, the framework also
                enforces the condition of the collection group being in editable state (not
                read-only) before the actions will be rendered.</para>
      <para>Let’s configure two buttons for our collection lines. The first button will call a
                server side controller method named ‘copyLine’, and the second will call a server
                side controller method named ‘deleteLine’:</para>
      <programlisting>
&lt;bean parent=”Uif-CollectionGroupBase” p:title=”My First Collection”
    p:propertyName=”test1Object.test2List”
    p:collectionObjectClass=”edu.myedu.sample.Test2Object”&gt;
    &lt;property name=”lineActions”&gt;
&#160;&#160;&#160;     &lt;list&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;bean parent=&quot;Uif-SecondaryActionButton-Small&quot; p:methodToCall=&quot;copyLine&quot; p:actionLabel=&quot;copy&quot;/&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;bean parent=&quot;Uif-SecondaryActionButton-Small&quot; p:methodToCall=&quot;deleteLine&quot; p:actionLabel=&quot;delete&quot;/&gt;
&#160;&#160;&#160;     &lt;/list&gt;
&#160;   &lt;/property&gt;
&lt;/bean&gt;
            </programlisting>
      <para>Notice we have chosen to use the secondary small button styling. This is the
                chosen design for collection buttons by the KRAD team, but any button style may be
                used. Furthermore, any action component may be used, including the action links or
                images.</para>
      <para>Similar to the group items, the set of line action components will be created for
                each collection item present in the model. This means our view could end up with
                several action buttons with label ‘copy’ and ‘delete’, that all call server method
                ‘copyLine’ and ‘deleteLine’. So when the server method is invoked how do we know
                which line was chosen? This is where the action parameters map available on the
                Action component comes into play. When the actions are created during the view
                lifecycle, action parameters will be added to each action component indicating the
                collection path, and the line index. These parameters are then sent with the request
                made when the action is invoked and can be pulled from the request (or form) within
                the controller method. </para>
      <para>What about if we have an add line, will these actions be rendered for it as well?
                In most cases the actions configured for existing lines do not make sense for the
                add line (consider our case with the copy and delete actions). Therefore the line
                actions are not rendered for the add line and instead a separate property is
                provided named <emphasis role="bold">addLineActions</emphasis>. The usual action we
                find here is of course the ‘add’ action. This is used to make the server call for
                adding the line to the collection. Let’s see how we add this:</para>
      <programlisting>
&lt;bean parent=”Uif-CollectionGroupBase” p:title=”My First Collection”
    p:propertyName=”test1Object.test2List”
    p:collectionObjectClass=”edu.myedu.sample.Test2Object”&gt;
&#160;   &lt;property name=”addLineActions”&gt;
&#160;&#160;&#160;     &lt;list&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;bean parent=&quot;Uif-SecondaryActionButton-Small&quot; p:methodToCall=&quot;addLine&quot; p:actionLabel=&quot;add&quot;/&gt;
&#160;&#160;&#160;     &lt;/list&gt;
&#160;   &lt;/property&gt;
&#160;   &lt;property name=”lineActions”&gt;
&#160;&#160;&#160;     &lt;list&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;bean parent=&quot;Uif-SecondaryActionButton-Small&quot; p:methodToCall=&quot;copyLine&quot; p:actionLabel=&quot;copy&quot;/&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;bean parent=&quot;Uif-SecondaryActionButton-Small&quot; p:methodToCall=&quot;deleteLine&quot; p:actionLabel=&quot;delete&quot;/&gt;
&#160;&#160;&#160;     &lt;/list&gt;
&#160;   &lt;/property&gt;
&lt;/bean&gt;
            </programlisting>
      <para>The configuration is the same as the lineActions property, the only different
                being we specify a different property name on the collection group.</para>
      <para>If all you need for your collection is the standard add and delete actions, you’re
                in luck! That is because you get all this for free by extending the
                ‘Uif-CollectionGroupBase’ bean. This bean definition sets the addLineActions to
                include the add action, and likewise sets the lineActions to include the delete
                action. Furthermore, the UifControllerBase class provided with KRAD takes care of
                adding and deleting collection lines. Thus no code required at all by the page
                developer!</para>
      <tip>
        <title>Add/Delete Actions</title>
        <para>In many cases an application needs to do more than&#160;simply modifying the
                    collection when an add or delete request is made. One common requirement is to
                    first validate the data with business rules. Or we might need to invoke some
                    other operation. These needs can be taken care while having the framework take
                    care of the collection manipulation. First, the controller methods delegate the
                    operations to a ViewHelperService. This is a service implementation that is
                    configured on a view instance and performs much of the view related functions.
                    Within the view helper, methods are provided that can be easily overridden to
                    perform validation or other functions. We could also choose to write a
                    controller that extends the UifControllerBase and configure the actions to
                    invoke a custom method. After performing custom logic a call to super can be
                    made to carry out the line action.</para>
      </tip>
    </section>
    <section>
      <title>Validated Line Actions</title>
      <para>A special type of Line Actions are the Validated Line Actions. They do client side validation on the
          related item before the action can be fired. If the validation fails a message dialog will be displayed
          informing the user that the item contains errors and that the action will not be executed.</para>
      <para>We specify the validated line actions using the collection group’s
        <emphasis role="bold">validatedLineActions</emphasis> property. Similar to line actions the property holds a
        list of Action components that are rendered when the collection group
        <emphasis role="bold">renderLineActions</emphasis> property is true (this property gives us a way to
        turn off all actions conditionally). Example : </para>
      <programlisting>
        &lt;bean parent=”Uif-CollectionGroupBase” p:title=”My First Collection”
        p:propertyName=”test1Object.test2List”
        p:collectionObjectClass=”edu.myedu.sample.Test2Object”&gt;
        &#160;   &lt;property name=”validatedLineActions”&gt;
        &#160;&#160;&#160;     &lt;list&gt;
        &#160;&#160;&#160;&#160;&#160;       &lt;bean parent=&quot;Uif-SecondaryActionButton-Small&quot; p:methodToCall=&quot;updateLine&quot; p:actionLabel=&quot;update&quot;/&gt;
        &#160;&#160;&#160;     &lt;/list&gt;
        &#160;   &lt;/property&gt;
        &lt;/bean&gt;
      </programlisting>
      <section>
        <title>Collection Save Action</title>
        <para>A type of Validated Line Action that is configured on collections is the save action. This action
          is not rendered by default. This action will call the saveLine method on the UifControllerBase controller
          which will call the ViewHelperService processCollectionSaveLine method which can be overridden by the client.
          This will allow for processing single collections item.</para>
        <para>The save actions can be rendered by setting the <emphasis role="bold">renderSaveLineActions</emphasis>
          property to true. Example : </para>
        <programlisting>
          &lt;bean id="Collections-SaveLines-TableLayout" parent="Uif-Disclosure-TableCollectionSection" p:layoutManager.numberOfColumns="4"&gt;
          ...
          &lt;property name="renderSaveLineActions" value="true" /&gt;
          ...
          &lt;/bean&gt;
        </programlisting>
      </section>
    </section>
    <section>
      <title>Collection Action Column Sequence</title>
      <para>Collections using TableLayoutManager can be configured to set the action column placement. </para>
      <para>The <emphasis role="bold">layoutManager.actionColumnPlacement</emphasis> property on the CollectionGroup
          can be set to specify the placement of the action column. The default placement will be 'RIGHT'. Other valid
          placement values are 'LEFT' or any valid column number. Values higher than the number of columns or a
          value of -1 will default to 'RIGHT'. </para>
      <para>Example configuration (NOTE : the addLinePlacement does not need to specified if 'TOP')...</para>
      <programlisting>
        &lt;bean id="Collections-ActionColumnPlacement-TableLayout" parent="Uif-Disclosure-TableCollectionSection" p:layoutManager.numberOfColumns="4"&gt;
            ...
            &lt;property name="layoutManager.actionColumnPlacement" value="3" /&gt;
            ...
        &lt;/bean&gt;
      </programlisting>
      <figure>
        <title>Collection Action Column Placement Example</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../images/KRAD_Guide/KRAD_Collection_ActionColumnPlacement.PNG"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
    <section>
      <title>SubCollections</title>
      <para>So we have seen how to bind to primitive types
                (data field), and collection types (collection group), and primitives within a
                collection (collection group data fields), so what about a collection property
                within a collection item? We can do that as well and these are called
                SubCollections.</para>
      <para>Basically we configure a sub-collection the same way as a normal collection, using
                a collection group. The difference is the collection group for a sub-collection is
                nested within another collection group. So we can just set the sub-collection
                collection group in the parent collection group’s items list right? The answer is
                no. The reason being these nested collection groups need to be treated differently
                for rendering than the standard collection group items. Therefore, a property named
                    <emphasis role="bold">subCollections</emphasis> is provided for configuring
                nested collection groups.</para>
      <para>For an example let’s first create a Test3Object, and
                add a list of these objects to our Test2Object:</para>
      <programlisting>
public class Test3Object {
&#160;   private String t3Field;
&#160;   private String t3Field2;
} &#160;

public class Test2Object {
&#160;   private String t2Field;
&#160;   private String t2Field2;
&#160;   private String t2Field3;
&#160;   private List&lt;Test3Object&gt; test3List;
&#160;   private Map&lt;String, String&gt; t2Map;
}
            </programlisting>
      <para>We can then configure the collection group for the sub-collection as
                follows:</para>
      <programlisting>
&lt;bean parent=”Uif-CollectionGroupBase” p:title=”My First Collection”
    p:propertyName=”test1Object.test2List”
    p:collectionObjectClass=”edu.myedu.sample.Test2Object”&gt;
&#160;   &lt;property name=”subCollections”&gt;
&#160;&#160;&#160;     &lt;list&gt;
&#160;&#160;&#160;&#160;&#160;       &lt;bean parent=”Uif-CollectionGroupBase” p:title=”My First Collection”
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;     p:propertyName=”test3List”
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;     p:collectionObjectClass=”edu.myedu.sample.Test3Object”&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;        &lt;property name=”items”&gt;
&#160;&#160;&#160;&#160;&#160;&#160; &#160;&#160;&#160;&#160;         &lt;list&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;            &lt;bean parent=”Uif-InputField” p:propertyName=”t3Field”/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;            &lt;bean parent=”Uif-InputField”
                            p:propertyName=”t3Field2”/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;          &lt;/list&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;        &lt;/property&gt;
&#160;   &lt;/property&gt;
&lt;/bean&gt;
            </programlisting>
      <para>Notice our collection group for the sub-collection is
                configured exactly like any standard collection. Also notice that the property name
                is simply ‘test3List’. This is because the binding for the sub collections follow
                the same rule as the collection group fields (assumed to be on the collection item).
                We can continue adding other sub collections to the list as needed.</para>
      <para>As you might have guessed, the sub-collection could in turn have sub-collections
                and further down the line. The framework does not restrict how many levels the
                nesting can go (in practical terms of screen real estate three levels is usually the
                limit). The number of fields generated when using sub-collections can grow quite
                rapidly. For each parent collection line, a separate sub collection must be rendered
                entirely. For example assume our test2List has 2 items, and our test3List has 3
                items. The line rendering would then be: </para>
      <itemizedlist>
        <listitem>
          <para>Render test2List[0]</para>
          <itemizedlist>
            <listitem>
              <para>Render test2List[0].test3List[0]</para>
            </listitem>
            <listitem>
              <para>Render test2List[0].test3List[1]</para>
            </listitem>
            <listitem>
              <para>Render test2List[0].test3List[2]</para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para>Render test2List[1]</para>
          <itemizedlist>
            <listitem>
              <para>Render test2List[1].test3List[0]</para>
            </listitem>
            <listitem>
              <para>Render test2List[1].test3List[1]</para>
            </listitem>
            <listitem>
              <para>Render test2List[1].test3List[2]</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
      <para>You can clearly see as more
                test2List items are added the number of fields grows fast. Adding other
                sub-collections, or another level of sub-collections makes the rate of growth even
                more rapid. </para>
    </section>
    <section>
      <title>Collection Group Builder</title>
      <para>Coming Soon!</para>
<!-- TODO: Add content here.
          -->    </section>
    <section>
      <title>Recap</title>
      <itemizedlist>
        <listitem>
          <para>A Collection Group is a special group that renders multiple sets of fields
                        and associates with a model property of type Collection</para>
        </listitem>
        <listitem>
          <para>Like an input field, the collection group uses the <emphasis role="bold">propertyName</emphasis> and <emphasis role="bold">bindingInfo</emphasis> properties for finding the property that
                        provides the collection data</para>
        </listitem>
        <listitem>
          <para>When configuring a collection group, we must specify the type for each
                        collection item using the <emphasis role="bold">collectionObjectClass</emphasis> property</para>
        </listitem>
        <listitem>
          <para>All data fields declared within the collection group’s items list are
                        assumed to be on the collection object class (therefore their path given is
                        relative to the path of the collection item)</para>
        </listitem>
        <listitem>
          <para>Collection groups provide data IO at two levels: the individual collection
                        fields and the collection items (data objects). For adding a collection item
                        we use the add line feature which is enabled by the property <emphasis role="bold">renderAddLine</emphasis> (true by default when the group is
                        not read-only)</para>
        </listitem>
        <listitem>
          <para>The add line data object is not part of the collection until the user
                        performs the add operation. Therefore we must hold the data object in a
                        separate property</para>
        </listitem>
        <listitem>
          <para>The UIF provides a general Map on UifFormBase for holding add line
                        objects. We can override this to use a custom property by setting the
                        properties <emphasis role="bold">addLinePropertyName</emphasis> and
                            <emphasis role="bold">addLineBindingInfo</emphasis></para>
        </listitem>
        <listitem>
          <para>By default the components configured in the items property will be used
                        for the add line as well. We can however configure a different list of
                        components using the <emphasis role="bold">addLineItems</emphasis>
                        property</para>
        </listitem>
        <listitem>
          <para>Collections can be configured to allow the user to add blank editable lines to the collection.
            This way the user is forced to add the line to the collection before entering data. To enable this
            feature the <emphasis role="bold">renderAddBlankLineButton</emphasis> property
            on CollectionGroup must be set to true.</para>
        </listitem>
        <listitem>
          <para>Collections can be configured to allow the user to add items to the collection via a modal dialog.
            To enable this feature the <emphasis role="bold">addViaLightBox</emphasis> property
            on CollectionGroup must be set to true.</para>
        </listitem>
        <listitem>
          <para>The collection group provides the property <emphasis role="bold">addLineLabel</emphasis> which is used by layout managers to label the
                        add line</para>
        </listitem>
        <listitem>
          <para>Action fields that perform an action related to an existing line can be
                        given using the <emphasis role="bold">lineActions</emphasis> property. For
                        the add line actions are given using the <emphasis role="bold">addLineActions</emphasis> property. Common examples include the
                        ‘delete’ action for existing lines and the ‘add’ action for the add
                        line</para>
        </listitem>
        <listitem>
          <para>Validated Action fields that perform an validation and an action related to an existing line can be
            given using the <emphasis role="bold">validatedLineActions</emphasis> property.</para>
        </listitem>
        <listitem>
          <para>The display of the actions is controlled by the property
            <emphasis role="bold">renderLineActions</emphasis> (by default is true when the
                        group is not read-only)</para>
        </listitem>
        <listitem>
          <para>We can specify the placement of the action column on collection groups using TableLayoutManager
            by setting the <emphasis role="bold">layoutManager.actionColumnPlacement</emphasis> property.</para>
        </listitem>
        <listitem>
          <para>Collection group beans can extend the base bean ‘Uif-CollectionGroupBase’
                        which configures the add and delete buttons by default</para>
        </listitem>
        <listitem>
          <para>We can create a controller that extends <emphasis role="bold">UifControllerBase</emphasis> which provides handling of the add and
                        delete line actions. If we need to perform custom actions (such as
                        validation), we can override the controller method or implement the
                        ViewHelperService method <emphasis role="bold">processBeforeAddLine</emphasis> or <emphasis role="bold">processAfterAddLine</emphasis></para>
        </listitem>
        <listitem>
          <para>In addition to providing data IO for primitive property types on a
                        collection, we also have nested collection property types. These are
                        referred to as sub-collections</para>
        </listitem>
        <listitem>
          <para>Sub-collections are just a collection that is nested, therefore we use a
                        collection group and configure in the same way as a non-nested collection.
                        The only difference is we then add this collection group to the <emphasis role="bold">subCollections</emphasis> property of the parent collection
                        group</para>
        </listitem>
        <listitem>
          <para>When configuring the property path for the sub-collection, (like the
                        collection items) it is assumed to be related to the collection object
                        class</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>
  <section>
    <title>Component Prototypes </title>
    <para>Coming Soon!</para>
<!-- TODO: Add content here.
          -->    <section>
      <title>Recap</title>
      <itemizedlist>
        <listitem>
          <para>In many places of the UIF components needs to be created dynamically based
                        on data or other conditions. A good example of this are components
                        configured for a collection group. For example when we specify the
                        lineActions, these action needs to be rendered for each line. Therefore we
                        need separate components for each line (the same components cannot be used
                        for reasons such as id, action parameters, property paths and so on).
                    </para>
        </listitem>
        <listitem>
          <para>When the framework needs to dynamically build a component it makes a copy
                        of the component configured. Therefore the configured component acts as a
                        prototype for the component creations rather than being the actual component
                        that is rendered</para>
        </listitem>
        <listitem>
          <para>Many properties have the suffix ‘prototype’ in their name to indicate this
                        purpose</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>
  <section>
    <title>Collection Layout Managers </title>
    <para>Again we know the group component (including collection groups) has no knowledge of
            how to position the components it holds. Therefore we need to associate a layout manager
            with the group. Because of the unique features we have seen with collection groups, they
            require a special type of layout manager. These layout managers must implement the
            interface org.kuali.rice.krad.uif.layout.CollectionLayoutManager, which requires a
            method named buildLine to be implemented. Collection layout managers have to do a lot
            more work than the standard layout managers. For the standard manager such as grid and
            box, most of the work can be simply done through the template by the process described
            earlier in this chapter. Collection layout managers though need to do work in code to
            collect the generated collection line fields (and actions) and in cases create wrapping
            components (this will become more clear as we continue).</para>
    <para>Setting aside the concerns of item layout, the collection group appears just like the
            standard group. We have the group header, instructional message, errors field, the group
            items, and the footer. The difference comes where the items are rendered, which we will
            again call the Layout Area.</para>
    <para>Version 2.0 of KRAD comes with two collection layout mangers, the Table Layout Manager
            and the Stacked Layout Manager. Let’s take a close look at each of these.</para>
    <section>
      <title>Table Layout</title>
      <para>The Table Layout manager does as you might expect, creates an HTML table! However,
                unlike the table created by the grid layout these tables follow more closely with
                what we think of as a data table (for example a spreadsheet). These tables have the
                following characteristics:</para>
      <orderedlist>
        <listitem>
          <para>Each collection item is one line in the table. Note we say line instead of
                        row (tr). In most cases a line is a single table row, but can span multiple
                        rows.</para>
        </listitem>
        <listitem>
          <para>Each item field is a column in the table. The field label is presented as
                        the column header.</para>
        </listitem>
      </orderedlist>
      <para>The basic table layout is shown below.</para>
      <figure>
        <title>Table Layout Manager</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../images/KRAD_Guide/KRAD_Table_Layout.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>In addition to the columns rendered for the group items, the table layout manager
                will create two additional columns. One of these will hold the line actions. Recall
                our line actions are configured as a list of Action components on the collection
                group. In order to place these in a cell, the table layout manager wraps these
                actions into a Field Group. We use the prototype pattern to specify how the action
                field groups should be created. The property for doing so is <emphasis role="bold">actionFieldPrototype</emphasis>.</para>
      <para>By default these prototype is set as follows:</para>
      <programlisting>
&lt;property name=&quot;actionFieldPrototype&quot;&gt;
    &lt;bean parent=&quot;Uif-HorizontalFieldGroup&quot; p:align=&quot;center&quot; p:label=&quot;Actions&quot;
        p:shortLabel=&quot;Actions&quot;/&gt;
&lt;/property&gt;
            </programlisting>
      <para>For each collection item a new field group component will be created by copying
                this prototype. The list of actions will then also be copied, and finally inserted
                as the items on the nested field group. The prototype definition here stated the
                field group items (actions) will be rendered using a horizontal box layout.
                Furthermore is specifies a label for the field of ‘Actions’, which like the label
                for the collection fields will be displayed as the column header. Finally we are
                specifying our content should align center.</para>
      <para>The second column the table layout manager will add is referred to as the sequence
                column. This is a column that will provide a label for each row. Typically the label
                is either a generated sequence (1,2,3…) or uses an identifier property from the
                collection item class (such as a line number or unique identifier). To enable the
                column, the property <emphasis role="bold">renderSequenceField</emphasis> on the
                table manger must be set to true (default). We then need to specify where the
                sequence value should come from. One way of doing this is to allow the framework to
                create the sequence value for us. This is basically a numbering of each line
                starting with one. To use autosequencing we set the property generateAutoSequence to
                true.</para>
      <section>
          <title>Row Details Group option</title>
          <para>Table collections can now display addition details per a row.  When using this functionality an additional column with a “Details” link will be available, and when the user clicks on it the configured group to display for that row will be revealed/disclosed below that row.  The intended uses of this functionality is for the user to be able to discover additional information about that collection item without having to leave the page, or hide content that can become large, such as descriptions.
</para>
          <para><emphasis role="bold">Note: Currently ONLY readOnly content is officially supported, and any content that relies on javascript functionality is NOT supported in this release. </emphasis></para>
          <para>To use a row details group with a Uif-TableCollectionSection (or variation of) you setup the following properties on its <emphasis role="bold">layoutManager</emphasis> (It is <emphasis role="bold">REQUIRED</emphasis> that the layoutManager is using richTable functionality - in other words, it is using the dataTables jQuery plugin to render):
</para>
          <para><emphasis role="bold">rowDetailsGrou</emphasis>p – this can be ANY group or section content you would like to use for the content of details.  The input and data fields used in this group will automatically inherit the necessary collection binding path just like items of the collection itself.
layoutManager.</para>
          <para><emphasis role="bold">rowDetailsLinkName</emphasis> – this is the name of the link if an image is not being used. </para>
          <para><emphasis role="bold">rowDetailsUseImage</emphasis> – this will use an image instead of text for the link.  This link with be a + sign when closed and an – sign when opened.
If neither a name nor images are set to be used, the link will be called “Details” by default.
</para>
          <para>Sample code using the images option, the group defined is a vertical box group with 2 input fields, these are fields of the collection item:
</para>
          <programlisting>&lt;bean id=&quot;Demo-RowDetails-Section2&quot; parent=&quot;Uif-TableCollectionSection&quot;&gt;
...
   &lt;property name=&quot;layoutManager.rowDetailsUseImage&quot; value=&quot;true&quot;/&gt;
    &lt;property name=&quot;layoutManager.rowDetailsGroup&quot;&gt;
      &lt;bean parent=&quot;Uif-VerticalBoxGroup&quot;&gt;
        &lt;property name=&quot;items&quot;&gt;
          &lt;list&gt;
            &lt;bean parent=&quot;Uif-InputField&quot; p:propertyName=&quot;field3&quot; p:label=&quot;Field 3&quot;
                  p:required=&quot;true&quot;/&gt;
            &lt;bean parent=&quot;Uif-InputField&quot; p:propertyName=&quot;field4&quot; p:label=&quot;Field 4&quot;
                  p:required=&quot;true&quot;/&gt;
          &lt;/list&gt;
        &lt;/property&gt;
      &lt;/bean&gt;
    &lt;/property&gt;</programlisting>
          <para><emphasis role="bold">A note on column width: </emphasis> If you would like the details column to take up less space than it does by default, you must manually alter the column width as follows (20px is the width we are manually setting here and 0 is the index of the details column):</para>
          <programlisting>&lt;property name=&quot;layoutManager.applyDefaultCellWidths&quot; value=&quot;false&quot;/&gt;
    &lt;property name=&quot;layoutManager.richTable.templateOptions&quot;&gt;
      &lt;map merge=&quot;true&quot;&gt;
        &lt;entry key=&quot;aoColumnDefs&quot; value=&quot;[{&amp;quot;sWidth&amp;quot; : &amp;quot;20px&amp;quot;, &amp;quot;aTargets&amp;quot; : [0]}]&quot;/&gt;
      &lt;/map&gt;
    &lt;/property&gt;</programlisting>
          <figure>
            <title>Row Details</title>
            <mediaobject>
              <imageobject>
                <imagedata fileref="../images/KRAD_Guide/rowDetails.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          
    </section>
    <section>
      <title>Stacked Layout</title>
      <para>Coming Soon!</para>
<!-- TODO: Add content here.
          -->      <figure>
        <title>Stacked Layout Manager</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../images/KRAD_Guide/KRAD_Stacked_Layout_Manager.png"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
    <section>
      <title>The List Template</title>
      <para>Coming Soon!</para>
<!-- TODO: Add content here.
          -->    </section>
    <section>
      <title>Recap</title>
      <itemizedlist>
        <listitem>
          <para>Due to the nature of collection groups special layout mangers are needed.
                        These must implement the interface
                        org.kuali.rice.krad.uif.layout.CollectionLayoutManager which requires
                        implementing the method <emphasis role="bold">buildLine</emphasis></para>
        </listitem>
        <listitem>
          <para>KRAD provides two collection layout managers: the Table layout
                        manager and the Stacked layout manager</para>
        </listitem>
        <listitem>
          <para>The table layout manager creates an HTML table in the form of a
                        data grid, whose characteristics are the following:</para>
          <itemizedlist>
            <listitem>
              <para>Each collection item is one line in the table (which might
                                correspond to one or more table rows)</para>
            </listitem>
            <listitem>
              <para>Each item field is a column in the table</para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para>The table layout manager can also add two columns for us. The first
                        being the action column which will present the configured actions
                        (lineActions or addLineActions) for the associated collection group</para>
        </listitem>
        <listitem>
          <para>The field group that is rendered in the action column is configured
                        using the <emphasis role="bold">actionFieldPrototype</emphasis> property.
                        The label given for the prototype is used to label the table column</para>
        </listitem>
        <listitem>
          <para>The second column the layout manager can add is called the sequence
                        column. This is used to label the row (using a th with scope row)</para>
        </listitem>
        <listitem>
          <para>We can specify a property whose value will be displayed in the
                        sequence column by setting the property <emphasis role="bold">sequenceFieldPrototype</emphasis> (Note this property is actually of
                        type Field, meaning we could instead use a message field or other type of
                        field)</para>
        </listitem>
        <listitem>
          <para>We can also have the table layout manager automatically number each
                        row for us by setting the property <emphasis role="bold">generateAutoSequence</emphasis> to true</para>
        </listitem>
        <listitem>
          <para>By default the add line will be rendered as the first line of the
                        table. We can have the add line render before the table by setting property
                            <emphasis role="bold">separateAddLine</emphasis> to true. When doing so
                        the group property <emphasis role="bold">addLineGroup</emphasis> will be
                        used to render the add line contents. This can be configured to use the
                        layout and other properties necessary (note: the separate add line group is
                        generally needed when our add line fields do not match up with the fields
                        configured for existing lines)</para>
        </listitem>
        <listitem>
          <para>The table layout manager also supports the following options:</para>
          <itemizedlist>
            <listitem>
              <para>useShortLabels – For creating the table header row the labels
                                for each field configured in the items list will be pulled. By
                                default the label property is used, however if this property is set
                                to true the shortLabel will be used instead. This is helpful if
                                there are many table columns</para>
            </listitem>
            <listitem>
              <para>headerLabelPrototype – Prototype label component that will be
                                copied to create the table headers. Styling and other properties can
                                be set this way</para>
            </listitem>
            <listitem>
              <para>richTable – The nested RichTable widget that adds on client
                                side features such as sorting, paging, and export. These options can
                                be changed on a per table bases by setting the options on the nested
                                property (If a basic table with no client side features is desired,
                                simply set richTable.render to false)</para>
            </listitem>
            <listitem>
              <para>numberOfColumns and supressLineWrapping – The table layout
                                manager extends the grid layout manager (used for general groups).
                                Therefore all of the properties available for the grid layout are
                                also available for the table layout. This includes setting the
                                number of columns for the table. If the number of columns is less
                                than the number of fields configured in the items property, multiple
                                rows will be created for each collection item as necessary. In most
                                cases we want the number of columns to match the number of
                                configured items. The property supressLineWrapping can be set to
                                true of force this condition (in which case the numberOfColumns
                                property does not need to be set).</para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para>The following beans are provided for the table layout:</para>
          <itemizedlist>
            <listitem>
              <para>Uif-TableCollectionLayout – Base bean for the table collection
                                layout. Sets defaults for many of the properties and add the style
                                class ‘uif-tableCollectionLayout’</para>
            </listitem>
            <listitem>
              <para>Uif-TableCollectionGroup – General group (not associated with
                                any level) configured with a table layout. Adds the style class
                                ‘uif-tableCollectionGroup’</para>
            </listitem>
            <listitem>
              <para>Uif-TableCollectionSection – Section level group configured
                                with a table layout. Adds the style class
                                ‘uif-tableCollectionSection’</para>
            </listitem>
            <listitem>
              <para>Uif-TableCollectionSubSection – Sub-section level group
                                configured with a table layout. Adds the style class
                                ‘uif-tableCollectionSubSection’</para>
            </listitem>
            <listitem>
              <para>Uif-TableSubCollection-WithinSection – For a sub-collection
                                group using a table layout where the parent is at the section level
                                (because sub-collections need to appear nested, it is necessary to
                                adjust header levels and styling for the collection group)</para>
            </listitem>
            <listitem>
              <para>Uif-TableSubCollection-WithinSubSection – For a sub-collection
                                group using a table layout where the parent is at the sub-section
                                level</para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para>Similar to the difference between the two general group layouts
                        (the grid table based and the box div based), is the difference between the
                        table and stacked collection layout managers</para>
        </listitem>
        <listitem>
          <para>A stacked layout manager renders each collection line in a div. In
                        other words for each collection item a standard Group is created containing
                        the items for that line</para>
        </listitem>
        <listitem>
          <para>The groups generated from the stacked manager by default ‘stack’ on
                        each other, that is by default they are positioned using a box layout with
                        vertical orientation</para>
        </listitem>
        <listitem>
          <para>The groups generated from the stacked manager by default ‘stack’ on
                        each other, that is by default they are positioned using a box layout with
                        vertical orientation</para>
        </listitem>
        <listitem>
          <para>The group for each line is created from the <emphasis role="bold">lineGroupPrototype</emphasis> property. For the add line, the <emphasis role="bold">addLineGroup</emphasis> group is used (note since only one
                        add line is needed this group is used directly, not copied)</para>
        </listitem>
        <listitem>
          <para>Since a group is generated for each line, the line fields are
                        positioned according to the layout manager of that group. Therefore when
                        using a stacked layout manager we also have a choice of the layout manager
                        to use for each line group (such as grid, horizontal or vertical box)</para>
        </listitem>
        <listitem>
          <para>Similar to the sequence field used by the table layout manager to
                        label each line, the stacked layout labels each line using the header for
                        the line’s group. </para>
        </listitem>
        <listitem>
          <para>For existing lines, the properties <emphasis role="bold">summaryTitle</emphasis> and <emphasis role="bold">summaryFields</emphasis> are used. The summaryTitle is a string that
                        will be set as the group header text (this can contain expressions for
                        adding dynamic content). The summaryFields property is a List of property
                        names whose value should be appended to the title. These properties are
                        assumed to be relative to the collection object class (this property will be
                        renamed to summaryPropertyNames in version 2.2)</para>
        </listitem>
        <listitem>
          <para>The overall layout of the generate groups (along with other
                        properties such as styling classes) can be controlled by configured the
                            <emphasis role="bold">wrapperGroup</emphasis> property</para>
        </listitem>
        <listitem>
          <para>The following beans are provided for using the stacked layout:</para>
          <itemizedlist>
            <listitem>
              <para>Uif-StackedCollectionLayoutBase – Base bean for the stacked
                                layout manager. Sets up some prototypes and adds the style class
                                ‘uif-stackedCollectionLayout’</para>
            </listitem>
            <listitem>
              <para>Uif-StackedCollectionLayout-WithGridItems – Stacked layout
                                manager that has a configured line group prototype to use a grid
                                layout</para>
            </listitem>
            <listitem>
              <para>Uif-StackedCollectionLayout-WithBoxItems - Stacked layout
                                manager that has a configured line group prototype to use a box
                                layout</para>
            </listitem>
            <listitem>
              <para>Uif-StackedCollectionGroup - General group (not associated
                                with any level) configured with a stacked layout with line group
                                grid layout. Adds the style class
                                ‘uif-stackedCollectionGroup’</para>
            </listitem>
            <listitem>
              <para>Uif-StackedCollectionSection – Section level group configured
                                with a stacked layout with line group grid layout. Adds the style
                                class ‘uif-stackedCollectionSection’</para>
            </listitem>
            <listitem>
              <para>Uif-StackedCollectionSubSection – Sub-section level group
                                configured with a stacked layout with line group grid layout. Adds
                                the style class ‘uif-stackedCollectionSubSection’</para>
            </listitem>
            <listitem>
              <para>Uif-StackedSubCollection-WithinSection – For a sub-collection
                                group using a stacked layout where the parent is at the section
                                level (because sub-collections need to appear nested, it is
                                necessary to adjust header levels and styling for the collection
                                group)</para>
            </listitem>
            <listitem>
              <para>Uif-StackedSubCollection-WithinSubSection – For a
                                sub-collection group using a stacked layout where the parent is at
                                the sub-section level</para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para>An alternate template for the stacked collection layout is provided
                        that renders each line group in a list item. The following base beans are
                        provided for a collection group that uses the stacked list template:
                        ‘Uif-ListCollectionGroup’, ‘Uif-ListCollectionSection’, and
                        ‘Uif-ListCollectionSubSection’</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>
  <section>
    <title>Disclosure </title>
    <para>Coming Soon!</para>
<!-- TODO: Add content here.
          -->    <section>
      <title>Recap</title>
      <itemizedlist>
        <listitem>
          <para>The <emphasis role="underline">Disclosure</emphasis> component can be used
                        to allow for showing and hiding of presented content</para>
        </listitem>
        <listitem>
          <para>All groups contains the disclosure component that can be enabled to
                        provide the ability to collapse a part of the page</para>
        </listitem>
        <listitem>
          <para>The UIF provides beans for all the group beans with disclosure
                        enabled</para>
        </listitem>
        <listitem>
          <para>All the disclosure bean names start with ‘Uif-Disclosure’ (for example
                        Uif-Disclosure-GridGroup)</para>
        </listitem>
        <listitem>
          <para>The disclosure widget supports the <emphasis role="bold">defaultOpen</emphasis> property, along with options for rendering (such
                        as animation properties and collapse image)</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>
  <section>
    <title>Scrollable</title>
    <para>Adding Scrollable to a group, section or sub-section enables a scroll bar to appear when the content exceeds
    height that is specified with Scrollable.</para>
    <figure>
      <title>Scrollable Section</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="../images/KRAD_Guide/scrollableSection.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <programlisting>
&lt;bean id=”MyScrollableGroup” parent=”Uif-Disclosure-VerticalBoxSection” p:headerText=”Scrollable Groupt” p:width=&quot;30%&quot;&gt;
    &lt;property name=&quot;scrollpane&quot;&gt;
        &lt;bean parent=&quot;Uif-Scrollpane&quot;&gt;
            &lt;property name=&quot;height&quot; value=&quot;100px&quot;/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
... </programlisting>
    <para>For section and sub-section only the content is scrolled, not the title or instructional text.</para>
    <section>
      <title>Recap</title>
      <itemizedlist>
        <listitem>
          <para>The <emphasis role="underline">Scrollable</emphasis> component can be used
            to enable scrolling in groups and sections.</para>
        </listitem>
        <listitem>
          <para>The height property on Scrollable needs to be specified. </para>
        </listitem>
        <listitem>
          <para>The height property is given in pixels or percentages (e.g. 100px or 30%). </para>
        </listitem>
        <listitem>
          <para>Only the content of the section and subsection will be scrolled, not the title or instructional text.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>
  </section>
</chapter>
