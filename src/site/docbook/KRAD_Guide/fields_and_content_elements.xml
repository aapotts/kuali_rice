<?xml version='1.0' encoding='UTF-8'?>
<!--

    Copyright 2005-2013 The Kuali Foundation

    Licensed under the Educational Community License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.opensource.org/licenses/ecl2.php

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

--><chapter xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://docbook.org/ns/docbook" xml:id="fields_and_content_elements" version="5.0">
  <title>Fields and Content Elements </title>
  <para>Throughout the next few chapters, we will be taking a detailed look at the component types
    and the individual components available out of the box with KRAD. We will start small and work
    our way up to the entire view. By the end of this section, you will be armed with knowledge you
    can use to create a wide variety of rich web interfaces!</para>
  <para>In this chapter, we will look at the Content Element and Field component types. These form
    the palette from which we can paint our page. Content elements are components that will generate
    an HTML element tag. Their properties are generally used to populate an available attribute of
    the HMTL tag. Therefore, if you are familiar with the base set of HTML tag, learning these
    components should be no problem!</para>
  <para>The Field component type is a wrapper. It is associated with the HTML span tag that allows
    us to enclose one or more elements, and treat them as one unit for layout purposes. The field
    also allows us to declare a label which will be presented with the field block. For convenience,
    KRAD includes field components that have present elements included. This allows for easy
    bundling in a group and applying a layout to the set of fields. If a span is not needed, the
    elements can be directly configured in a group and rendered using the configured layout
    manager.</para>
  <para>So to learn more about what we can do with elements and fields, let's take a look at each
    component we have in these types. </para>
  <section>
    <title>Field Labels </title>
    <para>One commonly used content element we have is the Label component. As you might have
      guessed, this component will render an HTML Label element. To create a new label component, we
      create a new bean with parent="Uif-Label":</para>
    <programlisting>&lt;bean parent="Uif-Label" ... &gt;</programlisting>
    <para>The label component is one of the simplest to use, since there are few properties which it
      accepts. However, there is one required property – the label text! This is the actual text
      that will appear on the screen as the label. To specify this, we can use the labelText
      property:</para>
    <programlisting>&lt;bean parent="Uif-Label" p:labelText="Book Title"/&gt;</programlisting>
    <para>In most cases, this is all we need to do! The resulting HTML will look like the
            following:</para>
    <programlisting>&lt;label id=&quot;66_label"&gt;Field Label&lt;/label&gt;</programlisting>
    <para>Wait, where did the id come from? Recall that all components extend ComponentBase which
      provides several properties for us, including the id property. If not specified, the framework
      will generate an id for us automatically and use it for the element id attribute. We can
      specify a different id in either of the following two ways:</para>
    <programlisting>&lt;bean id="mylabel" parent="Uif-Label" p:labelText="Book Title"/&gt;</programlisting>
    <programlisting>&lt;bean parent="Uif-Label" p:id="mylabel" p:labelText="Book Title"/&gt;</programlisting>
    <para>In addition to the id property provided by ComponentBase, there are many others we
            might want to use. Some that might be useful for the label component include title,
            style, and styleClasses.</para>
    <para>When generating a label, it is a best practice (for accessibility reasons) to also
            specify the for attribute. The value for this attribute is the id of the element for
            which the label applies. On the label component, we can configure this value using the
            labelForComponentId property:</para>
    <programlisting>&lt;bean parent="Uif-Label" p:labelText="Book Title" p:labelForComponentId="bookTitle"/&gt;</programlisting>
    <para>However, this is usually not necessary. Instead of creating the label component directly,
      we can let the field component create one for us. The field component provides some assistance
      to us for configuring the label and associating it with a component. To understand this, first
      let's look at the generic FieldBase class from which all fields extend:</para>
    <programlisting>
public class FieldBase extends ComponentBase implements Field {
    private Label fieldLabel;
} </programlisting>
    <para>We see the field base encapsulates a label component. Thus when creating a field
            component we can set the label component properties using the spring nested syntax (dot
            notation)</para>
    <programlisting>&lt;bean parent="Uif-DataField" p:fieldLabel.labelText="My Data Field" ... &gt;</programlisting>
    <para>Since the label is bundled within the field which is a wrapper for another component,
            the labelForComponentId property will be automatically set (to the id of that wrapped
            component).</para>
    <para>The Field component also provides a more convenient way of setting the label text. Instead
      of using the nested notation of 'fieldLabel.labelText', we can simply set the 'label'
      property:</para>
    <programlisting>&lt;bean parent="Uif-DataField" p:label="My Data Field" ... &gt;</programlisting>
    <para>The given value will then be set on the label property of the nested label
            component.</para>
    <section>
      <title>Other Label Options</title>
      <para>In addition to the properties described previously, the label component offers the
                following properties:</para>
      <para><emphasis role="keyword">renderColon</emphasis> – This indicates whether a colon should be
        rendered after the label text. For example, the label text of 'Foo' will result in 'Foo:'
        being rendered.</para>
      <para><emphasis role="keyword">requiredMessage</emphasis> – This is a message component that will
        be rendered with the label to indicate that the element associated with the label (generally
        a control) is required. By default, the message text is configured to be '*' but can be
        changed on a global or case by case basis:</para>
      <programlisting>&lt;bean parent="Uif-DataField" p:label="My Data Field" p:label.requiredMessage="required"/&gt;</programlisting>
      <para>Like all components, the required message will be displayed if its render property
                is true. Therefore we can set the required message to not display as follows:</para>
      <programlisting>&lt;bean parent="Uif-DataField" p:label="My Data Field" p:label.requiredMessage.render="false"/&gt;</programlisting>
      <para>However, we typically want to display the required message when the component the label
        is associated with is required. This is again where our Field component provides value. The
        field will look at the required property (on all components) of the wrapped component, and,
        if set to true, will then set the render property to true for the label's required message.
        Likewise, if the component's required property is false, the render property on the required
        message will be set to false. Therefore these two properties are synced.</para>
      <note>
        <title>Automatic Setting of Properties?</title>
        <para>In this section we have mentioned a few cases where the field component will
          automatically set values for us based on a condition. Where does this happen? Well in code
          of course! Besides simply holding the property values for us, the component class can also
          perform logic which are invoked during the view lifecycle. Therefore, if we wanted to
          change the component behavior, we would need to create a new class and then override the
          base bean definition as described. </para>
      </note>
      <para><emphasis role="keyword">requiredMessagePlacement</emphasis> – Along with the required
        message, the label component also provides a required message placement option. This
        indicates where the required message should be rendered in relation to the label text. The
        type for this property is org.kuali.rice.krad.uif.UifConstants.Position, which is an enum
        for the four possible positions (LEFT, TOP, RIGHT, BOTTOM). However, in the case of the
        required message, only the LEFT and RIGHT positions are supported.</para>
    </section>
    <section>
      <title>Other Field Label Options</title>
      <para>The field also provides some additional properties that related to the label.
                These are:</para>
      <para><emphasis role="keyword">labelPlacement </emphasis>– Similar to the
        requiredMessagePlacement of the label component, this property is of type Position. It
        indicates where the label should be placed in relation to the other field content (the
        wrapped component(s)). The LEFT, TOP, or RIGHT position may be specified:</para>
      <programlisting>&lt;bean parent="Uif-DataField" p:label="My Data Field" p:labelPlacement="LEFT"/&gt;</programlisting>
      <programlisting>&lt;bean parent="Uif-DataField" p:label="My Data Field" p:labelPlacement="TOP"/&gt;</programlisting>
      <programlisting>&lt;bean parent="Uif-DataField" p:label="My Data Field" p:labelPlacement="RIGHT"/&gt;</programlisting>
      <para>These three configurations are shown in the figure below. </para>
      <figure>
        <title>labelPlacement Options</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../images/KRAD_Guide/labelPlacement.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para><emphasis role="keyword">shortLabel</emphasis> – On the field component, we can also
        configure an alternate 'short' label. When necessary, the short label can be pulled instead
        of the standard 'long' label. For example, the table layout manager in KRAD will use the
        short label for the table headers.</para>
      <programlisting>&lt;bean parent="Uif-DataField" p:label="My Data Field" p:shortLabel="My Fld"/&gt;</programlisting>
    </section>
    <section>
      <title>Base Beans</title>
      <para>With the various configuration options such as what to render and where, it can
                overwhelming. We certainly do not want to think through each setting for every field
                we create. To help with this, base beans are provided sensible defaults based on the
                label placement. These beans exist for the data field and input field (two most
                commonly used fields). </para>
      <para>Uif-DataField – Default which sets label placement to left, render colon as true,
                and required message placement to right</para>
      <para>Uif-DataField-LabelTop – Sets label placement as top, render colon as false, and
                required message placement to right</para>
      <para>Uif-DataField-LabelRight – Sets label placement to right, render colon as false,
                and required message placement to left</para>
      <para>Similar beans exist for the Uif-InputField. To use one of the label
                configurations, we simply change our parent bean:</para>
      <programlisting>&lt;bean parent="Uif-DataField-LabelTop" p:labelText="My Data Field" /&gt;</programlisting>
    </section>
    <section role="NotInToc">
      <title>Recap</title>
      <itemizedlist>
        <listitem>
          <para>The link content element component renders an html label tag</para>
        </listitem>
        <listitem>
          <para>The text for the label is specified using the <emphasis role="keyword">labelText</emphasis> property</para>
        </listitem>
        <listitem>
          <para>The <emphasis role="keyword">labelForComponentId</emphasis> property on a label
            specifies the component id the label is associated with</para>
        </listitem>
        <listitem>
          <para>Generally we don't need to create label components ourselves, but instead configure
            them through a field component</para>
        </listitem>
        <listitem>
          <para>Labels can also include a required message that indicates the field associated with
            the label has required input</para>
        </listitem>
        <listitem>
          <para>The field component will automatically set the for property on the label, along with
            setting the required message field component's render flag to true if the field is
            required</para>
        </listitem>
        <listitem>
          <para>On the label component we can specify whether a colon should be added with
                        the <emphasis role="keyword">renderColon</emphasis> Boolean</para>
        </listitem>
        <listitem>
          <para>On the label component we can also specify whether the required message
                        appears to the left or right of the label using the <emphasis role="keyword">requiredMessagePlacement</emphasis> property</para>
        </listitem>
        <listitem>
          <para>The field component allows us to specify where the label is placed in
                        relation to the field contents. The options are left, top, or right</para>
        </listitem>
        <listitem>
          <para>The field component allows us to specify a short label that can be used instead of
            the 'long' label by some layout managers (for example the table layout manager)</para>
        </listitem>
        <listitem>
          <para>Base beans are provided for data and input fields that have different configurations
            for a label. The render colon and requirement message placement properties are set based
            on the label placement</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>
  <section>
    <title>Data Fields and Input Fields </title>
    <para>Two fields that are used often in enterprise applications are the DataField and
      InputField. Generally, enterprise applications have a large amount of data input and output.
      This IO is performed using an HTML Form. The properties that back the form (provide and accept
      the data) are stored on a model. For our purposes now, we can think of the model as a simple
      JavaBean (more information will be given in the section 'Data Binding'). When we need to
      display one of these properties using KRAD, we configure a DataField or InputField.</para>
    <section>
      <title>Data Field</title>
      <para>A Data Field is used to display a property value from the model as read-only. When we
        say read-only, this means the value is displayed as static text on the page and the user
        cannot change its value. To create a data field we specify a new bean with
        parent="Uif-DataField":</para>
      <programlisting>&lt;bean parent="Uif-DataField" ... &gt;</programlisting>
      <para>When configuring a data field for our view, we must associate it with a property
                on the model object. This is accomplished using the propertyName property. For
                example, suppose we had the following model object:</para>
      <programlisting>
public class BookForm {
  private String bookId;
  private String bookTitle;
  // getters/setters
}
            </programlisting>
      <para>To create a data field for the bookId property, our configuration would be as
                follows:</para>
      <para>&lt;bean parent="Uif-DataField" p:propertyName="bookId" p:label="Book"/&gt;</para>
      <para>Recall from the previous section that our data field includes a label element and, by
        default, is configured to be placed to the left of the field content. Therefore, the result
        of this will appear as in the figure below.</para>
      <figure>
        <title>Data Field Label</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../images/KRAD_Guide/dataFieldLabel.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>The given property name can be a nested path. For an example of this, suppose now
                our model is the following:</para>
      <programlisting>
public class BookForm {
  private Book book;
  
  // getters/setters
}

public class Book {
  private String bookId;
  private String bookTitle;
}
            </programlisting>
      <para>To display the bookId now, our property name should be "book.bookId". This is the same
        as doing getBook().getBookId(). More complex situations will be covered in the section
          '<link linkend="data_binding" endterm="data_binding.title"/>'.</para>
    </section>
    <section>
      <title>Input Field</title>
      <para>An Input Field extends from the Data Field and gives edit capability. This means the
        user can change the value for the associated property and submit it back using the HTML
        form. Values are edited using an HTML control which is represented in KRAD with a Control
        content element. We will learn all about the various types of controls later on in this
        chapter. </para>
      <para>To create a new input field, we specify a new bean with parent="Uif-InputField":</para>
      <programlisting>&lt;bean parent="Uif-InputField" ... &gt;</programlisting>
      <para>Now since input field is also a data field, we must specify the property it is
                associated with using the propertyName property:</para>
      <programlisting>&lt;bean parent="Uif-InputField" p:propertyName="bookId"/&gt;</programlisting>
      <para>Furthermore, since we have an input field and want to allow the user to change the
                value, we need to configure a control component to use. We set the control component
                for the input field using the <emphasis role="keyword">control</emphasis>
                property:</para>
      <programlisting>
&lt;bean parent="Uif-InputField" p:propertyName="bookId" p:label="Book Id"&gt;
    &lt;property name="control"&gt;
    &lt;bean parent="Uif-TextControl"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>
      <para>The control component is a new object, not a primitive. Therefore, we use a bean or ref
        tag to provide the value. In this example, we are using the text control whose bean id is
        'Uif-TextControl'. If needed, we could set properties on the text control component using
        the p namespace or nested property tags.</para>
      <para>In the figure below we see the result of the above input field
                configuration.</para>
      <para>The rendered HTML for our input field will be the following:</para>
      <programlisting>&lt;input id=&quot;u66&quot; name=&quot;bookId&quot; class=&quot;uif-control uif-textControl valid&quot; tabindex=&quot;0&quot; type=&quot;text&quot; value=&quot;&quot; size=&quot;30&quot; aria-invalid=&quot;false&quot;&gt;</programlisting>
      <para>Where did all these attributes come from? Since we didn't assign an id, the framework
        generated one for us and outputted as the element id. Next, the propertyName given for the
        input field was used as the name attribute on the tag. This is important for binding the
        data which will be discussed in the section 'Data Binding'. The 'Uif-TextControl' bean that
        was used for the control property included a default size of '30', and also includes the
        style classes 'uif-control' and 'uif-textControl'. Finally, the framework set a tabindex for
        us (this happens to be the first field on the page) and added aria markup for accessibility.
        Don't worry if this all doesn't make sense now, we'll see all these properties many more
        times!</para>
      <tip>
        <title>Data and Input Fields</title>
        <para>Whenever this training manual refers to a data field, the same will also apply to
          input fields (by inheritance). However the reverse is not always true. </para>
      </tip>
    </section>
    <section>
      <title>Default Values</title>
      <para>Through configuration of the data field, we can also initialize the backing property of
        the model. The value specified will then be set as the property value when the model is
        initialized. Chapter 12 will cover how the model gets initialized along with other concerns
        of the lifecycle. In terms of default values, it is important just to know that the model
        gets created for a new request to a view (such as a request from the portal or other
        application menu) and, once created, is reused throughout the conversation (series of posts
        on the same view). Generally for initial requests we do not need to perform a lot of
        business logic. That is, usually we just want to display the view for the user to begin
        completing. Being able to set default values that will display on the initial view is
        convenient in that we don't have to override the controller method to do the same in
        code.</para>
      <para>There are three properties available on a data field that allows us to configure a
        default value. The first is the property 'defaultValue', which takes the actual value to
        use. For example, suppose we want to set a default value of '2012' for the bookYear
        property. This would be done as follows:</para>
      <programlisting>&lt;bean parent="Uif-DataField" p:propertyName="bookYear" p:defaultValue="2012"/&gt;</programlisting>
      <para>This is equivalent to code:</para>
      <programlisting>bookForm.setBookYear("2012");</programlisting>
      <para>The default value given must be convertible to the property type without a custom
                property editor. </para>
<!--TODO: Add Content Here
            <note>
                <title>Default Type Conversion</title>
                <para>Spring uses PropertyEditor classes when converting a configured value in the XML 
                    to the type for the property being populated. Furthermore, these are used when formatting 
                    the value between the user interface and a custom editor can be specified on the data field. 
                    As of Rice 2.0, any custom editor is not used to apply the default value. This 
                    is being looked at for a potential enhancement in 2.2.</para>
            </note>
            -->      <para>A very powerful feature we will be looking at later on in this training manual is
                the Spring Expression Language (EL). KRAD allows you to use expressions for most
                component properties, including the defaultValue. There are many things you can do
                with EL, but to give you a taste here are a couple:</para>
      <programlisting>&lt;bean parent="Uif-DataField" p:propertyName="bookYear" p:defaultValue="@{2010 + 2}"/&gt;</programlisting>
      <programlisting>&lt;bean parent="Uif-DataField" p:propertyName="bookYear" p:defaultValue="@{bookId &lt; 1000 ? 2011 : 2012}"/&gt;</programlisting>
      <programlisting>&lt;bean parent="Uif-DataField" p:propertyName="bookTitle" p:defaultValue="New Book for @{bookYear}"/&gt;</programlisting>
      <para>The second way to configure default values is by setting the 'defaultValues' property
        (notice the &apos;s&apos; on the end). This property provides the ability to set multiple
        default values. For example, if you wanted to default items with values of either 2 or 3 you
        could add the following.</para>
      <programlisting>&lt;property name="defaultValues" &gt;
        &lt;list&gt;
        &lt;value&gt;2&lt;/value&gt;
        &lt;value&gt;3&lt;/value&gt;
        &lt;/list&gt;
        &lt;/property&gt;
      </programlisting>
      <para>The third way to configure a default value is by setting the <emphasis role="keyword">defaultValueFinderClass</emphasis> property. This is the full class
                name for the class that implements the <emphasis role="keyword">org.kuali.rice.krad.valuefinder.ValueFinder</emphasis> interface. This
                interface is very simple with just the one method:</para>
      <programlisting>public String getValue();</programlisting>
      <para>Implementations of this can be made to determine the default value in whatever
                manner necessary. Previous to KRAD, this was helpful for retrieving the default
                value from a system parameter. However, with KRAD EL, you can do this with the
                defaultValue property using the <emphasis role="keyword">getParm</emphasis>
                function.</para>
      <para>Let's create a default value finder class that calls a service to retrieve the value.
        Our finder class would be setup like:</para>
      <programlisting>
package edu.myedu.sample;
public class BookCopyrightYearValueFinder implements ValueFinder {
  public String getValue() {
     return getBookService().getDefaultCopyrightYear();
  }

  Protected BookService getBookService() {
     ServiceLocator.getBookService();
  }
}
            </programlisting>
      <para>We would then configure the data field to use our value finder class like
                this:</para>
      <programlisting>&lt;bean parent="Uif-DataField" p:propertyName="bookYear" 
     p:defaultValueFinderClass="edu.myedu.sample.BookCopyrightYearValueFinder"/&gt;</programlisting>
      <para>One additional note that should be made regarding default values is for collection
                group fields. Data or Input fields declared in these groups behave differently from
                the standard group, in that for each collection line that exists in the model, a new
                set of fields is created. When configuring a default value (by either mechanism) for
                a collection field, the value is picked up each time a new line is created (as a
                result of an add line request). Thus it is a default value for the collection line. </para>
    </section>
    <section>
      <title>Alternate and Additional Display Properties</title>
      <para>In certain situations, it is necessary to change the display of a data or input
                field when it is read only. For example, we might want to display additional
                information along with the value of the property, or we might want to display a
                different property value. This can be accomplished using the alternate and
                additional display properties that are available on data field (and therefore input
                field through inheritance).</para>
      <para>As is the case throughout much of the UIF, there is more than one way to accomplish
        this. The first method we can use is to directly configure the alternate or additional value
        that should be displayed. This is done using the readOnlyDisplayReplacement and
        readOnlyDisplaySuffix properties respectively. For example, instead of displaying the value
        for the bookId property, we want to display the string 'Id Val':</para>
      <programlisting>&lt;bean parent="Uif-InputField" p:propertyName="bookId" p:readOnlyDisplayReplacement="Id Val"/&gt;</programlisting>
      <para>This would result in the text 'Id Val' being displayed (along with the field
        label).</para>
      <para>Now, if we decide we just want to append the 'Id Val' string the actual value of the
        bookId property, our configuration would then be:</para>
      <programlisting>&lt;bean parent="Uif-InputField" p:propertyName="bookId" p:readOnlyDisplaySuffix="Id Val"/&gt;</programlisting>
      <para>Assuming the bookId is '3', this would result in the text '3 *-* Id Val' being displayed
        as shown below.</para>
      <figure>
        <title>Data Field Label</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../images/KRAD_Guide/fixedDelimiter.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <note>
        <title>*-*</title>
        <para>Where did the *-* come from? KRAD inserts this fixed delimiter between the property
          value and the additional display value. Currently this can only be changed by modifying
          the template; however, this will be customizable in the future. </para>
      </note>
      <para>This has limited benefits by itself, but as mentioned earlier, KRAD allows us to
                use expressions to set a value. With EL we can display one or more other property
                values, perform operations and functions, and mix in static text! </para>
      <programlisting>&lt;bean parent="Uif-InputField" p:propertyName="bookId" p:readOnlyDisplaySuffix="with title @{bookTitle}"/&gt;</programlisting>
      <para>Again assuming the bookId is '3' and bookTitle is 'Dogs and Cats', this would result in
        the text '3 *-* with title Dogs and Cats' being displayed.</para>
      <para>Often, there is a need to display another property value as the alternate or additional
        display value. For example, when we have an id or code field (that generally doesn't have
        any meaning to the user), it is preferred to display the name instead of the code (or in
        addition to it). For these cases, you can simply configure the
        readOnlyDisplayReplacementPropertyName or readOnlyDisplaySuffixPropertyName properties with
        the name of the property whose value should be used:</para>
      <programlisting>&lt;bean parent="Uif-InputField" p:propertyName="bookId"&#160;p:readOnlyDisplayReplacementPropertyName="bookTitle"/&gt;</programlisting>
      <para>Assuming bookTitle is 'Dogs and Cats', this would result in the text 'Dogs and
        Cats'.</para>
      <programlisting>&lt;bean parent="Uif-InputField" p:propertyName="bookId"&#160;p:readOnlyDisplaySuffixPropertyName ="bookTitle"/&gt;</programlisting>
      <para>Assuming bookId is '3' and bookTitle is 'Dogs and Cats', this would result in the text
        '3 *-* Dogs and Cats'.</para>
      <tip>
        <title>Alternate/Additional Display and Input Field</title>
        <para>The alternate and additional display values are only used when the field is read-only.
          But an input field allows the user to edit the value, so does it make sense to configure
          these properties for an input field? The answer is yes! An input field has a readOnly
          property (inherited form ComponentBase) which dictates whether the control is rendered. If
          there are conditions which set this property to true, then the control will not render and
          the value will be displayed as text.</para>
      </tip>
    </section>
    <section>
      <title>Additional Display Properties for List&lt;String> fields</title>
      <para>When a field is of type List&lt;String> and the readOnly property is set to true, there
        are a few more options that you can take advantage of to change how this data is displayed.
        By default this values will be output in a comma and space (", ") separated list, but this
        can be changed with the <emphasis role="keyword">readOnlyListDisplayType</emphasis> property of
        DataField (and child type InputField).  The following options are allowed:<itemizedlist>
          <listitem>
            <para>"DELIMITED" - list will be output with delimiters between each item defined
                by<emphasis role="keyword"> readOnlyListDelimiter</emphasis> (which can be any text or
              html you would like)</para>
          </listitem>
          <listitem>
            <para>"BREAK" - list will be output with breaks between each item</para>
          </listitem>
          <listitem>
            <para>"OL" - list will be output in ordered list format (numbered)</para>
          </listitem>
          <listitem>
            <para>"UL" - list will be output in unordered list format (bulleted)</para>
          </listitem>
        </itemizedlist></para>
      <para>The following would put a dash with spaces between each item of the
        list:<programlisting>&lt;bean parent="Uif-InputField-LabelTop" p:propertyName="field120" p:label="Alternate Delimiter"
              p:instructionalText="CheckboxGroupControl using an optionsFinder" p:width="auto"
              p:readOnlyListDisplayType="DELIMITED" p:readOnlyListDelimiter=" - ">
...</programlisting>The
        result would be something like this "Value1 - Value2 - Value3"<tip>
          <title>Empty list alternate readOnly display</title>
          <para>If your List&lt;String> field is empty, the DataField will simply display nothing as
            a the value for the list.  Inorder to display something instead, indicating that the
            list is empty, you can use a SpringEL expression with the <emphasis role="keyword"
              >readOnlyDisplayReplacement</emphasis> property as
            follows:<programlisting>p:readOnlyDisplayReplacement="@{#emptyList(field115)?'No Options Selected':''}</programlisting>This
            would display 'No Options Selected'  when the list is empty.  </para>
          <para>Note the OR; this means that the <emphasis role="keyword"
              >readOnlyDisplayReplacement</emphasis> property is blank when the list is not empty.
            This is required because we want the list to display with the options we may have set in
              <emphasis role="keyword">readOnlyListDisplayType</emphasis> instead of an alternate
            replacement for when the list does contain values.  The readOnlyListDisplayType logic
            performs a check make sure that readOnlyDisplayReplacement is null or blank before
            processing - if it was set that content would be used instead!</para>
        </tip></para>
    </section>
    <section role="NotInToc">
      <title>Recap</title>
      <para>
                <itemizedlist>
          <listitem>
            <para>The Data Field and Input Field components are used to perform data
                            IO</para>
          </listitem>
          <listitem>
            <para>These components are used within an HTML form, corresponding to the
                            KRAD form view component</para>
          </listitem>
          <listitem>
            <para>Data and input fields are associated with a property on the model
                            object (object providing the data)</para>
          </listitem>
          <listitem>
            <para>A data field is used to give a read-only display of a property
                            value</para>
          </listitem>
          <listitem>
            <para>A data field is created with a bean whose parent is 'Uif-DataField'</para>
          </listitem>
          <listitem>
            <para>The model property associated with the data field is specified using
                            the <emphasis role="keyword">propertyName</emphasis> property</para>
          </listitem>
          <listitem>
            <para>The property name can refer to a property on a nested object using the
                            dot notation</para>
          </listitem>
          <listitem>
            <para>An input field adds edit capability for a property's value</para>
          </listitem>
          <listitem>
            <para>A input field is created with a bean whose parent is 'Uif-InputField'</para>
          </listitem>
          <listitem>
            <para>The input field contains a control element component which is used to set the
              property value (for example, a text control)</para>
          </listitem>
          <listitem>
            <para>We can set a default value with the <emphasis role="keyword">defaultValue</emphasis> property. A static value can be given or an
                            expression which uses data from the model or a provided variable</para>
          </listitem>
          <listitem>
            <para>Default values can also be set by creating a class that implements the
                                <emphasis role="keyword">ValueFinder</emphasis> interface</para>
          </listitem>
          <listitem>
            <para>The value finder class is configured for use with the field using the
                                <emphasis role="keyword">defaultValueFinderClass</emphasis>
                            property</para>
          </listitem>
          <listitem>
            <para>Default values for fields with a collection group are used to
                            initialize properties on new lines for the collection (after the add
                            action has been taken)</para>
          </listitem>
          <listitem>
            <para>In some cases when the state is read-only we might need to display the value for
              another property instead of the field's property, or display the value in addition to
              it. This is done by using the <emphasis role="keyword">readOnlyDisplayReplacementPropertyName</emphasis> and <emphasis role="keyword">readOnlyDisplaySuffixPropertyName</emphasis>
                            properties</para>
          </listitem>
        </itemizedlist>
            </para>
    </section>
  </section>
  <section xml:id="data_binding">
    <title xml:id="data_binding.title">Data Binding </title>
    <para>The purpose for our data and input fields is to perform IO between the user interface
            and our application model (or domain objects). The population of data between these two
            layers is known as the data binding process. </para>
    <para>The binding process is mostly handled for us with the use of the Spring MVC framework (in
      previous versions on Rice with the KNS this was handled by the Struts framework). In the
      majority of cases, all we need to do is correctly point to our property in the model. Sounds
      easy, right? In cases such as our BookForm example, it is. However, model objects (also called
      form objects) can contain nested data objects that go down several levels and include
      collection structures such as List and Map. In order to correctly push and pull the value,
      Spring needs to know the full 'path' of the property relative to the model.</para>
    <para>To understand this better, let's take a look at how Spring performs the binding process.
      First, let's take the outgoing direction (data from model outputted to the page). We know from
      the previous sections we must specify a propertyName for the data and input fields. In the
      case of the input field, an input HTML element will be generated within the input field
      template. However, this is not generated directly but instead uses a helper tag provided by
      the Spring framework:</para>
    <programlisting>&lt;@spring.input id=&quot;${control.id}&quot; path=&quot;${field.bindingInfo.bindingPath}&quot; ... &gt;</programlisting>
    <para>Notice the path attribute (disregard the value for now). This is an attribute of the
      Spring input macro that specifies the path to the property that this input should be
      associated with. Spring will do two things with this information. First, it will retrieve the
      value for that property from the model and set it as the value attribute for the input macro.
      Next, it will use the path given as the value for the name attribute (if you are wondering,
      the id attribute just gets passed through to the id attribute for the HTML tag). Assuming we
      had a property path of 'bookId' with value '3', the resulting HTML input would be as
      follows:</para>
    <programlisting>&lt;input id="u3" name="bookId" value="3" ... &gt;</programlisting>
    <para>The value of '3' will then appear inside the rendered text box. All other controls types
      work in a similar manner.</para>
    <para>In the case of a data field, or when the input field is read only, the Spring bind macro
      is used. This tells Spring to pull the value for the given property and stick the value into a
      FreeMarker variable (page or request scope). We can then write out that value to a stream
      which results in the static text being displayed.</para>
    <programlisting>
&lt;@spring.bind path=&quot;${field.bindingInfo.bindingPath}&quot;&gt;${status.value}&lt;/@spring.bind&gt;${status.value}    
        </programlisting>
    <para>Now let's look at the incoming direction. This is data contained in the HTML form (with
      the controls) that we wish to populate onto the model. Recall that when we used the Spring
      tag, our property path was used for the name attribute value. When the page is submitted, the
      browser will use the name attribute as the corresponding name of the request parameter. The
      request parameter value will then be the value that was set on the control. </para>
    <para>On the server, Spring will then iterate through the request parameter map, and attempt to
      find a property on the model that matches the request parameter key. If a match is made, the
      corresponding request parameter value is set as the value of the property. That's it! Our
      binding is complete. Therefore, as long as we have configured the property name to match a
      property on our model (nested or not), Spring will take care of the rest.</para>
    <section>
      <title>Property Editors</title>
      <para>When binding the data between the JSP page and the model, Spring will again invoke
                registered Property Editors to perform the necessary type conversion. All values
                within the interface are treated as Strings. When going from or to a property type,
                other than the primitive types or String type, a property editor must be
                used.</para>
      <para>Spring provides out-of-the-box property editors for common Java types that are
                registered by default (registration is the process of configuring the Spring
                container to use a property editor). Also, some optional property editor
                implementations are provided that can be used. These include:
                ByteArrayPropertyEditor, ClassEditor, CustomBooleanEditor, CustomCollectionEditor,
                CustomDateEditor, CustomNumberEditor, FileEditor, InputStreamEditor, LocaleEditor,
                PatternEditor, PropertiesEditor, StringTrimmerEditor, and URLEditor.</para>
      <para>In addition to the provided Spring property editors, KRAD provides a set that can
                be used with the custom Kuali types (such as KualiDecimal and KualiInteger) and
                other common formatting practices. These include:</para>
      <para><emphasis role="keyword">UifBooleanEditor</emphasis> – Formats any of the strings
        &quot;/true/yes/y/on/1/&quot; to the Boolean true, and any of the strings
        &quot;/false/no/n/off/0/&quot; to Boolean false. Conversely, the Boolean true is formatted
        as the string "yes" and the Boolean false is formatted as the string "no". </para>
      <para><emphasis role="keyword">UifCurrencyEditor</emphasis> – Used for converting between a
        KualiDecimal and a string. The string is formatted using commas and to two decimal
        places.</para>
      <para><emphasis role="keyword">UifDateEditor</emphasis> – Used for converting between a
        java.util.Date and a string. The Rice <emphasis role="keyword">DateTimeService</emphasis> is used to perform the string formatting and for
                parsing the string to create a date object.</para>
      <para><emphasis role="keyword">UifKualiIntegerEditor</emphasis> – Used for converting between a
        KualiInteger and a string. The string is formatted using commas and to zero decimal
        places.</para>
      <para><emphasis role="keyword">UifPercentageEditor</emphasis> – Used for converting between
                a KualiPercent and a string. Formatting is similar to UifCurrencyEditor.</para>
      <para><emphasis role="keyword">UifTimestampEditor</emphasis> – Used for converting between
                a java.sql.Timestamp and a string. The Rice DateTimeService is used to perform the
                string formatting and Timestamp creation.</para>
      <para>These property editors, along with Spring editors, are registered with Spring by
                property type. This means whenever Spring encounters the associated type for the
                property being bound to, it will use the registered property editor. For example,
                the UifCurrencyEditor is registered with the KualiDecimal type. Thus, when binding
                to a property with type KualiDecimal, the UifCurrencyEditor will be used. </para>
      <para>If needed, KRAD allows you to also specify a property editor to use for a data field. 
                This might be needed to support a custom data type or to perform custom formatting 
                (formatting refers to the process of rendering a String from an object). To create a 
                new property editor, a class must be created that implements the PropertyEditor interface. 
                The easiest way to do this is to extend the Spring provided class 
                java.beans.PropertyEditorSupport, and then override the getAsText() and setAsText(String 
                text) methods.</para>
      <programlisting>
package edu.sampleu.demo.kitchensink;
public class UITestPropertyEditor extends PropertyEditorSupport implements Serializable {
    private static final long serialVersionUID = -4113846709722954737L;

    /**
     * @see java.beans.PropertyEditorSupport#getAsText()
     */
    @Override
    public String getAsText() {
        Object obj = this.getValue();

        if (obj == null) {
            return null;
        }

        String displayValue = obj.toString();
        if (displayValue.length() &gt; 3) {
            displayValue = StringUtils.substring(displayValue, 0, 3) + &quot;-&quot; + StringUtils.substring(displayValue, 3);
        }

        return displayValue;
    }

    /**
     * @see java.beans.PropertyEditorSupport#setAsText(java.lang.String)
     */
    @Override
    public void setAsText(String text) {
        String value = text;
        if (StringUtils.contains(value, &quot;-&quot;)) {
            value = StringUtils.replaceOnce(value, &quot;-&quot;, &quot;&quot;);
        }

        this.setValue(value);
    }
}
            </programlisting>
      <para>The two methods implemented here correspond to the two directions: outgoing to the page (to string), 
                and incoming to the model (to object). The getAsText() method is invoked to build the string that 
                should be displayed. We can use the getValue() method provided by the base class to get current object, 
                then build the string and return. The setAsText(String text) method is used to build the object from 
                the String. After we have constructed the object, we can call the setValue method to set the object 
                that will be used for the model property value.</para>
      <para>Once we have the property editor class created, we can configure it to be used
                with our data field by specifying the full class name in the propertyEditor
                property:</para>
      <programlisting>&lt;bean parent="Uif-DataField" p:propertyName="bookId"&#160;p:propertyEditor="edu.sampleu.demo.kitchensink.UITestPropertyEditor"/&gt;</programlisting>
      <para>Likewise the property editor can be specified for an input field:</para>
      <programlisting>&lt;bean parent="Uif-InputField" p:propertyName="bookId"&#160;p:propertyEditor="edu.sampleu.demo.kitchensink.UITestPropertyEditor"/&gt;</programlisting>
    </section>
    <section>
      <title>Complex Paths</title>
      <para>So far, we have used examples where the property was either directly on the model (form)
        object, or one level down. Now let's look at more complex paths for binding that include
        many levels of nesting and collection properties. </para>
      <para>Let's assume we have the following objects:</para>
      <programlisting>
public class TestForm {
  private String field1;
  private Test1Object test1Object;
}

public class Test1Object {
  private String t1Field;
  private Test2Object test2Object;
  private List&lt;Test2Object&gt; test2List;
}

public class Test2Object {
  private String t2Field;
  private Map&lt;String, String&gt; t2Map;
}
                
            </programlisting>
      <para>Some example paths for these properties would be:</para>
      <programlisting>Field1 on TestForm – "field1"</programlisting>
      <para>Each time we go into a nested object, we use a dot:</para>
      <programlisting>T1Field on Test1Object = "test1Object.t1Field" </programlisting>
      <programlisting>T2Field on Test2Object – "test1Object.test2Object.t2Field"</programlisting>
      <para> The path for a collection field must specify the item index using the brackets [] and the index within the
        brackets:</para>
      <programlisting>T2Field on Test1List – "test1Object.test2List[0].t2Field",
        "test1Object.test2List[1].t2Field", "test1Object.test2List[2].t2Field", … </programlisting>
      <para> For binding to a map we again use the brackets with the map key within the brackets and
        quoted:</para>
      <programlisting>T2Map on Test2Object – "test1Object.test2Object.t2Map['key1']",
        "test1Object.test2Object.t2Map['key2']" </programlisting>
      <para>We can continue forming paths for objects that are nested at deeper levels by adding
        additional dots to the path. In this way, we can form the path and set the propertyName
        value for any model property:</para>
      <programlisting>&lt;bean parent="Uif-DataField"
        p:propertyName="test1Object.test2Object.t2Field"&gt;</programlisting>
      <para>Now suppose Test2Object had a large set of fields we wanted to display. We could
        configure all of them just as in the previous example:</para>
      <programlisting>&lt;bean parent="Uif-DataField" p:propertyName="test1Object.test2Object.t2Field1"&gt;</programlisting>
      <programlisting>&lt;bean parent="Uif-DataField" p:propertyName="test1Object.test2Object.t2Field2"&gt;</programlisting>
      <programlisting>&lt;bean parent="Uif-DataField" p:propertyName="test1Object.test2Object.t2Field3"&gt;</programlisting>
      <para>This is, however, very tedious and repetitive. Luckily, the UIF provides a class
                named <emphasis role="keyword">BindingInfo</emphasis> for which a property exists on a data field.
        This class separates the path into three parts. The first is called the binding object path.
        This is the path to a data object on the model. The second is called the binding prefix, and
        the third part is the binding name.</para>
      <para>The binding name is usually the same as the given property name, and will be synced if
        not set. The binding prefix is then a prefix to add before the binding name (property name).
        Finally, the full path is formed by joining the prefix and name to the object path. This is
        known as the binding path and is invoked by the templates to set the Spring path attribute.
        Please note the binding prefix is optional and not always beneficial to use.</para>
      <para>Let's breakdown the path "test1Object.test2Object.t2Field1" from the previous example. A
        good candidate for the object path is "test1Object.test2Object". That just leaves "t2Field1"
        so there is not really a need for a binding prefix. Therefore, our configuration would
        be:</para>
      <para>&lt;bean parent="Uif-DataField"
        p:bindingInfo.bindingObjectPath="test1Object.test2Object"
        p:propertyName="t2Field1"&gt;</para>
      <para>We could also configure out data field as follows:</para>
      <para>&lt;bean parent="Uif-DataField" p:bindingInfo.bindingObjectPath="test1Object"
        p:bindingInfo.bindByNamePrefix="test2Object" p:propertyName="t2Field1"&gt;</para>
      <para>You might be wondering what the KRAD designers were thinking at this point. This doesn't
        seem to remove the repetition, and in fact, it is much more verbose! On an individual field
        level, that is true. The benefit is that we can put multiple fields which share similar
        paths together into a group. </para>
      <para>We will learn all about the Group component in the next chapter, but two
                properties that exist are fieldBindByNamePrefix and fieldBindingObjectPath. When one
                or both of these properties are configured on the group, the value will be taken and
                set on corresponding binding info property for each group field.</para>
      <para>For example:</para>
      <programlisting>
&lt;bean parent="Uif-VerticalBoxGroup" p:fieldBindingObjectPath="test1Object.test2Object"&gt;
    &lt;property name="items"&gt;
        &lt;list&gt;
            &lt;bean parent="Uif-DataField" p:propertyName="t2Field1"&gt;
            &lt;bean parent="Uif-DataField" p:propertyName="t2Field2"&gt;
            &lt;bean parent="Uif-DataField" p:propertyName="t2Field3"&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>
      <para>This will result in "test1Object.test2Object" being set as the
        bindingInfo.bindingObjectPath for each of the three contained fields. Now that's
        better!</para>
      <para> But KRAD goes one step further! We can also specify a default object binding path for
        the entire view. This is done by setting the defaultBindingObjectPath property on the View
        component. This will set the binding object path for all fields (and collection groups) if
        it not already set (we can override if necessary). This is very useful in particular for the
        various view types provided. One example is the MaintenanceView. This view targets the
        maintenance of a data object instance. This data object instance is found in the model with
        path 'document.newMaintainableObject.dataObect'. Since typically all these views do are
        present all data for a particular record to be edited, we just need to specify the
        properties of the data object we want to present. The maintenance view makes this easy for
        us by setting "document.newMaintainableObject.dataObject" as the defaultBindingObjectPath.
        Therefore, when specifying the view fields, we just need to specify the property name
        relative to the data object: </para>
      <programlisting>
&lt;bean parent=&quot;Uif-InputField&quot; p:propertyName=&quot;number&quot;/&gt;
&lt;bean parent=&quot;Uif-InputField&quot; p:propertyName=&quot;name&quot;/&gt;
...</programlisting>
      <para>Which would result in binding paths:</para>
      <programlisting>
'document.newMaintainableObject.dataObect.number' 
'document.newMaintainableObject.dataObect.name'
            </programlisting>
      <tip>
        <title>Bean Reuse</title>
        <para>Separating out the object path or binding prefix also allows for more reuse. For
          example, when extending a group bean, it is a simple property change to modify the binding
          object path or prefix. However, if the object path and prefix is embedded on the property
          name for each field in the group, the child bean would need to override the entire items
          list and duplicate all the field information.</para>
      </tip>
      <para>The data and input field components implement the interface <emphasis role="keyword">org.kuali.rice.krad.uif.component.DataBinding</emphasis>. This indicates to the framework
        that the component binds to the model, and provides the binding info and property name
        properties. The other component that implements this interface is the CollectionGroup. A
        collection group is a group that iterates over a model collection and presents fields for
        each line. Therefore, when configuring a collection group, we must point it to the property
        that holds the collection. This is done exactly the same as for data fields, using the
        propertyName property and the bindingInfo property. For example:</para>
      <programlisting>&lt;bean parent="Uif-TableCollectionGroup" p:propertyName="mycollection" ... &gt;</programlisting>
      <para>One thing to note is how the binding path for the fields within the collection group is
        formed. These fields will automatically receive a binding prefix that is the path for the
        collection line. This path includes the collection path plus the line index:
        "mycollection[0]", "mycollection[1]". Therefore the fields specified within the collection
        are relative to the line (data object for the collection). This would be the same as setting
        the fieldBindByNamePrefix property on a standard group component.</para>
      <para>Finally, there are a couple other properties on the binding info class that are helpful
        to know about. The first of these is the bindToMap property. This is necessary when our
        property name (or binding name) is actually a Map key. Recall in these cases that we need to
        use the special bracket notation. When this property is true, the binding path will be
        formed using the object path, binding prefix, then the brackets with the binding name in
        quotes.</para>
      <programlisting>
&lt;bean parent="Uif-DataField" p:bindingInfo.bindingObjectPath="test1Object.test2Object" p:bindingInfo.bindByNamePrefix="t2Map" p:bindingInfo.bindToMap="true" p:propertyName="key1"&gt;</programlisting>
      <para>This would result in the following binding path:</para>
      <para>"test1Object.test2Object.t2Map['key1']"</para>
      <para>Another useful property on binding info is the <emphasis role="keyword">bindToForm</emphasis> property. This is essentially an indicator to not add on any
        binding object path (either from the view or a group). The binding prefix is still added, if
        specified.</para>
      <para>For example:</para>
      <programlisting>
&lt;bean parent="Uif-VerticalBoxGroup" p:fieldBindingObjectPath="test1Object.test2Object"&gt;
    &lt;property name="items"&gt;
        &lt;list&gt;
            &lt;bean parent="Uif-DataField" p:propertyName="t2Field1"&gt;
            &lt;bean parent="Uif-DataField" p:propertyName="field1" p:bindingInfo.bindToForm="true"&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>
      <para>The binding path for the first data field would be "test1Object.test2Object.t2Field1",
        but the binding path for the second data field will only be "field1", due to the bindToForm
        property being set to true.</para>
    </section>
    <section role="NotInToc">
      <title>Recap</title>
      <para>
                <itemizedlist>
          <listitem>
            <para>The process of populating the model from an HTTP request and
                            outputting values to the response from the model is referred to as data
                            binding</para>
          </listitem>
          <listitem>
            <para>The Spring MVC framework performs the binding process </para>
          </listitem>
          <listitem>
            <para>For the incoming direction (request to model), Spring looks for
                            request parameters that match a property name on the model (starting
                            from the top object and using dot notation for nested objects)</para>
          </listitem>
          <listitem>
            <para>For the outgoing direction (model to response), we use the provided Spring JSP
              tags, and specify the path attribute to the property whose value should be
              outputted</para>
          </listitem>
          <listitem>
            <para>The Spring tags in KRAD have the namespaces 's' and 'form'</para>
          </listitem>
          <listitem>
            <para>When a conversion between data types is needed (for example String to
                            Date), Spring uses a <emphasis role="keyword">PropertyEditor</emphasis>. Spring comes with
              default property editors for basic Java types and additional editors that can be used
              as needed. In addition KRAD provides property editors which include:</para>
            <itemizedlist>
              <listitem>
                <para>UifBooleanEditor</para>
              </listitem>
              <listitem>
                <para>UifCurrencyEditor</para>
              </listitem>
              <listitem>
                <para>UifDateEditor</para>
              </listitem>
              <listitem>
                <para>UifKualiIntegerEditor</para>
              </listitem>
              <listitem>
                <para>UifPercentageEditor</para>
              </listitem>
              <listitem>
                <para>UifTimestampEditor</para>
              </listitem>
            </itemizedlist>
          </listitem>
          <listitem>
            <para>Using the data field propertyEditor property, custom editors can be associated
              with a property for binding (this includes using one of the provided editors, or
              creating a custom editor)</para>
          </listitem>
          <listitem>
            <para>Complex property paths are created in the following manner:</para>
            <itemizedlist>
              <listitem>
                <para>Each time a nested object is encountered in the path, it is separated by a dot
                  (eg 'nestedObject.nestedObject2.property')</para>
              </listitem>
              <listitem>
                <para>A property on a List type is specified using the collection path, then the
                  line index inside brackets (eg 'collectionPath[index].property')</para>
              </listitem>
              <listitem>
                <para>A Map property is specified using the map path, then the map key in quotes and
                  inside a bracket (eg 'mapPath['key'].property')</para>
              </listitem>
            </itemizedlist>
          </listitem>
          <listitem>
            <para>When configuring multiple fields that belong to the same nested object (or list or
              map), it can be tedious to specify the full path each time. To help with this, KRAD
              provides the BindingInfo object. This can be used to set the following
              properties:</para>
            <itemizedlist>
              <listitem>
                <para>bindingObjectPath – Path to the parent data object</para>
              </listitem>
              <listitem>
                <para>bindByNamePrefix – Prefix to add after the object path and
                                        before the binding name (property name)</para>
              </listitem>
            </itemizedlist>
          </listitem>
          <listitem>
            <para>Since specifying the bindingObjectPath for each field does not really
                            help with the verbosity, the <emphasis role="keyword">fieldBindingObjectPath</emphasis> on the
              parent Group can be used instead. Likewise, the group component contains the <emphasis role="keyword">fieldBindByNamePrefix</emphasis> property</para>
          </listitem>
          <listitem>
            <para>We can set a default object path for the entire view using the view
                            component property <emphasis role="keyword">defaultBindingObjectPath</emphasis></para>
          </listitem>
          <listitem>
            <para>Separating the property name into an object path helps with the reusability of
              bean configuration</para>
          </listitem>
          <listitem>
            <para> The BindingInfo object also contains the property <emphasis role="keyword">bindToMap</emphasis> which is used to indicate the property is a map key (which
              impacts how the final binding path is formed). In addition, we can set the property
              bindToForm to true which means we do not want any binding object path (coming from the
              group or the view) to be prepended</para>
          </listitem>
        </itemizedlist>
            </para>
    </section>
  </section>
  <section>
    <title>Data Dictionary Backing </title>
    <para>In Chapter 4, we learned about the data dictionary and attribute definition entries.
            We learned that we could define a label, control, and certain other properties in the
            attribute definition that will drive the rendering of that attribute wherever it appears
            in the UI. So how does this work with the data fields?</para>
    <para>First, as we have seen, we can configure everything we need directly on the data
            fields; therefore, the UIF does not require the data dictionary to be used. However, the
            UIF does have a process for determining and using an attribute definition for backing a
            data or input field. What this means is if an attribute definition is found, the
            properties specified on the definition will be used as defaults for the data field. If
            the same property is specified on the data field, it will override the value from the
            attribute definition.</para>
    <para>For example, suppose we have the following data object entry and attribute
            definition:</para>
    <programlisting>            
&lt;bean id=&quot;TravelAccount&quot; parent=&quot;DataObjectEntry&quot;&gt;
    &lt;property name=&quot;dataObjectClass&quot; value=&quot;org.kuali.rice.krad.demo.travel.account.TravelAccount&quot;/&gt;
        &lt;property name=&quot;attributes&quot;&gt;
            &lt;list&gt;
                &lt;ref bean=&quot;TravelAccount-number&quot;/&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

&lt;bean id=&quot;TravelAccount-number&quot; parent=&quot;AttributeDefinition&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;number&quot;/&gt;
    &lt;property name=&quot;label&quot; value=&quot;Travel Account Number&quot;/&gt;
    &lt;property name=&quot;shortLabel&quot; value=&quot;Travel Account Number&quot;/&gt;
    &lt;property name=&quot;forceUppercase&quot; value=&quot;false&quot;/&gt;
    &lt;property name=&quot;maxLength&quot; value=&quot;10&quot;/&gt;
    &lt;property name=&quot;constraintText&quot; value=&quot;Must be 10 digits&quot;/&gt;
    &lt;property name=&quot;validationPattern&quot;&gt;
        &lt;bean parent=&quot;AnyCharacterValidationPattern&quot;/&gt;
    &lt;/property&gt;
    &lt;property name=&quot;controlField&quot;&gt;
        &lt;bean parent=&quot;Uif-TextControl&quot; p:size=&quot;10&quot;/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</programlisting>
    <para>And we have the following input field which the previous attribute definition is
            backing:</para>
    <programlisting>&lt;bean parent="Uif-InputField" p:propertyName="number" p:label="New Travel Account Number" 
 p:forceUppercase="true"/&gt;</programlisting>
    <para>During the view lifecycle initialize phase, the properties from the attribute definition
      are picked up and set onto the input field (if not set). Note that the names do not always
      match exactly (for example the control property of input field is fed from the controlField
      property of attribute definition). The above example would result in an input field with the
      following state:</para>
    <itemizedlist>
      <listitem>
        <para>Label: "New Travel Account Number" (from the input field config)</para>
      </listitem>
      <listitem>
        <para>Short Label: "Travel Account Number" (from the attr def config)</para>
      </listitem>
      <listitem>
        <para>Force Uppercase: true (from the input field config)</para>
      </listitem>
      <listitem>
        <para>Max Length: 10 (from the attr def config)</para>
      </listitem>
      <listitem>
        <para>Constraint Text: "Must be 10 digits" (from the attr def config)</para>
      </listitem>
      <listitem>
        <para>Validation Pattern: Any Character Validation (from the attr def config)</para>
      </listitem>
      <listitem>
        <para>Control: Text control with size 10 (from the attr def config)</para>
      </listitem>
    </itemizedlist>
    <para>An attribute definition can be linked manually through the data field configuration,
            or the framework will attempt to find one based on the field binding path.</para>
    <para>For manual configuration, we use the <emphasis role="keyword">dictionaryObjectEntry</emphasis> and <emphasis role="keyword">dictionaryAttributeName</emphasis> properties. The dictionary object entry is the name of
      the entry in the data dictionary for which the attribute definition belongs. This is generally
      the full class name of a data object. The dictionary attribute name is then the value for the
      name attribute of the definition we want to pick up. For our previous example this
      configuration would be as follows:</para>
    <programlisting>&lt;bean parent="Uif-InputField" p:propertyName="number" 
 p:dictionaryObjectEntry="edu.sampleu.travel.bo.TravelAccount" p:dictionaryAttributeName="number"/&gt; </programlisting>
    <para>We can also leave off the dictionaryAttributeName, in which case the framework will
            default it to the given propertyName:</para>
    <programlisting>&lt;bean parent="Uif-InputField" p:propertyName="number" 
 p:dictionaryObjectEntry="edu.sampleu.travel.bo.TravelAccount"/&gt;</programlisting>
    <para>If the dictionary properties are not set, the UIF will attempt to find an attribute
            definition with the binding path. This works as follows:</para>
    <orderedlist>
      <listitem>
        <para>The UIF takes the model class as the dictionary object entry (form class which is given on the view) and the binding path as the dictionary attribute name. Is there an entry? If so, the UIF will use it. Else it goes to step 2.</para>
      </listitem>
      <listitem>
        <para>Is the binding path nested (contains the dot separator)? If so, the UIF uses the name
          before the first dot to get the corresponding object from the form by name. This will be
          the dictionary object entry. The UIF uses the part after the first dot as the dictionary
          attribute name. Is there an entry? If so, the UIF will use it. If the path contains
          additional nesting, the UIF repeats this step (step 2).</para>
      </listitem>
    </orderedlist>
    <para>As an example let's take the following model:</para>
    <programlisting>
package edu.myedu.sample;
public class TravelForm {
  private TravelAccount travelAccount;
}

package edu.myedu.sample;
public class TravelAccount {
  private String number;
}
        </programlisting>
    <para>Now suppose we have the following input field:</para>
    <programlisting>&lt;bean parent="Uif-InputField" p:propertyName="travelAccount.number"/&gt;</programlisting>
    <para>The UIF will first ask the data dictionary if it has an entry for
      'edu.myedu.sample.TravelForm' and attribute 'travelAccount.number', if so that attribute
      definition will be used to populate the input field. If not, it will then get the property
      type for 'travelAccount' from TravelForm. This is of type edu.myedu.sample.TravelAccount.
      Therefore, it will ask the data dictionary if it has an entry for
      'edu'myedu.sample.TravelAccount' and attribute 'number', and if so that attribute definition
      will be used. The process continues until an attribute definition is found or the binding path
      is no longer nested.</para>
    <para>The one exception to the above rule is for fields in collection groups. Since the
            assumption is these are properties on the data object for the collection lines, the
            framework begins by asking for entries for that data object class and the property name
            of the field.</para>
    <programlisting>
&lt;bean parent="Uif-TableCollectionGroup" p:propertyName="testObject1.mycollection" p:collectionObjectClass="edu.myedu.sample.Test3Object"&gt;
    &lt;property name="items"&gt;
        &lt;list&gt;
            &lt;bean parent="Uif-InputField" p:propertyName="field1"/&gt;
                ...
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
        </programlisting>
    <para>The binding path for our field here will be 'testObject1.mycollection[index].field1'. In
      this case, the framework asks the data dictionary for a definition with entry
      'edu.myedu.sample.Test3Object' and attribute name 'field1'. If the field propertyName is
      nested (or has a bindingInfo.bindByNamePrefix specified), and an entry was not found for the
      full name, the framework will recurse down the path as it does for non-collection
      fields.</para>
    <section role="NotInToc">
      <title>Recap</title>
      <para>
                <itemizedlist>
          <listitem>
            <para>We can default the properties for a data or input field from a data
                            dictionary AttributeDefinition</para>
          </listitem>
          <listitem>
            <para> If an AttributeDefinition is used for a data field, the corresponding properties
              from the definition are used if a value for that property has not been specified for
              the field (in other words, we can override any value on the attribute definition) </para>
          </listitem>
          <listitem>
            <para>We can explicitly associate an attribute definition with a data field
                            using the properties <emphasis role="keyword">dictionaryObjectName</emphasis> and <emphasis role="keyword">dictionaryAttributeName</emphasis></para>
          </listitem>
          <listitem>
            <para>The dictionary object name gives the name of the data object entry in
                            the data dictionary</para>
          </listitem>
          <listitem>
            <para>The dictionary attribute name is the name of the property (the attribute
              definition 'name') associated with the attribute definition. If not given but the
              dictionary object name is, the propertyName configured on the data field will be
              used</para>
          </listitem>
          <listitem>
            <para>For fields configured on collection groups, the dictionaryObjectName
                            is automatically set to the collectionObjectClass configured on the
                            group</para>
          </listitem>
          <listitem>
            <para>If an attribute definition is not explicitly defined, the framework
                            will attempt to discover an attribute definition to use. This process
                            involves performing substrings on the binding path (starting from the
                            object path and substringing on the dot) and making a series of calls to
                            determine if an attribute definition exists for a given object entry and
                            attribute name. This continues until a definition is found or until all
                            substrings of the binding path have been tried</para>
          </listitem>
        </itemizedlist>
            </para>
    </section>
  </section>
  <section>
    <title>Types of Controls </title>
    <para>A very important type of content element is the control. Control components are used
            with an HTML Form to allow the user to interact with the data. The control holds one or
            more data values. These values are first initialized when the page renders (known as the
            initial value) and then can be changed by the user or script (known as the current
            value). When the form is submitted, the controls have their name attribute paired with
            their current value to form a request parameter that is sent to the server.</para>
    <para>Controls are wrapped with the input field component. As described in the beginning of this
      chapter, the input field holds the pointer to the model property whose value will be used as
      the initial value of the control. The input field also contains other configurations related
      to the control and its value, such as helper widgets and validation constraints.</para>
    <para>HTML controls have different types. Some of these types are represented by different tag
      elements (such as textarea and select), while variations of the input control are indicated
      with the type attribute (technically these might all be considered input controls, but KRAD
      treats each type as a different control). In this section, we will learn about the different
      types of controls and their UIF component representation.</para>
    <section>
      <title>Checkbox</title>
      <para>The Checkbox control renders an HTML input tag with type of "checkbox". This control is
        used to toggle the state of a property between two values (usually the Booleans true and
        false). The image shows an example checkbox control.</para>
      <figure>
        <title>Checkbox Control</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../images/KRAD_Guide/checkboxControl.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>To create a new checkbox control, we create a new bean with parent of
        'Uif-CheckboxControl'. Controls cannot be set on their own; they must be defined within an
        input field using the control property:</para>
      <programlisting>
&lt;bean parent="Uif-InputField" p:propertyName="acceptIndicator" p:label="Accept?"&gt;
    &lt;property name="control"&gt;
        &lt;bean parent="Uif-CheckboxControl"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
            </programlisting>
      <para>The checkbox control has one custom property that can be set which is the value
        property. This can be used to specify a string value that will be sent to the server when
        the checkbox is checked. If not set, the default Boolean 'true' will be sent.</para>
      <tip>
        <title>Checkbox Request Parameters</title>
        <para>It is important to note that browsers only send a request parameter for checkbox
          controls if their state is checked. That is, if the checkbox is not checked, no request
          parameter will be sent. Therefore, if the value for a checkbox property was true before
          rendering the page, then the user unselects the checkbox and submits. Unless special logic
          is in place, the property will not be set to false. KRAD uses the Spring checkbox tag
          which adds a hidden input that will indicate the presence of a checkbox for each request,
          then if a corresponding checkbox parameter does not exist, Spring will set the property to
          false. However when setting the value attribute for use with a non-Boolean type, the reset
          logic must be taken care of by the developer. </para>
      </tip>
    </section>
    <section>
      <title>File</title>
      <para>The File control is used to allow the user to select a file from their file system whose
        contents will be submitted with the form. The server can then make use of the file contents,
        or simply store the file on the server (for example a note attachment).</para>
      <para>To specify that a file control should be used, a bean with parent of 'Uif-FileControl'
        should be given:</para>
      <programlisting>
&lt;bean parent="Uif-InputField" p:propertyName="fileUpload" p:label="File Upload"&gt;
    &lt;property name="control"&gt;
        &lt;bean parent="Uif-FileControl"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</programlisting>
      <para>This control supports no custom properties (just the inherited component and base
                control properties). The image below shows an example file control:</para>
      <figure>
        <title>File Control</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../images/KRAD_Guide/fileControl.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>In order to use the control, there are a couple of requirements for the backend. First,
        the backing property must be of type org.springframework.web.multipart.MultipartFile. This
        is so Spring can set all the necessary file information (name, content type, size, bytes).
        Many times, a pattern employed is to have a property on the form with this type that is used
        for holding the upload, and then in a controller method, the contents are pulled to populate
        a property with type File (or store the File object). The MultipartFile class provides a
        convenient method for doing this called transferTo(java.io.File file). </para>
      <para>The second requirement for uploading files is the HTML form encoding type
        &quot;multipart/form-data&quot;. KRAD takes care of this by setting this as the encoding
        type for all forms.</para>
      <tip>
        <title>Multipart Form</title>
        <para>Always using the multipart form encoding (even when no file uploads are present) has 
                    an impact on performance. An upcoming enhancement to KRAD will be to use this encoding 
                    only when a file upload is present (with the use of script detection).  </para>
      </tip>
    </section>
    <section>
      <title>Hidden</title>
      <para>The Hidden control is used to render an HTML input of type hidden. A hidden control is
        not visible to the user, therefore its value can only be changed by a script. These are
        often used to hold some state that is needed when the page is posted back, or to provide
        data for scripting purposes.</para>
      <para>To specify a hidden control should be used, a bean with parent of 'Uif-HiddenControl'
        should be given:</para>
      <programlisting>    
&lt;bean parent="Uif-InputField" p:propertyName="hiddenField"&gt;
    &lt;property name="control"&gt;
        &lt;bean parent="Uif-HiddenControl"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
            </programlisting>
      <tip>
        <title>Request/Session State</title>
        <para>All model data is stored with the user session and when a form is submitted, the
          request data is overlaid. This means any model properties that were not present in the
          request will remain untouched. This alleviates the need to write all state to the request
          (using hiddens) so that it is not lost. </para>
      </tip>
      <para>Using a hidden control is not the same as making the field state hidden (covered in
        Chapter 10). When the field state is hidden, all of the field contents will be rendered
        (including a control that is possibly not hidden) but not visible by default. The field
        contents can then be shown with a script once a condition is met. With the hidden control,
        the other field contents (such as label and lookup) can still be visible. One usage of the
        hidden control is to provide a field quickfinder (lookup icon) that forces the user to
        select a value from the lookup instead of allowing them to type the value. </para>
      <tip>
        <title>Min/Max Length</title>
        <para>The input field control also has properties for setting min and max length. If the
          corresponding properties on the control are not set, they will be synced with the field
          settings. It can be necessary to have a different setting for the control than the field
          due to formatting. The min and max length settings for the control are used on the client,
          which is working with the formatted value. On the server, validation is performed against
          the model property value (unformatted) and uses the field length settings. </para>
      </tip>
    </section>
    <section>
      <title>Text</title>
      <para>The Text control renders the HTML input element with type of "text". This is a
        single-line box that allows the user to type the value.</para>
      <para>To specify that a text control should be used, a bean with parent of 'Uif-TextControl'
        should be given:</para>
      <programlisting>
&lt;bean parent="Uif-InputField" p:propertyName="title" p:label="Title"&gt;
    &lt;property name="control"&gt;
        &lt;bean parent="Uif-TextControl"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
            </programlisting>
      <para>The text control supports the following properties:</para>
      <para><emphasis role="keyword">size</emphasis> – This is the display size for the control in
        number of characters.</para>
      <para><emphasis role="keyword">maxLength</emphasis> – When a value is given, this is the
                maximum number of characters in length the value can have. If set, the browser will
                stop the user from entering more characters than allowed.</para>
      <para><emphasis role="keyword">minLength</emphasis> – When a value is given, this is the minimum
        number of characters in length the value can have. Note that this is not supported by the
        HTML input tag itself, but is used by the KRAD validators to check the value client side or
        server side.</para>
      <para><emphasis role="keyword">datePicker</emphasis> – This is a nested widget component that
        renders an icon next to the text input that can be used to selected a calendar day. Like all
        components, the date picker will be rendered if its render property is set to true. This
        widget and others are covered in Chapter 8.</para>
      <para><emphasis role="keyword">watermarkText</emphasis> – Specifies text that will appear
                in the text control when the value is empty. This is used to show example inputs to
                the user and is sometimes referred to as a placeholder (HTML 5). Once the user
                begins to input a value the watermark text is cleared.</para>
      <para><emphasis role="keyword">textExpand</emphasis> – A Boolean type which indicates
                whether the text input can be expanded. When enabled, an icon is rendered next to
                the text input that allows the user to click for getting a text area input that
                allows more room for entering the value. This is useful if the maximum length for
                the field is longer than the display size.</para>
      <para>The UIF provides a handful of base beans for the text control that have various
                commonly used configuration. These are as follows:</para>
      <para><emphasis role="keyword">Uif-TextControl</emphasis> – The default text control bean
                which sets the size to 30. None of the other text control properties are set by
                default.</para>
      <para><emphasis role="keyword">Uif-SmallTextControl</emphasis> – Similar to Uif-TextControl but
        sets the size to 10 and applies an additional style class of 'uif-smallTextControl'.</para>
      <para><emphasis role="keyword">Uif-MediumTextControl </emphasis>– The same as Uif-TextControl
        except adds a style class of 'uif-mediumTextControl'.</para>
      <para><emphasis role="keyword">Uif-LargeTextControl</emphasis> – Similar to Uif-TextControl but
        sets the size to 100 and applies an additional style class of 'uif-largeTextControl'.</para>
      <para><emphasis role="keyword">Uif-CurrencyTextControl</emphasis> – Same as Uif-TextControl
        except adds a style class of 'uif-currencyControl'. This adds a right align style to the
        control useful for displaying currency.</para>
      <para><emphasis role="keyword">Uif-DateControl</emphasis> – Same as Uif-SmallTextControl with the
        data picker added and an additional style class of 'uif-dateControl'.</para>
      <para>Below are various examples of using these beans and setting other
                properties:</para>
      <programlisting>
&lt;bean parent="Uif-InputField" p:propertyName="field" p:label="Field Label"&gt;
    &lt;property name="control"&gt;
        &lt;bean parent="Uif-MediumControl" p:watermarkText="It's watermarked"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
            </programlisting>
      <figure>
        <title>Watermark Control</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../images/KRAD_Guide/watermarkControl.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <programlisting>            
&lt;bean parent="Uif-InputField" p:propertyName="field" p:label="Date 1"&gt;
    &lt;property name="control"&gt;
        &lt;bean parent="Uif-DateControl"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
            </programlisting>
      <figure>
        <title>Date Control</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../images/KRAD_Guide/dateControl.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <programlisting>            
&lt;bean parent="Uif-InputField" p:propertyName="field" p:label="Field Label"&gt;
    &lt;property name="control"&gt;
        &lt;bean parent="Uif-TextControl" p:textExpand="true"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
            </programlisting>
      <figure>
        <title>Text Expand Control</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../images/KRAD_Guide/textExpandControl.png"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
    <section>
      <title>TextArea</title>
      <para>The TextArea control is similar to the text control with the exception of
                providing multiple lines for input. This control is used for entering longer strings
                of data such as a description.</para>
      <para>To specify a text area control should be used, a bean with parent of
        'Uif-TextAreaControl' should be given:</para>
      <programlisting>
&lt;bean parent="Uif-InputField" p:propertyName="title" p:label="Title"&gt;
    &lt;property name="control"&gt;
        &lt;bean parent="Uif-TextAreaControl"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
            </programlisting>
      <para>The text area control supports the following properties:</para>
      <para><emphasis role="keyword">rows</emphasis> – Specifies the number of rows (or lines)
                the input should have. This determines the height of the control.</para>
      <para><emphasis role="keyword">cols</emphasis> – Specifies the width in characters the
                input should have.</para>
      <para><emphasis role="keyword">maxLength</emphasis> – Similar to the text control, when a value
        is given restricts the number to a certain number of characters. </para>
      <para><emphasis role="keyword">minLength</emphasis> – When a value is given, requires the
                length be greater than or equal to a certain number of characters.</para>
      <para><emphasis role="keyword">textExpand</emphasis> - A Boolean type which indicates whether the
        text area input can be expanded.</para>
      <para><emphasis role="keyword">watermarkText</emphasis> – Specifies text that will appear
                in the text area control when the value is empty.</para>
      <para>The UIF provides a handful of base beans for the text area control that have
                various commonly used configuration. These are as follows:</para>
      <para><emphasis role="keyword">Uif-TextAreaControl </emphasis>– The default text area
                control bean which sets rows to 3, and cols to 40.</para>
      <para><emphasis role="keyword">Uif-SmallTextAreaControl</emphasis> – Sets rows to 2 and cols to
        35. Adds the style class 'uif-smallTextAreaControl'. </para>
      <para><emphasis role="keyword">Uif-MediumTextAreaControl</emphasis> – Sets rows to 3 and cols to
        40. Adds the style class 'uif-mediumTextAreaControl'. </para>
      <para><emphasis role="keyword">Uif-LargeTextAreaControl</emphasis> – Sets rows to 6 and cols to
        50. Adds the style class 'uif-largeTextAreaControl'. </para>
      <para>Below shows an example text area control.</para>
      <figure>
        <title>TextArea Control</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../images/KRAD_Guide/textAreaControl.png"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
    <section>
      <title>Spinner</title>
      <para>The Spinner control is a special text control that renders up and down arrows to the
        right of the control for incrementing and decrementing the value. This is an example of a
        'decorated' control. That is, HTML does not support a Spinner control inherently, but we use
        JavaScript to provide the additional functionality. This means the rendered content will be
        the input element with type of 'text', with a script invocation to add the spinner
        functionality.</para>
      <para>Within the UIF, these script decorations are represented by a widget component.
                The widget is associated with the component it works with. In this case, we extend
                the text control component and add the spinner widget. The spinner widget will be
                covered in more detail in Chapter 8.</para>
      <para>To specify a spinner control should be used, a bean with parent of 'Uif-SpinnerControl'
        should be given:</para>
      <programlisting>
&lt;bean parent="Uif-InputField" p:propertyName="count" p:label="Spinner Control"&gt;
    &lt;property name="control"&gt;
        &lt;bean parent="Uif-SpinnerControl"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
            </programlisting>
      <para> Screen shot 13 shows the spinner control. </para>
      <figure>
        <title>Spinner Control</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../images/KRAD_Guide/spinnerControl.png"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
    <section>
      <title>Multi-Value Controls</title>
      <para>Up to this point, the controls we have seen hold a single value. Next, we will
                look at controls that can hold multiple values to choose from. Some also allow
                selecting multiple values to be submitted. These components are known as multi-value
                controls and implement the org.kuali.rice.krad.uif.control.MultiValueControl
                interface.</para>
      <section>
        <title>Options</title>
        <para>When using a multi-value control, we need to specify a list of options the control
          will present. Each option has two parts: the option key and the option value. The key
          gives the value for the field that will be submitted to the server when the option is
          chosen. The label is displayed to the user for that option. These do not necessarily have
          to be different, but it is a useful feature to display a friendlier label for the
          value.</para>
        <para>As an example, let's assume we need to render a control that presents the list of
          states as options. In our model, the property expects the state code (two letter
          abbreviation). However, to help the user we want to display the full name for each state.
          Our options would then look like the following:</para>
        <table frame="all" tabstyle="striped">
          <title>State Options Example</title>
          <tgroup cols="2">
            <colspec colname="c1" colnum="1" colwidth="1.0*"/>
            <colspec colname="c2" colnum="2" colwidth="1.0*"/>
            <thead>
              <row>
                <entry>Key</entry>
                <entry>Value</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>AL</entry>
                <entry>Alabama</entry>
              </row>
              <row>
                <entry>CO</entry>
                <entry>Colorado</entry>
              </row>
              <row>
                <entry>IN</entry>
                <entry>Indiana</entry>
              </row>
              <row>
                <entry>OH</entry>
                <entry>Ohio</entry>
              </row>
              <row>
                <entry>TX</entry>
                <entry>Texas</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <para>To represent these options, Rice provides the <emphasis role="keyword">KeyValue</emphasis> interface and the <emphasis role="keyword">ConcreteKeyValue</emphasis>
          implementation. This class provides a string property for the key and a string property
          for the value, with corresponding getters and setters. Furthermore, for configuring key
          value objects within XML, the bean with name 'Uif-KeyLabelPair' is provided (whose class
          is ConcreateKeyValue). The following demonstrates creating the above list in Spring
          XML:</para>
        <programlisting>
&lt;property name="options"&gt;
    &lt;list&gt;
        &lt;bean parent="Uif-KeyLabelPair" p:key="AL" p:value="Alabama"/&gt;
        &lt;bean parent="Uif-KeyLabelPair" p:key="CO" p:value="Colorado"/&gt;
        &lt;bean parent="Uif-KeyLabelPair" p:key="IN" p:value="Indiana"/&gt;
        &lt;bean parent="Uif-KeyLabelPair" p:key="OH" p:value="Ohio"/&gt;
        &lt;bean parent="Uif-KeyLabelPair" p:key="TX" p:value="Texas"/&gt;
&lt;/property&gt;
                </programlisting>
      </section>
      <section>
        <title>Key Value Finders</title>
        <para>Hard-coding in the options works for some simple cases (like 'Yes', 'No' type
          options), however most of the time the options need to be built up dynamically. This might
          require performing a database query to retrieve code/name pairs, or invoking a service to
          retrieve the options. For this, a small piece of code must be written that implements the
          org.kuali.rice.krad.keyvalues.KeyValuesFinder interface. The easiest way to implement a
          key value finder is to extend the base class org.kuali.rice.krad.keyvalues.KeyValuesBase.
          When extending this base class, we must implement the following method:</para>
        <programlisting>public List&lt;KeyValue&gt; getKeyValues();</programlisting>
        <para>Hopefully, it is
                    clear what we need to do here. As stated previously, each option is represented
                    by a KeyValue object, so we return a List of KeyValue objects that will make up
                    our options. How the method is implemented depends purely on the application
                    logic needed. A common pattern is to query the database to retrieve all records
                    of a certain type, and then to use two fields from the record (usually the
                    primary key property and a description property) as the key and value. Here is
                    an example from the Rice project that is building up the options for
                    state:</para>
        <programlisting>
public List&lt;KeyValue&gt; getKeyValues() {
    List&lt;KeyValue&gt; labels = new ArrayList&lt;KeyValue&gt;();
    List&lt;State&gt; codes = 
LocationApiServiceLocator.getStateService().findAllStatesInCountry(countryCode);

labels.add(new ConcreteKeyValue(&quot;&quot;, &quot;&quot;));
for (State state : codes) {
    if(state.isActive()) {
        labels.add(new ConcreteKeyValue(state.getCode(), state.getName()));
        }
    }
    return labels;
}
                </programlisting>
        <para>Notice the construction of ConcreteKeyValue objects using each state's code and name
          properties. </para>
        <para>Once a key value finder class is created, it needs to be specified on the
                    input field for which the options should apply. This is done using the <emphasis role="keyword">optionsFinder</emphasis> or <emphasis role="keyword">optionsFinderClass</emphasis>
          properties. This first of these takes an actual KeyValueFinder instance, so it will be an
          inner bean or bean reference in the XML. This is useful if a reusable finder has been
          created that contains properties which can be configured. For example, suppose our state
          finder had an option indicating whether inactive state codes should be included. First, we
          could setup a base bean as follows:</para>
        <programlisting>&lt;bean id="StateOptionsFinder" class="org.kuali.rice.location.framework.state.StateValuesFinder"/&gt;</programlisting>
        <para>Next, we can specify that the state finder should be used for an input field
                    and configure the include inactive option:</para>
        <programlisting>
&lt;bean parent="Uif-InputField" p:propertyName="stateCode"&gt;
    &lt;property name="optionsFinder"&gt;
        &lt;bean parent="StateOptionsFinder" p:includeInactive="true"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
                </programlisting>
        <para>If our finder class does not have any options, or we just want to use the
                    default, we can specify the class using the optionsFinderClass property:</para>
        <programlisting>&lt;bean parent="Uif-InputField" p:propertyName="stateCode" 
      p:optionsFinderClass="org.kuali.rice.location.framework.state.StateValuesFinder"/&gt; </programlisting>
<!-- TODO: Add Content Here
                <note>
                    <title>Reusable Key Value Finders</title>
                    <para>Since the majority of key value finder implementations employ the pattern of 
                        retrieving all records for a business object, a 'generic' key value finder could 
                        easily be built that is configured with the business object class to retrieve, and 
                        properties that should be used for the key and value. Then this finder can be referenced 
                        and configured within input fields saving the need to create a new class each time. 
                        This along with potentially other reusable key value finders will be added in Rice 
                        2.2.</para>
                </note>
                -->        <para>When the key value finder class is configured on an input field, during the
                    view lifecycle it will be invoked to build the options, which will then in turn
                    be set on the options property of the control. If the options property was
                    already set on the control, it will not be overridden.</para>
        <para>The KeyValueFinder class is actually used not only in KRAD, but in various places
          throughout the Rice project. In terms of building options for our controls, it has one big
          gap. Our getKeyValues method takes no parameters, so unless our model data is provided
          through some global variable, it is not possible to conditionally build the options based
          on a model property value. This is a use case that comes up often. For example, think of
          two dropdown controls, the first providing options for the food groups (Dairy, Fruit,
          Vegetables, and so on). The second dropdown should provide options for the particular
          foods within the selected group of the first dropdown. Thus, our key value finder for the
          food dropdown needs to know the current value for the food group.</para>
        <para>To allow for this, KRAD extends the KeyValueFinder interface with
                    org.kuali.rice.krad.uif.control.UifKeyValuesFinder. One of the methods this
                    interface adds is the following:</para>
        <programlisting>public List&lt;KeyValue&gt; getKeyValues(ViewModel model);</programlisting>
        <para>Notice we now have a getKeyValues method that takes in the model from which we can get
          at our application data. A base class named
          org.kuali.rice.krad.uif.control.UifKeyValuesFinderBase is provided for creating new UIF
          key value finders. The following demonstrates implementing conditional logic for building
          the options:</para>
        <programlisting>
public class FoodKeyValuesFinder extends UifKeyValuesFinderBase { 

@Override
public List&lt;KeyValue&gt; getKeyValues(ViewModel model) {
    UifComponentsTestForm testForm = (UifComponentsTestForm) model;  
                        
    List&lt;KeyValue&gt; options = new
                        ArrayList&lt;KeyValue&gt;();  

        if (testForm.getFoodGroup().equals(&quot;Fruits&quot;)) {
            options.add(new ConcreteKeyValue(&quot;Apples&quot;, &quot;Apples&quot;));
            options.add(new ConcreteKeyValue(&quot;Bananas&quot;, &quot;Bananas&quot;));
            options.add(new ConcreteKeyValue(&quot;Cherries&quot;, &quot;Cherries&quot;));
            options.add(new ConcreteKeyValue(&quot;Oranges&quot;, &quot;Oranges&quot;));
            options.add(new ConcreteKeyValue(&quot;Pears&quot;, &quot;Pears&quot;));
        } else if (testForm.getFoodGroup().equals(&quot;Vegetables&quot;)) {
            options.add(new ConcreteKeyValue(&quot;Beans&quot;, &quot;Beans&quot;));
            options.add(new ConcreteKeyValue(&quot;Broccoli&quot;, &quot;Broccoli&quot;));
            options.add(new ConcreteKeyValue(&quot;Cabbage&quot;, &quot;Cabbage&quot;));
            options.add(new ConcreteKeyValue(&quot;Carrots&quot;, &quot;Carrots&quot;));
            options.add(new ConcreteKeyValue(&quot;Celery&quot;, &quot;Celery&quot;));
            options.add(new ConcreteKeyValue(&quot;Corn&quot;, &quot;Corn&quot;));
            options.add(new ConcreteKeyValue(&quot;Peas&quot;, &quot;Peas&quot;));
        }  
        
        return options;
    }
}
                </programlisting>
        <para>In this example, foodGroup, which is on our test form, holds the value for the
          selected food group. This key value finder is then associated with the field that will
          display the available foods for that group:</para>
        <programlisting>
&lt;bean parent=&quot;Uif-InputField&quot; p:propertyName=&quot;food&quot; p:label=&quot;Foods" 
     p:optionsFinderClass=&quot;edu.sampleu.travel.options.FoodKeyValuesFinder&quot; p:refreshWhenChanged=&quot;field88&quot;&gt;
    &lt;property name="control"&gt;
        &lt;bean parent="Uif-DropdownControl"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
                </programlisting>
        <para>Notice the refreshWhenChanged property setting pointing to foodGroup. This is
          configuring refresh behavior, which we will learn about in Chapter 11. When the value of
          the foodGroup control changes, it will refresh our food control, which will then rebuild
          the options based on the new food group!</para>
        <para>Besides making the model data available, the UIF key value finder also
                    provides another convenience. In some cases (depending on whether our field is
                    required) we want to display a blank option for our control, while others we do
                    not (forcing a value to be selected). You might have noticed in our state finder
                    the following line:</para>
        <programlisting>labels.add(new ConcreteKeyValue(&quot;&quot;, &quot;&quot;));</programlisting>
        <para>This is adding a blank option at the beginning of the options list. Previous
                    to KRAD, if you then wanted the same options on another screen but did not want
                    to provide the blank option, a new key value finder class would need to be
                    created. The UifKeyValuesFinder makes this a simple configuration option with
                    the following method:</para>
        <programlisting>public boolean isAddBlankOption();</programlisting>
        <para>When this is set to true, the framework will add a blank option to the
                    returned list of options from the key value finder. Using the mechanism
                    described above for setting key value finder properties, we can reuse the same
                    class in multiple places and configure whether a blank option should be
                    added.</para>
      </section>
      <section>
        <title>CheckboxGroup</title>
        <para>The CheckboxGroup control is a multi-value control that presents each option as a
          checkbox. When a checkbox is selected the corresponding option key will be selected as a
          value. The checkbox group allows the selection of multiple options, therefore multiple
          checkboxes for the group may be selected. The option label for each checkbox is rendered
          to the right of the control.</para>
        <para>The checkbox group control supports one custom property named delimiter. This is a
          string that will be rendered between each checkbox (including the label). Two common
          options for this are the '&amp;nbsp;' and '&lt;/br&gt;' strings. Note this is the HTML
          entity and tag and thus the first adds a space between each checkbox, while the second
          adds a link break between each. These can be used to horizontally or vertically align the
          checkboxes. KRAD provides base beans for both these options named
          'Uif-HorizontalCheckboxesControl' and 'Uif-VerticalCheckboxesControl'.</para>
        <para>To specify a checkbox control should be used, a bean with parent of
          'Uif-HorizontalCheckboxesControl' or 'Uif-VerticalCheckboxesControl' should be
          given:</para>
        <programlisting>
&lt;bean parent="Uif-InputField" p:propertyName="selectedOpts" p:label="Checkboxes 1"&gt;
    &lt;property name="control"&gt;
        &lt;bean parent="Uif-VerticalCheckboxesControl"&gt;
            &lt;property name="options"&gt;
                &lt;list&gt;
                    &lt;bean parent="Uif-KeyLabelPair" p:key="O1" p:value="Option 1"/&gt;
                    &lt;bean parent="Uif-KeyLabelPair" p:key="O2" p:value="Option 2"/&gt;
                    &lt;bean parent="Uif-KeyLabelPair" p:key="O3" p:value="Option 3"/&gt;
                &lt;/list&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;
                </programlisting>
        <para>Note we could also have chosen to configure the optionsFinder or
                    optionsFinderClass on the input field bean instead of configuring the options
                    directly on the control.</para>
        <para>Below shows the checkbox group control.</para>
        <figure>
          <title>CheckboxGroup Control</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="../images/KRAD_Guide/checkBoxGroupControl.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>Since the checkbox group control allows selecting multiple values, our back
                    model property must be a List type of primitives (usually string). For
                    example:</para>
        <programlisting>private List&lt;String&gt; checkboxGroupProperty;</programlisting>
        <para>After the request data is bound to the model, each value that was checked will
                    be an entry in the List.</para>
      </section>
      <section>
        <title>RadioGroup</title>
        <para>The RadioGroup control is similar to the checkbox group control, with the exception of
          it only allowing one value to be selected. Similar to the checkbox group, it supports the
          delimiter property and the UIF provides two base beans for the space and line break
          delimiters.</para>
        <para>To specify a radio control should be used, a bean with parent of
          'Uif-HorizontalRadioControl' or 'Uif-VerticalRadioControl' should be given:</para>
        <programlisting>
&lt;bean parent="Uif-InputField" p:propertyName="selectedOpt" p:label="Radio 1"&gt;
    &lt;property name="control"&gt;
        &lt;bean parent="Uif-VerticalRadioControl"&gt;
            &lt;property name="options"&gt;
                &lt;list&gt;
                    &lt;bean parent="Uif-KeyLabelPair" p:key="O1" p:value="Option 1"/&gt;
                    &lt;bean parent="Uif-KeyLabelPair" p:key="O2" p:value="Option 2"/&gt;
                    &lt;bean parent="Uif-KeyLabelPair" p:key="O3" p:value="Option 3"/&gt;
                &lt;/list&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;
                </programlisting>
        <para>Since the radio control only allows selection of one option, the back model property
          should be a non-List type.</para>
      </section>
      <section>
        <title>Select</title>
        <para>The Select control is another variation of a
                    multi-value control. The select control appears similar to the text control, but
                    with an arrow to display a dropdown list of options. The select control can be
                    configured to only allow one selection, or multiple.</para>
        <para>To specify a select control should be used that allows only one value to be selected,
          a bean with parent of 'Uif-DropdownControl' should be used:</para>
        <programlisting>
&lt;bean parent="Uif-InputField" p:propertyName="selectedOpt" p:label="Select Control"&gt;
    &lt;property name="control"&gt;
        &lt;bean parent="Uif-DropdownControl"&gt;
            &lt;property name="options"&gt;
                &lt;list&gt;
                    &lt;bean parent="Uif-KeyLabelPair" p:key="O1" p:value="Option 1"/&gt;
                    ...
                &lt;/list&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;
                </programlisting>
        <para>The back model property in this case should be a simple primitive (string, integer,
          …). </para>
        <para>Below shows the select control allowing only one selection.</para>
        <figure>
          <title>Select Control</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="../images/KRAD_Guide/selectControl.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>To specify a select control should be used that allows one or more values to be
          selected, a bean with parent of 'Uif-MultiSelectControl' should be used: </para>
        <programlisting>
&lt;bean parent="Uif-InputField" p:propertyName="selectedOpts" p:label="Multi Select Control"&gt;
    &lt;property name="control"&gt;
        &lt;bean parent="Uif-MultiSelectControl"&gt;
            &lt;property name="options"&gt;
                &lt;list&gt;
                    &lt;bean parent="Uif-KeyLabelPair" p:key="O1" p:value="Option 1"/&gt;
                    ...
                &lt;/list&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;
                </programlisting>
        <para>Below shows the select control allowing multiple values to be selected. </para>
        <figure>
          <title>Multi Select Control</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="../images/KRAD_Guide/multiSelectControl.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>The select control supports two custom properties. The first is the multiple property
          which is a boolean indicating whether selection of more than one value is allowed (set to
          true by the 'Uif-MultiSelectControl' bean). The second property is named size and
          configures how many options should be visible to the user without using the arrow. This
          dictates the vertical size of the control. As an example the select control above was set
          to 4. </para>
      </section>
      <section>
        <title>KIM Group</title>
        <para>The KIM Group control is not an actual different type of HTML control. Instead, it is
          a wrapper for the text control that provides additional functionality related to selecting
          a KIM group. The KIM group and KIM user entities are used often in Rice enabled
          applications; therefore, these controls are provided to simplify the configuration.</para>
        <para>The group control adds a quickfinder (lookup icon) to the text control that is
                    configured to invoke the KIM group lookup. The lookup is configured to return
                    the group id, namespace, and name. The namespace and name fields can then be
                    displayed as data or input fields, and the group id will be added as a
                    hidden.</para>
        <para>To use the KIM group control a bean with parent of 'Uif-KimGroupControl' should be
          given. The property that backs the input field for which the control is configured is
          assumed to hold the group name. As usual this is configured using the propertyName
          property on input field. In order for the control to work properly, we must then specify
          the properties that hold the group id and namespace:</para>
        <programlisting>
&lt;bean parent=&quot;Uif-InputField&quot; p:propertyName=&quot;groupNamespaceCode&quot; p:label=&quot;Namespace Code&quot;/&gt;
&lt;bean parent=&quot;Uif-InputField&quot; p:propertyName=&quot;groupName&quot; p:label=&quot;Name&quot;&gt;
    &lt;property name=&quot;control&quot;&gt;
        &lt;bean parent=&quot;Uif-KimGroupControl&quot; p:groupIdPropertyName=&quot;groupId&quot; p:namespaceCodePropertyName=&quot;groupNamespaceCode&quot;/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
                </programlisting>
        <para>Notice we are displaying the group namespace in an input field before the group name.</para>
      </section>
      <section>
        <title>KIM User</title>
        <para>The KIM User control is similar to the KIM Group control but instead of a KIM group,
          it allows us to find a KIM User. This control does several things for us. First, like the
          group control, it will configure a quickfinder for our field that is configured to invoke
          the KIM User lookup. The lookup will then return the principal id, principal name
          (username), and person name (full name). Also, like the group control, it will
          automatically add the principal id as a hidden field for us. In addition, it sets up a
          field query (covered later on in this chapter) that displays the person name under the
          control on return from the lookup, or when tabbing out of the control.</para>
        <para>To use the KIM User control, a bean with parent of 'Uif-KimPersonControl' should be
          given. The property that backs the input field for which the control is configured is
          assumed to hold the principal name. As usual this is configured using the propertyName
          property on input field. In order for the control to work properly, we must then specify
          the properties that hold the principal id and the person name:</para>
        <programlisting>
&lt;bean parent=&quot;Uif-InputField&quot; p:propertyName=&quot;principalName&quot; p:label=&quot;Person Name&quot; p:required=&quot;true&quot;&gt;
    &lt;property name=&quot;control&quot;&gt;
        &lt;bean parent=&quot;Uif-KimPersonControl&quot; p:principalIdPropertyName=&quot;principalId&quot; p:personNamePropertyName=&quot;personName&quot;/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
                </programlisting>
        <para>It a common setup to carry the principal id as a primitive field, with a nested Person
          object. In these cases, it is not necessary to have a separate property for the principal
          name and person name, but instead the properties on the nested person object can be used.
          For these cases, the user control provides a simpler way to configure it by setting the
          personObjectPropertyName. This is the name of the property that holds the nested person
          object. </para>
        <programlisting>
&lt;bean parent=&quot;Uif-InputField&quot; p:propertyName=&quot;principalName&quot; p:label=&quot;Person Name&quot; p:required=&quot;true&quot;&gt;
    &lt;property name=&quot;control&quot;&gt;
        &lt;bean parent=&quot;Uif-KimPersonControl&quot; p:personObjectPropertyName=&quot;person"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
                </programlisting>
        <para>Below shows the user control with the person name displayed:</para>
        <figure>
          <title>KIM Group Control</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="../images/KRAD_Guide/KIMGroupControl.png"/>
            </imageobject>
          </mediaobject>
        </figure>
      </section>
    </section>
    <section role="NotInToc">
      <title>Recap</title>
      <para>
                <itemizedlist>
          <listitem>
            <para>A control is a type of content element that allows the user to input
                            data through the HTML form</para>
          </listitem>
          <listitem>
            <para>A control has an initial value that comes from a model property, and
                            can then be changed by the user or script on behalf of the user</para>
          </listitem>
          <listitem>
            <para>When the form is submitted, the value for each control is sent as a request
              parameter, where the parameter name is the taken from the name attribute and the value
              is the actual control value</para>
          </listitem>
          <listitem>
            <para>Controls are associated with an input field which holds a pointer to
                            the property from which the control value will be pulled</para>
          </listitem>
          <listitem>
            <para>HTML controls have different types which are represented by different
                            control components in KRAD</para>
          </listitem>
          <listitem>
            <para>The <emphasis role="keyword">Checkbox</emphasis> component is used to render an HTML
              input of type 'checkbox'. A checkbox is used to toggle a value (typically a boolean
              property with true or false values)</para>
          </listitem>
          <listitem>
            <para>The <emphasis role="keyword">File</emphasis> component is used to render an HTML
              input of type 'file'. This allows the user to select a file from the local file system
              that will be uploaded to the server. The backing property for a file control must be
              of type org.springframework.web.multipart.MultipartFile</para>
          </listitem>
          <listitem>
            <para>The <emphasis role="keyword">Hidden</emphasis> component is used to render an HTML
              input of type 'hidden'. This control is not visible to the user and therefore cannot
              be changed directly by the user (only by script)</para>
          </listitem>
          <listitem>
            <para>The <emphasis role="keyword">Text</emphasis> component is used to render an HTML
              input of type 'text'. This renders a single line text box where the user can type a
              value. This control supports the following options:</para>
            <itemizedlist>
              <listitem>
                <para>size – The horizontal display size of the text box</para>
              </listitem>
              <listitem>
                <para>maxLength – The maximum number of the characters the user
                                        can enter (corresponding to the length of the value)</para>
              </listitem>
              <listitem>
                <para>minLength – The minimum number of characters that are
                                        required for the value</para>
              </listitem>
              <listitem>
                <para>datePicker – A nested date picker widget that allows the user to select a date
                  from a calendar</para>
              </listitem>
              <listitem>
                <para>watermarkText – Text that will appear in the control when
                                        there is no value. This is used to help the user know the
                                        format for the value</para>
              </listitem>
              <listitem>
                <para>textExpand – A boolean that indicates whether the text
                                        expand widget should be enabled for the control. This allows
                                        the user to click an icon and get an expanded text
                                        box</para>
              </listitem>
            </itemizedlist>
          </listitem>
          <listitem>
            <para>The UIF provides base beans that promote standard sizes for small, medium, and
              large text controls. These include 'Uif-SmallTextControl', 'Uif-MediumTextControl',
              and 'Uif-LargeTextControl'</para>
          </listitem>
          <listitem>
            <para>The UIF also provides the bean 'Uif-DateControl' which is a text control with the
              date picker widget enabled. Furthermore the bean 'Uif-CurrencyTextControl' can be used
              when the value is a currency</para>
          </listitem>
          <listitem>
            <para>The TextArea component renders an HTML text area tag. This is a multi-line text
              box used for long values. The text area components support the rows and cols
              properties, which determine the vertical and horizontal display size of the
              control</para>
          </listitem>
          <listitem>
            <para>The Spinner component renders as an HTML input of type 'text' that is decorated
              with the jQuery Spinner plugin. This allows the user to increment or decrement the
              value using a arrows rendered within the text box</para>
          </listitem>
          <listitem>
            <para>Multi-Value controls are controls which can present multiple values
                            for selection and possibly allow multiple values to be submitted for a
                            single field</para>
          </listitem>
          <listitem>
            <para>When creating a multi-value control we must specify the options that
                            should be available. These are built by configuring instances of the
                            Rice KeyValue interface (ConcreteKeyValue implementation)</para>
          </listitem>
          <listitem>
            <para>KeyValue objects can be created in XML by using the bean 'Uif-KeyLabelPair'</para>
          </listitem>
          <listitem>
            <para>The list of KeyValues are associated with a control using the
                                <emphasis role="keyword">options</emphasis> property</para>
          </listitem>
          <listitem>
            <para>Instead of specifying the options directly in the XML, we can create a
                            class of type org.kuali.rice.krad.keyvalues.KeyValuesFinder and
                            implement the method List&lt;KeyValue&gt; getKeyValues(). This class is
                            then configured on the input field using the property <emphasis role="keyword">optionsFinderClass</emphasis> (or an object can be
                            injected using the optionsFinder property)</para>
          </listitem>
          <listitem>
            <para>The UIF provides a special key value finder
                            org.kuali.rice.krad.uif.control.UifKeyValuesFinder that allows
                            conditional key values to be built based on the model</para>
          </listitem>
          <listitem>
            <para>The <emphasis role="keyword">CheckboxGroup</emphasis> component is a multi-value
              control that presents the options as a set of checkboxes</para>
          </listitem>
          <listitem>
            <para>The checkbox group control supports a delimiter which will be rendered between
              each checkbox. The UIF provides two beans with a delimiter set:
              'Uif-HorizontalCheckboxesControl' (space delimiter) and
              'Uif-VerticalCheckboxesControl' (HTML break delimiter)</para>
          </listitem>
          <listitem>
            <para>Checkbox group controls allow multiple values to be selected.
                            Therefore the backing property must be a List type</para>
          </listitem>
          <listitem>
            <para>The <emphasis role="keyword">RadioGroup</emphasis> component is similar
                            to the checkbox group, with the exception of only allowing one value to
                            be selected</para>
          </listitem>
          <listitem>
            <para>The <emphasis role="keyword">Select</emphasis> component is a multi-value
                            control that presents the options as a dropdown (arrow in the text box
                            that can be clicked to see the options)</para>
          </listitem>
          <listitem>
            <para>Select controls are created using the bean 'Uif-DropdownControl' for allowing a
              single value to be selected or the bean 'Uif-MultiSelectControl' for allowing multiple
              values to be selected</para>
          </listitem>
          <listitem>
            <para>The select control supports the <emphasis role="keyword">size</emphasis>
                            property which controls the number of options that are visible without
                            clicking the arrow</para>
          </listitem>
          <listitem>
            <para>The <emphasis role="keyword">KIMGroup</emphasis> control is a special
                            text control that is configured for inputting KIM group names</para>
          </listitem>
          <listitem>
            <para>The <emphasis role="keyword">KIMUser</emphasis> control is a special text
                            control that is configured for inputting KIM users. It adds things such
                            as a quickfinder and field query</para>
          </listitem>
        </itemizedlist>
            </para>
    </section>
  </section>
  <section>
    <title>Disabling Controls and Tabbing </title>
    <para>Besides the specific properties offered by the various controls, all control
            components inherit a couple of properties from
            org.kuali.rice.krad.uif.control.ControlBase. The first of these is the <emphasis role="keyword">tabIndex</emphasis> property. This property is an int type
      that is used to populate the tabIndex attribute on the corresponding control element tag. This
      is of course used by the browser to set the tabbing order between the form controls. </para>
    <para>By default, the framework sets all tab indexes to 0. This means the tabbing will
            follow the natural order of the page (the order the controls are laid out on the page).
            However, if needed a specific tab order can be created by setting the tab index property
            for each control.</para>
    <para>The other property supported on all controls is the <emphasis role="keyword">disabled</emphasis> property with type Boolean. The value given for this property will be
      set as the attribute value for the disabled attribute of the corresponding control element.
      This indicates to the browser that the user should not be allowed to interact with the
      control.</para>
    <para>Similar to other properties, we can statically set the value to 'true' or 'false' in the
      XML, or use an expression to conditionally disable the control:</para>
    <programlisting>
&lt;bean parent="Uif-InputField" p:propertyName="fruitName"&gt;
    &lt;property name="control"&gt;
        &lt;bean parent="Uif-TextControl" p:disabled="@{foodGroup ne 'Fruit'}"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
        </programlisting>
    <para>In this example, we are disabling the text control for 'Fruit Name' if the food group
      field is not 'Fruit'.</para>
    <para>The following is an example text control that is in the disabled state:</para>
    <figure>
      <title>Disabled State Control</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="../images/KRAD_Guide/disabledStateControl.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <tip>
      <title>Disabled or Read Only</title>
      <para>An important UX issue is whether to disable a control, or make the control read only.
        Both display the current value and prevent the user from changing it. Generally, a disabled
        control is used to temporarily disallow interaction based on a condition. It might be the
        result of a refreshed component based on a change to data. Read only is often used to
        display a state that cannot be changed based on the current data (for example user
        permissions, or a state that the user cannot modify).</para>
    </tip>
<!-- TODO: Add Content Here
        <note>
            <title>Disabled Reason</title>
            <para>Control base also currently has a property name controlReason. This is not currently being 
                used by the framework but the intention is when a control's state is changed to disabled, a 
                reason can be given using this property. The user will then be able to hover over the control 
                to see the disabled reason as a tooltip (Tooltips are an upcoming enhancement as well).</para>
        </note>
        -->    <section role="NotInToc">
      <title>Recap</title>
      <para>
                <itemizedlist>
          <listitem>
            <para>All controls have the <emphasis role="keyword">tabIndex</emphasis> property which can
              be used to implement a custom tab order (Note that this is not recommended, though, if
              not set, the framework will set the tab indexes based on the natural order of the
              page)</para>
          </listitem>
          <listitem>
            <para>Controls also support the <emphasis role="keyword">disabled</emphasis>
                            property. This is a boolean that will disable the control so that input
                            is not allowed (the control is still rendered). Like most properties,
                            the disabled property can contain an expression to conditionally disable
                            the control</para>
          </listitem>
        </itemizedlist>
            </para>
    </section>
  </section>
  <section>
    <title>Hooking up Lookups and Inquiries </title>
    <para>The input field component also provides a couple of widgets we can configure that will
            help the user with data input. The first of these is the fieldLookup property which is a
            nested widget component. This widget component is called a Quickfinder. Quickfinder is a
            term that was adopted in the KNS framework to represent the icon next to a control that
            can be used to bring up a lookup screen, search for a value, and return that value to
            the field. In KRAD, the quickfinder widget holds all the configuration for rendering the
            icon along with the lookup request it makes.</para>
    <para>All the options for quickfinder are covered in Chapter 8, but we will go over the
      essential ones here. To understand these widget properties, we need to know a little bit about
      the lookup API. Essentially, this is a request based API where communication is done via
      request parameters, of which the following are required:</para>
    <para><emphasis role="keyword">dataObjectClassName</emphasis> – Lookup views (a special 'type' of
      view) are associated with a data object class. This is the class for the data object the
      search will be performed on. After the bean container is loading, an indexing process is
      performed that maps data object classes to configured lookup views (see 'View Type Indexing'
      in Chapter 13). Therefore, instead of passing in the unique view id to specify the view we
      want, we can pass in the data object class name.</para>
    <para><emphasis role="keyword">fieldConversions</emphasis> – The purpose of using the lookup is to
      search for a particular value and return that value to the form being completed. In order for
      the lookup framework to return the field back to us, we must specify the name of the field on
      the data object class whose value we need, and the name of the field on the calling view.
      Furthermore, we can choose to have the lookup return additional fields that populate other
      form fields or informational properties (see 'Field Queries and Informational Properties').
      These pairs of fields are known as 'field conversions'.</para>
    <para>The fieldConversions property is a Map. Each entry represents a field that will be
            returned back from the lookup, with the entry key being the field name on the data
            object class, and the entry value being the field name on the calling view. It is
            helpful to think of this as a from-to mapping. Pulling from the data object field (map
            key) to the calling view field (map value).</para>
    <para>To configure a quickfinder on an input field, we have two options. First, we can create an
      inner bean with parent of 'Uif-QuickFinder' for the input field's fieldLookup property:</para>
    <programlisting>
&lt;bean parent="Uif-InputField" p:propertyName="document.number"&gt;
    &lt;property name="fieldLookup"&gt;
        &lt;bean parent="Uif-QuickFinder" p:dataObjectClassName="edu.sampleu.travel.bo.TravelAccount" 
         p:fieldConversions="number:document.number"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
        </programlisting>
    <para>In this example we have configured a quickfinder that will invoke the lookup view for
            Travel Account. After the user performs a search and selects a row (using the provided
            return value links), the corresponding number property value for the selected row will
            be returned and set in the document.number property for our view (the field for which
            the quickfinder is configured). Notice in this example we are using the map shorthand
            configuration for the fieldConversions property.</para>
    <para>An alternative configuration is to set the dataObjectClassName and fieldConversions
      properties directly using nested notation. Note this only works if the bean we are inheriting
      from (or one of its parents has configured) the parent property, else a NullPointerException
      will be thrown:</para>
    <programlisting>&lt;bean parent="Uif-InputField" p:propertyName="document.number" 
      p:fieldLookup.dataObjectClassName="edu.sampleu.travel.bo.TravelAccount" 
      p:fieldLookup.fieldConversions="number:document.number"/&gt;</programlisting>
    <note>
      <title>Initializing Nested Components</title>
      <para>It is a common practice in the UIF for base beans to initialize and nest components.
        This allows child beans to simply configure the needed properties on the nested component
        without having to initialize the component itself. For example, the 'Uif-InputField' has the
        following property tag:</para>
      <programlisting>
&lt;property name=&quot;fieldLookup&quot;&gt;
    &lt;bean parent=&quot;Uif-QuickFinder&quot;/&gt;
&lt;/property&gt;</programlisting>
      <para>If this was not provided, child beans would need to populate the fieldLookup property using a 
                nested bean instead of using the directed nested property notation.</para>
    </note>
    <para>Below we see the quickfinder icon (to the right of the text control) and the corresponding
      lookup view that is presented when the user clicks the icon:</para>
    <figure>
      <title>Quickfinder Hook</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="../images/KRAD_Guide/quickfinderHook.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <figure>
      <title>Quickfinder Hook Example</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="../images/KRAD_Guide/quickfinderHookExample.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>Another widget provided by input field and data field components is the Inquiry
            component. The inquiry is used to display additional information about the current field
            value, generally the associated database record. </para>
    <para>There are two different flavors of the inquiry, the 'standard' inquiry and the 'direct'
      inquiry. The former refers to an inquiry for a field that is read only (user is not allowed to
      change value). This inquiry is configured with the <emphasis role="keyword">fieldInquiry</emphasis> property on data field. A direct inquiry refers to an
            inquiry of a field that is editable (has a control for changing the value). This
            inquired is configured with the <emphasis role="keyword">fieldDirectInquiry</emphasis>
            property and is available on input fields only.</para>
    <para>Both inquiries point to the Inquiry widget component. This widget holds the
            configuration for invoking the inquiry view once the inquiry is triggered (a link for
            the standard and an icon for the direct). Inquiry views are similar to lookup views.
            They are associated with a data object class and can be requested by passing the data
            object class name. However, for inquiries we need to pass a value from the calling view
            to the inquiry view, instead of the other way around (as is the case for lookup views).
            These are the values that will be used to retrieve the data for the inquiry view.</para>
    <para>This configuration is done using the <emphasis role="keyword">inquiryParameters</emphasis>
      property on the Inquiry widget. Like the Lookup's fieldConversions property, this holds a map
      where each entry is a mapping of fields between the two views. The entry key is the name of
      the field in the calling view from which the value will be pulled, and the entry key is the
      name of the field in the inquiry data object class for which the value will be populated.
      Again we can think of this as a from-to mapping.</para>
    <para>To configure the standard inquiry we use a bean with parent of 'Uif-Inquiry'. For the
      direct inquiry, we use a bean with parent of 'Uif-DirectInquiry'. </para>
    <programlisting>
&lt;bean parent="Uif-InputField" p:propertyName="document.number"&gt;
    &lt;property name="fieldInquiry"&gt;
        &lt;bean parent="Uif-Inquiry" p:dataObjectClassName="edu.sampleu.travel.bo.TravelAccount" 
         p:inquiryParameters="document.number:number"/&gt;
    &lt;/property&gt;
    &lt;property name="fieldDirectInquiry"&gt;
        &lt;bean parent="Uif-DirectInquiry" p:dataObjectClassName="edu.sampleu.travel.bo.TravelAccount" 
         p:inquiryParameters="document.number:number"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
        </programlisting>
    <para>We also have the option of using the nested property notation instead of using inner
            beans.</para>
    <para>Below shows an example inquiry (standard inquiry for read only field), followed by an
            example direct inquiry</para>
    <figure>
      <title>Standard Inquiry, Read Only</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="../images/KRAD_Guide/standardInquiryReadOnly.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <section>
      <title>Automatic Lookups and Inquiries</title>
      <para>For many instances where a lookup or inquiry is desired, there is an underlying
        relationship in the model. In Chapter 3, we learned how to represent one-to-one
        relationships in code (with nested data objects) and then provide configuration to OJB using
        a reference descriptor. In Chapter 4, we learned about the data dictionary and the ability
        to declare relationship definitions for our data object entry. These sources of metadata are
        then consumed by the UIF to automatically configure lookups and inquiries for our
        fields!</para>
      <para>For each data or input field, the framework will attempt to find a model relationship if
        two conditions are met: one, we have not manually configured the lookup and inquiry; and
        two, the render flag for both is not set to false. Setting the render flag to false on the
        fieldLookup or fieldInquiry indicates to the framework that we do not want them rendered
        regardless of the existence of a relationship.</para>
      <para>The basic strategy for determining the existence of a
                relationship is as follows:</para>
      <orderedlist>
        <listitem>
          <para>Determine a parent data object class for the fields property.</para>
        </listitem>
        <listitem>
          <para>Query OJB metadata to get a class descriptor for the data object class, get any
            reference descriptors the property participates in.</para>
        </listitem>
        <listitem>
          <para>Query data dictionary metadata to get data object entries for the data object class,
            get any relationship definitions the field participates in.</para>
        </listitem>
        <listitem>
          <para>Of all the relationships found in steps 2 and 3, filter out those where the target
            class does not support the function (lookup or inquiry). For example, if the target data
            object class is TravelAccount, but there is no lookup view associated with that data
            object class, we do not consider that relationship.</para>
        </listitem>
        <listitem>
          <para>Of the relationships remaining from step 4, choose the relationship which has the
            lowest cardinality of foreign keys.</para>
        </listitem>
        <listitem>
          <para>If a relationship was not found and the property name is nested, split the
                        property name using the first part of the path as the parent property and
                        the remaining as the property name. Repeat the process looking for a
                        relationship. Note this is similar to the process of finding a back data
                        dictionary entry.</para>
        </listitem>
      </orderedlist>
      <para>This is a complicated process and not all details are important as a user of KRAD.
                However, the first step is critical to understand and deserves more explanation. The
                determination of the parent data object class drives the metadata picked up by the
                framework and therefore where the relationships will be found. Recall the three
                parts to the fields binding path: the object path, binding prefix, and binding name
                (property name). The framework will use the object path and prefix as the path to
                the parent object (everything except the property name). Then it will get the type
                for the property from the model which is used as the data object class.</para>
      <note>
        <title>Data Object Metadata</title>
        <para>Many areas of the UIF (including the above widgets) use metadata from the OJB
          repository and Data Dictionary together. They use a service named
          DataObjectMetaDataService which is a façade for both sources of metadata.</para>
      </note>
      <para>A couple of things should be noted about the automatic lookups and inquiries. First, if
        no relationship is found, the render flag on the widget will be set to false. Second, recall
        for the lookup and inquiry, we need to configure field mappings (fieldConversions and
        inquiryParameters). The framework builds these mappings from the fields that participate in
        the relationship.</para>
    </section>
    <section role="NotInToc">
      <title>Recap</title>
      <itemizedlist>
        <listitem>
          <para>The input field component provides the quickfinder widget to allow the
                        user to search for a value to enter. This is configured using the
                        fieldLookup property</para>
        </listitem>
        <listitem>
          <para>The quickfinder can be configured by creating an inner bean with parent
            'Uif-Quickfinder' or setting options using the nested notation
            (fieldLookup.property)</para>
        </listitem>
        <listitem>
          <para>The basic options for a quickfinder are:</para>
          <itemizedlist>
            <listitem>
              <para>dataObjectClassName – The full class name for the data object
                                    whose lookup view should be rendered</para>
            </listitem>
            <listitem>
              <para>fieldConversions – A mapping of properties on the lookup data
                                    object to properties in the calling view. When a result row is
                                    selected from the lookup, the values for the configured lookup
                                    data object fields will be returned to their associated view
                                    properties</para>
            </listitem>
            <listitem>
              <para>lookupParameters – A mapping of properties from the calling view to search
                fields for the data object. When the quickfinder is selected, the values for the
                configured view properties will be pulled and populated into the search
                fields</para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para>The input field also provides the Inquiry widget. This allows the user to see detail
            associated with the current value. This comes in two flavors, a simple inquiry
            (presented as a link) for read only state, and a direct inquiry (used by clicking an
            icon) to inquire on the current value of a control</para>
        </listitem>
        <listitem>
          <para>The inquiry widget is configured using the input field's <emphasis role="keyword">fieldInquiry</emphasis> and <emphasis role="keyword">fieldDirectInquiry</emphasis> properties</para>
        </listitem>
        <listitem>
          <para>The inquiry can be configured by creating an inner bean with parent 'Uif-Inquiry' or
            'Uif-DirectInquiry'. We can also use nested notation to set properties
            (fieldInquiry.property or fieldDirectInquiry.property)</para>
        </listitem>
        <listitem>
          <para>The basic options for an inquiry are:</para>
          <itemizedlist>
            <listitem>
              <para>dataObjectClassName – Full class name for the data object
                                    whose inquiry view should be rendered</para>
            </listitem>
            <listitem>
              <para>inquiryParameters – A mapping of properties from the calling view to properties
                on the inquiry data object. When the inquiry is selected, the values for the view
                properties will be pulled and sent with the inquiry as request parameters for the
                corresponding inquiry properties. This generally becomes the critiera for the record
                selection (and is generally the primary keys for the data object)</para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para>If a quickfinder or inquiry is not explicity configured, the framework will attempt
            to hook these up automatically. This is done using the DataObjectMetaDataService which
            will find relationships for the property</para>
        </listitem>
        <listitem>
          <para>We can turn off automatic quickfinders or inquiries by setting the render
                        property to false</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>
  <section>
    <title>Input Field Messages </title>
    <para>For views that are not used often (such as a student page) or complex or unclear fields,
      it is helpful to provide instructional text within the field. These messages provide
      additional information that helps clarify the intended use.</para>
    <para>The input field component has two types of standard messages that can be configured. The
      first of these is known as instructional text. Instructional text is used to indicate more
      information about filling out a field or how to complete a task using the UI elements. An
      example of this is "Complete this field only if applying for a one year loan". Instructional
      text is specified for an input field using the instructionalText property:</para>
    <programlisting>&lt;bean parent="Uif-InputField" p:propertyName="oneYearTerm" 
      p:instructionalText="Complete this field only if applying for a one year loan"/&gt;</programlisting>
    <para>The instructional text appears by default above the control and has a style class named
      'uif-instructionalMessage' applied. If the label placement is top, the instructional text will
      appear between the label and the control. </para>
    <para>Another type of message that can be configured on the input field is called constraint
            text. Constraint text gives the user information about the required format of the data
            that must be entered, or other information necessary for entering the data correctly. A
            constraint message can be configured using the constraintText property as shown
            here:</para>
    <programlisting>&lt;bean parent="Uif-InputField" p:propertyName="oneYearTerm" p:constraintText="Must be formatted as 3 digits"/&gt;</programlisting>
    <para>The constraint text appears by default under the control and has a style class named
      'uif-constraintMessage' applied.</para>
    <para>Below shows an input field with instructional and constraint text.</para>
    <figure>
      <title>Input Field with Contratint Text</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="../images/KRAD_Guide/inputFieldConstraintText.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>Recall from Chapter 4 these messages can also be configured on the dictionary
            attribute definition. If an attribute definition is found for the field, the
            instructional and constraint messages will be copied (unless overridden).</para>
    <section role="NotInToc">
      <title>Recap</title>
      <itemizedlist>
        <listitem>
          <para>Input field provides message properties that can be specified to help
                        clarify the purpose of a form field</para>
        </listitem>
        <listitem>
          <para>The first type of message is known as instructional text and is configured
                        with the <emphasis role="keyword">instructionalText</emphasis> property</para>
        </listitem>
        <listitem>
          <para>Instructional text is meant to give information about how to complete a
                        field or a task</para>
        </listitem>
        <listitem>
          <para>By default the instructional text appears above the input field control and has a
            style class of 'uif-instructionalMessage'</para>
        </listitem>
        <listitem>
          <para>The other type of message is known as constraint text and is configured
                        with the <emphasis role="keyword">constraintText</emphasis> property</para>
        </listitem>
        <listitem>
          <para>Constraint text gives information about the format or other constraints
                        for an inputted value</para>
        </listitem>
        <listitem>
          <para>By default the constraint text appears below the input field control and has a style
            class of 'uif-constraintMessage'</para>
        </listitem>
        <listitem>
          <para>These messages can also be configured on the data dictionary attribute
                        definition and inherited by the input field</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>
  <section>
    <title>Field Queries and Informational Properties </title>
    <para>Next let's take a look at some of the features available for providing the user dynamic
      information based on the inputted field data. The information provided can vary based on what
      is relevant for a particular field. Generally though, it is similar information as provided by
      the inquiry view, except we pick a couple of important fields that are inserted directly into
      the page field (without the user having to take an action and bring up a lightbox or separate
      page).</para>
    <para>To display dynamic information, first we need to setup placeholders or the properties that
      will hold the information. These must be valid properties on the model (however for displaying
      a custom message, the form is a great place to create 'dummy' properties). To specify
      information properties, we configure the informationalDisplayPropertyNames property on
      DataField. This property is a List type, with each entry giving the name for a property to
      display.</para>
    <programlisting>&lt;bean parent="Uif-InputField" p:propertyName="bookId" p:label="Book Id" 
      p:informationalDisplayPropertyNames="bookTitle,bookCopyright"/&gt;</programlisting>
    <para>In this example we have an input field for the book id property, and we want to
            display the values for the bookTitle and bookCopyright property with the field. </para>
    <para>Informational display properties by default are rendered under the field control (or if
      read only under the displayed value, and also if constraint text is present, then they will
      display below it). They are always displayed read only. The value for each property is placed
      with a span that receives a style class of 'uif-informationalMessage'. Therefore, we can
      configure this style to change how the properties are displayed. The default style uses the
      CSS display block style, making each property value appear on a new line.</para>
    <para> Below gives a picture of this with two informational properties being
            displayed.</para>
    <figure>
      <title>Two Informational Properties Example</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="../images/KRAD_Guide/informationalProperties.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <section>
      <title>Field Attribute Query</title>
      <para>Each time the field is rendered, the information display property values will be
        displayed. This is useful, however, by itself it is not 'dynamic'. That is, if the user then
        changes the value, the information properties will not change to reflect the update. To make
        this happen, we need to associate a piece of functionality called attribute query with our
        field.</para>
      <para>An attribute query is represented by the class
        org.kuali.rice.krad.uif.field.AttributeQuery. This is not a component, just a class that
        configures behavior that can be added to the input field component. Basically, this class
        provides properties for configuring a query to retrieve these information properties. It has
        similar concepts to the lookup (quickfinder widget) with a more targeted purpose. There are
        two mechanisms for configuring a query. The first involves configuring the necessary
        properties to allow the framework to automatically perform a query. This involves the
        following attribute query properties:</para>
      <para><emphasis role="keyword">dataObjectClassName</emphasis> –
                Name of the data object class the query will go against. The class given must be
                mapped to the database (with ORM metadata) to support the automatic lookup. This
                functions the same as the dataObjectClassName for the lookup view (or quickfinder
                widget).</para>
      <para><emphasis role="keyword">queryFieldMapping</emphasis> – A map type that holds the mappings
        of properties from the calling view to properties on the data object class. Each entry
        represents one property mapping. The map key is the property name in the calling view, and
        the map value is the property name on the data object class. This will usually include the
        property name of the field for which the query is configured (since we want to query based
        on the value the user has inputted). We might need to pass in additional properties from the
        view to complete the query. This property functions similarly to the inquiryParameters on
        the inquiry widget.</para>
      <para>Note this mapping is used to build criteria for the query. The values for the calling
        view properties are retrieved and used to restrict the retrieved data object records based
        on the mapped data object fields. For example, suppose we have the following query field
        mapping: "document.rentedBookId:bookId" and the value of the document.rentedBookId on our
        view is '3'. When the query is performed the following clause will be created "where bookId
        = '3'" (note the actual SQL is not constructed by KRAD, but created by the OJB criteria
        object).</para>
      <para><emphasis role="keyword">returnFieldMapping</emphasis> – A map type that holds the mappings of
                properties from the data object class to the calling view. Each entry represents one
                property mapping. The map key is the property name on the data object class, and the
                map value is the property name on the calling view. We can use this property to map
                properties on the data object class back to configured information display
                properties of the field. However, it is not limited to that. We can also map
                properties of the data object class back to properties that are separate fields
                (thus filling in the control value for those corresponding
                    fields).</para>
      <para><emphasis role="keyword">additionalCriteria</emphasis> – A map that holds additional
        criteria for the query. The criteria specified will be added to the constructed criteria
        based on query field mapping. The map key is the name of the property on the data object
        class the criteria should apply to, and the map value is the value for the criteria. All map
        entries are joined using the AND clause. Note, the map value does support query characters
        as provided by the lookup framework ('!' – not, '&gt;' – greater than, '&lt;' – less than,
        '*' – wildcard, and so on). In addition for the map values, we can use expressions
        ('@{}').</para>
      <para>To hook up an attribute query with an input field we use the
                    <emphasis role="keyword">fieldAttributeQuery</emphasis> property. We can then create an instance of the attribute
        query class by creating a bean with parent of 'Uif-AttributeQueryConfig':</para>
      <programlisting>
&lt;bean parent="Uif-InputField" p:propertyName="rentedBookId" p:label="Book Id" 
      p:informationalDisplayPropertyNames="rentedBookTitle,rentedBookCopyright"&gt;
    &lt;property name="fieldAttribueQuery"&gt;
        &lt;bean parent=&quot;Uif-AttributeQueryConfig&quot; p:dataObjectClassName=&quot;edu.sampleu.bookstore.bo.Book&quot; 
         p:queryFieldMapping=&quot;rentedBookId:bookId&quot; 
         p:returnFieldMapping=&quot;bookTitle:rentedBookTitle, bookCopyright:rentedBookCopyright&quot;/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
            </programlisting>
      <para>In
                this example we have an input field for the rentedBookId property. We then setup a
                query that will go against the Book data object, passing the value for rentedBookId
                as criteria for the bookId property. From the resulting record, the bookTitle and
                bookCopyright property values will be copied to the rentedBookTitle and
                rendedBookCopyright properties. These are configured as informational display
                properties, therefore the updated values will display under the control for
                rentedBookId.</para>
      <para>Note the framework takes care of triggering the query (with the 'onblur' event),
        performing the query, and updating the mapping return fields all client side (without a page
        post). It is expected the field attribute query will return only one result. If more than
        one record is retrieved, the first record of the hit list will be used. In the case of no
        matching records, a message will be rendered stating '{field label} not found', where {field
        label} is the configured label. This message can be disabled by setting
        fieldAttributeQuery.renderNotFoundMessage to false. In addition, attribute query contains a
        property named returnMessageText that can be used to configure a message that will display
        with the results, or a custom message in the case where no results are found.</para>
      <para>The attribute query class also allows us to hook up a custom
                query that will be invoked to retrieve the additional information. In this case, the
                developer writes the actual code to perform the query (call another service or
                whatever) and return the results. The framework will then take care of triggering
                the query and handling the results (updating the values).</para>
      <para>There is a great deal of flexibility for invoking a custom query method. Let's start
        with the way that requires the least amount of configuration. First, we need to know a
        little bit about the framework code, in particular one service. The UIF invokes a service of
        type org.kuali.rice.krad.uif.service.ViewHelperService to perform building of the view and
        many other UI related functions. An implementation of this service (ViewHelperServiceImpl)
        carries out this processing. The framework allows us to extend this service and declare that
        one or more views should use the custom view helper. This is our gateway for code-based
        customizations. So let's do it! The following sets up a custom view helper service:</para>
      <programlisting>
package edu.myedu.sample;
public class CustomViewHelperServiceImpl extends ViewHelperServiceImpl {
}</programlisting>
      <para>Next
                we configure our view to use the custom view helper service. This is done by setting
                the viewHelperServiceClass property on the view component (the View component is
                covered in complete detail in Chapter
                9):</para>
      <programlisting>
&lt;bean id=&quot;MyView&quot; parent=&quot;Uif-FormView&quot;&gt;
    ...
    &lt;property name=&quot;viewHelperServiceClass&quot; value=&quot;edu.myedu.sample.CustomViewHelperServiceImpl&quot;/&gt;
&lt;/bean&gt;
            </programlisting>
      <para>Now
                we have a place to put our custom query method. The signature of this method depends
                on the query being performed, but there are a few guidelines:<orderedlist>
          <listitem>
            <para>The method parameters must correspond to fields on the view (for
                            example, think of the queryFieldMapping which is configured for the
                            automatic query, essentially we will be pulling fields from the view the
                            same way, except passing them as arguments to the method).</para>
          </listitem>
          <listitem>
            <para>The method must return a data object instance for which the return properties can
              be retrieved, or a list of data objects (in the case of backing a field's suggest
              property), or an AttributeQueryResult. The AttributeQueryResult is an object that gets
              returned back to the client and read to process the results. If the method returns the
              data object, the framework will build the result object from that. However, the result
              object can be built directly for custom needs.</para>
          </listitem>
        </orderedlist></para>
      <para>To understand this better, let's take an example. We will create a method that will
        perform the same search as our automatic book query example. The query will go against the
        Book data object and take in the book id as a parameter:</para>
      <programlisting>
public Book retrieveBookById(String bookId) {
    Book foundBook;
    // do query to find the book
    
    return foundBook;
}
            </programlisting>
      <para>Now
                we need to configure the attribute query for the book id input field. To specify the
                name of our method that should be called, we use the <emphasis role="keyword">queryMethodToCall</emphasis> property provided by the AttributeQuery class.
                Then we specify the arguments for our method using the <emphasis role="keyword">queryMethodArgumentFieldList</emphasis> property. Note this property functions
                similarly to the queryFieldMapping, except we are not mapping properties from the
                calling view to properties on a data object, but instead to method arguments. The
                value for each property configured in the queryMethodArgumentFieldList list is
                retrieved and passed as a method argument in the order listed.</para>
      <para>The final
                step is to configure the returnFieldMapping property. This is the same as when doing
                the automatic query. It maps properties on the returned object (returned from the
                method) to properties on the
                view.</para>
      <programlisting>
&lt;bean parent="Uif-InputField" p:propertyName="rentedBookId" p:label="Book Id" 
     p:informationalDisplayPropertyNames="rentedBookTitle,rentedBookCopyright"&gt;
    &lt;property name="fieldAttribueQuery"&gt;
        &lt;bean parent=&quot;Uif-AttributeQueryConfig&quot; p:queryMethodToCall=&quot;retrieveBookById&quot; 
          p:queryMethodArgumentFieldList =&quot;rentedBookId&quot; 
          p:returnFieldMapping=&quot;bookTitle:rentedBookTitle, bookCopyright:rentedBookCopyright&quot;/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
            </programlisting>
      <para>Here we configure the attribute query to invoke the 'retrieveBookById' method. Since
        this is the only configuration we gave, the framework assumes this is on the view helper
        service. Next, we set the query method argument list as 'rentedBookId'. This means the value
        for the rentedBookId (the backing property for the field) will be pulled and sent as the
        first argument to our method. If we added another property; its value would be passed as the
        second argument, and so on. Finally, we configure the return field mapping to pull the
        bookTitle and bookCopyright properties from the data object returned from our method, and
        copy those values to the rentedBookTitle and rentedBookCopyright properties on the view
        model.</para>
      <para>In addition to
                calling methods on a custom view helper service, we can choose to call a method
                within another class. This could be a static class method somewhere, or a method on
                another service configured in the Spring container. To configure an alternate class,
                we use the <emphasis role="keyword">queryMethodInvokerConfig</emphasis> property on
                AttributeQuery.</para>
      <para>The type for this property is
                org.kuali.rice.krad.uif.component.MethodInvokerConfig. This type is used in various
                places within KRAD to configure a method invocation (for example setting component
                properties through code which is covered in Chapter 10). The class that contains the
                query method can be specified using one of the following three
                    properties:</para>
      <para><emphasis role="keyword">targetClass</emphasis> – Fully
                qualified class that contains the method. A new instance of this class will be
                created before the method is invoked.</para>
      <para><emphasis role="keyword">targetObject</emphasis> – Object instance the method should be invoked on. This
                is useful for referencing other Spring beans such as services.</para>
      <para><emphasis role="keyword">staticMethod</emphasis> – This configures a static method
        invocation and includes the class and method name (e.g.
        'edu.myedu.sample.QueryUtils.retrieveById').</para>
      <para>When using targetClass or
                targetObject, the method name can be configured by using the queryMethodToCall
                property on AttributeQuery, or by setting the <emphasis role="keyword">targetMethod</emphasis> property on MethodInvokerConfig. If needed, the
                argument types can be specified using the <emphasis role="keyword">argumentTypes</emphasis> property (in the case of overloaded methods), or even
                more information (such as generics and so on) can be configured using the <emphasis role="keyword">methodObject</emphasis> property.</para>
      <para>Wow! That's a lot of options. Let's look at a couple of examples.</para>
      <para>First let's assume we have the following static method:</para>
      <programlisting>
package edu.myedu.sample;
public class QueryUtils {
    public static Book retrieveBookById(String bookId) {
        Book foundBook;
        // do query to find the book
        return foundBook;
    }
} 
            </programlisting>
      <para>Our
                query configuration would then be as follows:</para>
      <programlisting>
&lt;property name="fieldAttribueQuery"&gt;
    &lt;bean parent=&quot;Uif-AttributeQueryConfig" 
        p:queryMethodInvokerConfig.staticMethod=
        &quot;edu.myedu.sample.QueryUtils.retrieveBookById&quot;
        p:returnFieldMapping=&quot;bookTitle:rentedBookTitle,
        bookCopyright:rentedBookCopyright&quot;/&gt;
&lt;/property&gt;
            </programlisting>
      <para>Next assume we have a service that has our retrieveBookById method, and we have
                the following Spring bean:</para>
      <programlisting>
&lt;bean id="BookService" class="edu.myedu.sample.BookServiceImpl"/&gt;</programlisting>
      <para>Our query configuration would then be as follows:</para>
      <programlisting>
&lt;property name="fieldAttribueQuery"&gt;
    &lt;bean parent=&quot;Uif-AttributeQueryConfig"
        p:queryMethodToCall="retrieveBookById"
        p:returnFieldMapping=&quot;bookTitle:rentedBookTitle,
        bookCopyright:rentedBookCopyright&quot;&gt;
    &lt;property name="queryMethodInvokerConfig.targetObject"&gt;
        &lt;ref bean="BookService"/&gt;
    &lt;/property&gt;
    &lt;/bean&gt;
&lt;/property&gt;
            </programlisting>
      <para>Finally the case of a non-static class method:</para>
      <programlisting>
package edu.myedu.sample;
public class QueryUtils {
    public Book retrieveBookById(String bookId) {
        Book foundBook;
        // do query to find the book
        return foundBook;
    }
} 
            </programlisting>
      <para>Our query configuration would be as follows:</para>
      <programlisting>&#160; 
&lt;property name="fieldAttribueQuery"&gt;
    &lt;bean parent=&quot;Uif-AttributeQueryConfig"
        p:queryMethodToCall="retrieveBookById"
        p:queryMethodInvokerConfig.targetClass=
        &quot;edu.myedu.sample.QueryUtils&quot; 
        p:returnFieldMapping=&quot;bookTitle:rentedBookTitle,
        bookCopyright:rentedBookCopyright&quot;/&gt;
&lt;/property&gt;
            </programlisting>
      <note>
        <title>Attribute Query Service</title>
        <para>If you are interested in learning more about the framework code supporting 
                    attribute queries, take a look at org.kuali.rice.krad.uif.service.AttributeQueryService 
                    and its implementation. All query calls (from the controller) go through this service
                </para>
      </note>
    </section>
    <section>
      <title>Field Suggest Widget </title>
      <para>The attribute query class is also used for configuring the Suggest widget. The Suggest
        widget decorates the standard text control to show the user options as they are inputting
        text (also known as auto-complete). The Suggest widget itself provides configuration on the
        client side behavior (such as delay, minimum number of characters for query, and so on).
        This widget along with others is covered in Chapter 8.</para>
      <para>The attribute query for the field Suggest widget is configured much like the field
        query. The only difference is instead of returning multiple fields from one record, we want
        to return values for one field only, but potentially multiple records. These make up the
        options the user sees when inputting a value (similar to the options provided by multi-value
        controls). In addition, the framework assumes that property from the data object class maps
        back to the field we configured the suggest with, therefore, we do not have to specify the
        returnFieldMapping. </para>
      <para>We configure the Suggest widget using the input field's <emphasis role="keyword">suggest</emphasis> property. This is the nested Suggest widget, which contains a nested
        AttributeQuery in the suggestQuery property. The base bean for the Suggest widget is
        'Uif-Suggest'. We again have the two mechanisms for configuring the query (automatic with
        dataObjectClassName, or build our own query and specify queryMethodToCall). After we have
        configured the data object or the query method, we can then specify the property name for
        the data object class that provides values using the <emphasis role="keyword">suggest.valuePropertyName</emphasis>:</para>
      <programlisting>
&lt;bean parent="Uif-InputField" p:propertyName="rentedBookTitle"&gt;
    &lt;property name="suggest"&gt;
        &lt;bean parent=&quot;Uif-Suggest&quot; p:valuePropertyName =&quot;bookTitle&quot;
            p:suggestQuery.dataObjectClassName=&quot;edu.myedu.sample.Book&quot;/&gt;
    &lt;/property&gt;
    &lt;/bean&gt;
            </programlisting>
      <para>Since our query can now return multiple records, we should sort them so the field
                values appear in ascending order to the user. This can be accomplished by specifying
                the property names to sort by with the attribute query <emphasis role="keyword">sortPropertyNames</emphasis> property:</para>
      <programlisting>
&lt;property name="suggest"&gt;
    &lt;bean parent=&quot;Uif-Suggest&quot; p:valuePropertyName =&quot;bookTitle&quot;
        p:suggestQuery.dataObjectClassName=&quot;edu.myedu.sample.Book&quot;
        p:suggestQuery.sortPropertyNames="bookTitle"/&gt;
&lt;/property&gt;
            </programlisting>
      <para>In this example we are sorting the resulting Book data objects by their bookTitle
                property. The sortPropertyNames property is a List type, therefore multiple columns
                to sort on can be given (using a comma for the shorthand notation, or the Spring
                list tag).
            </para>
      <note>
        <title>Paths for Properties Configured with a Data Field</title>
        <para>Throughout the past few sections we have discussed many properties on data and input
          field that specify other model properties (such as the property mappings, informational
          properties, additional/alternate display properties). Just like the property configured
          for the field itself, these are properties on the model the framework needs to pull
          (possibly set) a value from. Also just like the field property, we need to know the full
          'path' to the property from the root model object (generally the form object). In the
          section on data binding we discussed how tedious it would be to specify the full path for
          each field property (and in some cases like collection fields not even possible). The same
          is true for these other properties. Luckily, KRAD helps out with this by automatically
          adjusting the paths for these property names. It does this by looking at the binding info
          object for the field the various properties are associated with, and assuming they have
          the same binding object path and prefix (if given). </para>
        <para>For example, let&apos;s assume we have the following input field:</para>
        <programlisting>
&lt;bean parent="Uif-InputField" p:propertyName="bookId"
    p:readOnlyDisplaySuffixPropertyName="bookTitle"
    p:informationalDisplayPropertyNames="bookTitle,bookCopyright"&gt;
    &lt;property name="fieldLookup"&gt;
        &lt;bean parent="Uif-Quickfinder"
            p:dataObjectClassName="edu.myedu.sample.Book"
            p:fieldConversions="id:bookId"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
                </programlisting>
        <para>Now assume this field belongs to a group where fieldBindingObjectPath is set to
          'document.newBook'. Thus the binding path for our field will be 'document.newBook.bookId'.
          The paths for the additional display property, informational display properties, and
          quickfinder field conversions will then be adjusted by prefixing 'document.newBook' to the
          path (eg 'document.newBook.bookTitle'). If a property should not be adjusted (for example,
          using a dummy form property), it can be prefixed with the string '#form.' (eg
          '#form.holdBookId'). When the framework finds this, it will take the prefix off and do no
          further adjustment.</para>
      </note>
    </section>
    <section role="NotInToc">
      <title>Recap</title>
      <para>
                <itemizedlist>
          <listitem>
            <para>Field queries provide dynamic information for an inputted value</para>
          </listitem>
          <listitem>
            <para>To support field queries the data field property <emphasis role="keyword">informationDisplayPropertyNames</emphasis> can be configured with a
                            list of property names whose values should be displayed with the
                            field</para>
          </listitem>
          <listitem>
            <para>When the field is rendered, values for informational display properties will be
              rendered as well. By default, each value appears on a line below the control and
              receives a style class of 'uif-informationalMessage'</para>
          </listitem>
          <listitem>
            <para> To update information display properties dynamically (immediately
                            after the user inputs or changes the field value) we can build a field
                            attribute query </para>
          </listitem>
          <listitem>
            <para>Field queries are supported by the class
                            org.kuali.rice.krad.uif.field.AttributeQuery. This holds configuration
                            for performing a query and mapping return values. Supported properties include:</para>
            <itemizedlist>
              <listitem>
                <para>dataObjectClassName – Name of the data object class the query
                                    will be performed against. When specified the framework will
                                    build a query against the data object</para>
              </listitem>
              <listitem>
                <para>queryFieldMapping - A map type that holds the mappings of
                                    properties from the calling view to properties on the data
                                    object class. This becomes part of the query criteria</para>
              </listitem>
              <listitem>
                <para>returnFieldMapping – A map type that holds the mappings of
                                    properties from the data object class to the calling view. The
                                    properties for the calling view may be informational display
                                    properties, hidden properties, or even other displayed field
                                    properties</para>
              </listitem>
              <listitem>
                <para>additionalCriteria – A map that holds additional criteria for
                                    the query.</para>
              </listitem>
            </itemizedlist>
          </listitem>
          <listitem>
            <para>A field query is configured for an input field using the <emphasis role="keyword">fieldAttributeQuery</emphasis> property</para>
          </listitem>
          <listitem>
            <para>An attribute query can be configured to invoke a custom method that
                            will perform the query (such as a service method). The basic steps for
                            doing so are:</para>
            <itemizedlist>
              <listitem>
                <para>Set <emphasis role="keyword">queryMethodToCall</emphasis>
                                    property to the name of the method that should be invoked (by
                                    default this is assumed to be on the ViewHelperService
                                    implementation, for methods on other classes the <emphasis role="keyword">queryMethodInvokerConfig</emphasis> property can
                                    be configured)</para>
              </listitem>
              <listitem>
                <para>Specify the method argument mapping with the <emphasis role="keyword">queryMethodArgumentFieldList</emphasis>
                                    property. This takes a list of properties on the view that will
                                    map to method arguments in the order listed</para>
              </listitem>
              <listitem>
                <para>Finally, as in the case of the automatic query, configure the <emphasis role="keyword">returnFieldMapping</emphasis> property
                                    to map properties from the returned data object to properties on
                                    the view</para>
              </listitem>
            </itemizedlist>
          </listitem>
          <listitem>
            <para>The <emphasis role="keyword">Suggest</emphasis> widget performs an attribute query to
              show the user valid options as they are inputting a value. The widget is configured
              for an input field using the field's <emphasis role="keyword">suggest</emphasis> property</para>
          </listitem>
          <listitem>
            <para>The query for a field's Suggest widget is completed in a similar manner to the
              field attribute query, the only difference being the property return. Instead of
              expecting one data object record to be returned (from which multiple property values
              can be picked), the query can return one or more records, from which we only care
              about one property (the property that is associated with the field's property)</para>
          </listitem>
          <listitem>
            <para>To configure the property on the returned data objects that maps to
                            the input field we set <emphasis role="keyword">valuePropertyName</emphasis></para>
          </listitem>
          <listitem>
            <para>Query results can be sorted by setting the <emphasis role="keyword">sortPropertyNames</emphasis> property to the list of properties the sort should be
              performed on (note only ascending sort is supported at this time)</para>
          </listitem>
        </itemizedlist>
            </para>
    </section>
  </section>
  <section>
    <title>Other Data and Input Field Properties </title>
    <para>You have likely realized by now the data and input field components are very busy! But
            we are not done yet. There are a few more properties that can be used with these
            components:</para>
    <para>readOnlyHidden – A Boolean property that indicates the value for the field should be
      written out as a hidden when the field's state is read only. This is useful for cases where
      the user is not allowed to change the value, but the value can be changed with script and thus
      needs to be posted with the form to update the value server side.</para>
    <para>hiddenPropertyNames – Specifies a list of property names whose values should be rendered
      as hidden elements with the field. Each property specified will produce a hidden element. A
      common use case of this is a field that does not hold the primary key (name or alternate key)
      and thus we want to keep the primary key as a hidden. These hidden property names can be
      populated from a lookup return or a field query. The user control discussed earlier uses this
      functionality. The principal name is given in the text control and the principal id is a
      hidden. When a query or lookup is performed, the name will display in the control and the
      hidden id will be populated. Therefore on submit the primary key field will be populated on
      the model.</para>
    <para>escapeHtmlInPropertyValue – A Boolean that indicates whether HTML markup should be
            escaped from the display property value. If HTML (or XML) content needs to be displayed
            in the value and not interrupted when rendering the page, this property should be set to
            true.</para>
    <para>customValidatorClass, validCharactersConstraint, caseConstraint, dependencyConstraints,
      mustOccurConstraints, simpleConstraint (Input Field Only) – These are constraint properties
      that configure validation for the input field. These are interrupted to perform client side
      validation along with the ability to validate server side. Note these can also be inherited
      from an attribute definition. Chapter 4 covers each one of these constraint types.</para>
    <para>performUppercase (Input Field Only) – A Boolean that indicates whether the user inputted
      value should be uppercased. If set to true the value will be uppercased client side with the
      onblur event.</para>
    <section role="NotInToc">
      <title>Recap</title>
      <para>
                <itemizedlist>
          <listitem>
            <para>Data Fields support the following additional properties:<itemizedlist>
                <listitem>
                  <para><emphasis role="keyword">readOnlyHidden</emphasis> – Boolean
                                        that indicates the property value should be written out as a
                                        hidden in addition to being displayed when the field is
                                        read-only</para>
                </listitem>
                <listitem>
                  <para><emphasis role="keyword">escapeHtmlInPropertyValue</emphasis>
                                        – A Boolean that indicates whether HTML content (markup)
                                        within the property value should be escaped</para>
                </listitem>
                <listitem>
                  <para><emphasis role="keyword">customValidatorClass, validCharactersConstraint, caseConstraint, dependencyConstraints, mustOccurConstraints, simpleConstraint</emphasis> (Input Field Only) – These
                                        are constraint properties that configure validation for the
                                        input field</para>
                </listitem>
                <listitem>
                  <para><emphasis role="keyword">performUppercase</emphasis> (Input
                                        Field Only) – A Boolean that indicates whether the user
                                        inputted value should be uppercased</para>
                </listitem>
              </itemizedlist></para>
          </listitem>
        </itemizedlist>
            </para>
    </section>
  </section>
  <section>
    <title>Action and Action Field </title>
    <para>So far in this chapter we have looked at the data and input field components, which allow
      the user to perform data IO with our application. We will now move on to other types of
      content element and field components that are offered by KRAD. The field component behaves the
      same as it did before, essentially being a wrapper for the content element and providing a
      label. The various field implementations essentially provide convenience methods for setting
      properties on the nested element component. Therefore, we just need to focus on the different
      content elements available to us.</para>
    <para>The first element we will look at is the Action component. This component allows the user
      to take an action on the view, such as submitting the data, requesting a new page, or invoking
      a server side or client side process. There are a few different ways of representing the
      action in the UI to the user. The most common way is through an HTML button element (button
      tag). We can also choose to invoke the action with an image (HTML input element of type
      'image'). Finally, we can use a link to invoke the action (HTML a tag using script).</para>
    <para>In the UIF the action component is represented by the class
            org.kuali.rice.krad.uif.field.ActionField. This class contains properties that configure
            the action that will be taken when the component is invoked, along with the presentation
            of the action within the view.</para>
    <para>To configure the action that will be taken, we have two strategies possible. The first is
      to use standard form posting that will submit the form and make a server side call. These
      calls will get processed by the Spring MVC framework, which will invoke a class referred to as
      the Controller. In Chapter 12 we will cover the details for building controllers and other web
      layer artifacts, but for our purposes now we can think of this as a class with methods that
      get invoked to handle a request from the client. The request URL (which was constructed from
      the HTML form post URL) is used by Spring to determine the controller class to invoke.
      Therefore, on our individual action components, we just need to configure the controller
      method to call. This is done using the action component property methodToCall. The value given
      will be sent along with the action request and used by Spring to determine the controller
      method to invoke.</para>
    <para>The other possible
            action type is invoking a JavaScript method. This would be script developed by the
            application and included in the view. The script may then perform some client side
            operation and finish, or perform some operation and then in turn make a server call.
            When making the server call, the script would be responsible for setting the sever side
            method to call. Invoking client side script is done by setting the actionScript
            property. Note the value given for this property is assumed to be script code, and is
            bound with the onclick event for the corresponding HTML element.</para>
    <para>For example, we could give a value like p:actionScript="alert('Hello World!');" which
      would simply show the alert dialog and finish. We could also invoke a method that is defined
      in one of our included script files (through the view components additionalScriptFiles
      property): p:actionScript="doCalculateAndPost();". This would invoke a script method named
      'doCalculateAndPost'. Note multiple script statements can be given within the string: "var
      i=0;var j=1;doMethod(i,j);".</para>
    <para>Now that we know how to configure the action that will occur, how do we create the action
      component in XML, and specify how it will appear? Like all UIF components, we just need to
      know the base beans we can use, and then create a new bean that inherits from one. The
      following beans are provided for the action component:</para>
    <para>Uif-ActionImage – Action component that is configured for an image action. That is it will
      render an HTML input element of type 'image'. This bean sets the CSS style 'uif-actionImage'
      on the image element.</para>
    <para>Uif-PrimaryActionButton – Action component that is configured to render a button. The
      button element can include text (the label) along with an image. This bean adds the CSS style
      'uif-primaryActionButton' on the button element.</para>
    <para>Uif-SecondaryActionButton – Action component that is configured to render a button. This
      bean sets the CSS style 'uif-secondaryActionButton' on the button element.</para>
    <para>Uif-PrimaryActionButton-Small – Action component that is configured to render a button.
      This bean sets the CSS style 'uif-primaryActionButton' and 'uif-smallActionButton' on the
      button element.</para>
    <para>Uif-SecondaryActionButton-Small – Action component that is configured to render a button.
      This bean sets the CSS style 'uif-secondaryActionButton' and 'uif-smallActionButton' on the
      button element.</para>
    <para>Uif-ActionLink – Action component that is configured to render a link. The link may
      contain text and an image. This bean sets the CSS style 'uif-actionLink' on the link
      element.</para>
    <para>Note the four beans that render a button are the same with the exception of the style
      class. These four different style classes give the ability to have different button 'levels'
      that result in different 'weight' being applied to the button visually. For example a button
      the user is expected to use often should be given the primary level, while once used less
      often should be given a secondary level (thus it is easier for them to spot the former). Below
      the different button levels are shown. </para>
    <figure>
      <title>Button Levels</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="../images/KRAD_Guide/buttonLevels.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <note>
      <title>Button Rendering</title>
      <para> In addition to rendering the HTML button element, KRAD uses the jQuery Button plugin to
        add styling and behavior to the buttons. For more information on this plugin visit <link xlink:href="http://jqueryui.com/demos/button/">http://jqueryui.com/demos/button/</link>. </para>
    </note>
    <para>Let's look at some examples of creating buttons. Besides configuring the action, we
      generally want to display a label for the button (text that is display on the button). To do
      this we set the actionLabel property:</para>
    <programlisting>
&lt;bean parent="Uif-PrimaryActionButton" p:actionLabel="Save" p:methodToCall="performSave"/&gt;
        </programlisting>
    <para>In this example we have created an action button with the primary styling that will have a
      label of 'Save'. When the user clicks the button, the enclosing form will be submitted and a
      method named 'performSave' will be invoked on our controller. It's that easy!</para>
    <para>Along with the button label we can include an image icon. This is done by configuring an
      Image component that lives on the action component. The image component will be covered later
      on in this chapter, but we can create one by simply giving the path to the image using the
      source property on Image. The image component is nested on the action component with the
      actionImage property and we can create a new image component using the 'Uif-Image'
      bean:</para>
    <programlisting>
&lt;bean parent="Uif-PrimaryActionButton" p:actionLabel="Save"
    p:methodToCall="performSave"&gt;
    &lt;property name="actionImage"&gt;
        &lt;bean parent="Uif-Image" 
            p:source="@{#ConfigProperties[&apos;krad.externalizable.images.url&apos;]}searchicon.gif"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
        </programlisting>
    <para>Notice the use of the expression
      "#ConfigProperties[&apos;krad.externalizable.images.url&apos;]}" in the value for the source
      property. ConfigProperties is a variable available for all expressions which holds properties
      the Rice application has been configured with. This variable is a map type, where the key is
      the name of the configuration property, and the map value is the value for the configuration
      property. The Rice application comes with a set of configuration properties, one of which is
      the 'krad.externalizable.images.url' which points to the directory in the web app which
      contains the KRAD images. The definition of this configuration is:</para>
    <programlisting>
&lt;param name=&quot;krad.externalizable.images.url&quot;override=&quot;false&quot;&gt;${application.url}/krad/images/&lt;/param&gt;
        </programlisting>
    <para>This is referring to another configuration property named 'application.url' (which could
      refer to others). Ultimately this resolves to something like
      'https://test.kuali.org/kr-krad/krad/images'. This makes the source for our image
      'https://test.kuali.org/kr-krad/krad/images/searchicon.gif' which will be used by the browser
      to fetch the image contents. </para>
    <tip>
      <title>Configuration Properties:</title>
      <para>Note the configuration properties are fed from the various '-config' XML files
        configured with the application, including one that resides in the user home. You can add
        your own application properties and refer to them like above. Note as well applications can
        configure other mechanisms for picking up properties using the Rice configurers.</para>
    </tip>
    <para>By default, the image will display to the left of the label text in the button. We can
      change this to one of the other positions (top, right, bottom) by setting the <emphasis role="keyword">actionImagePlacement</emphasis> property:</para>
    <programlisting>
&lt;bean parent="Uif-PrimaryActionButton" p:actionLabel="Save" 
    p:methodToCall="performSave"&gt;
    &lt;property name="actionImage"&gt;
        &lt;bean parent="Uif-Image" 
            p:source="@{#ConfigProperties[&apos;krad.externalizable.images.url&apos;]}searchicon.gif"
            p:actionImagePlacement="RIGHT"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
        </programlisting>
    <para>The following Screen Shot is an example taken from the KRMS module which uses the
            images and buttons to create a toolbar.</para>
    <figure>
      <title>Buttons Toolbar</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="../images/KRAD_Guide/buttonsToolbar.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>To change our button to an image submit or a link, we just need to change the base
            bean:</para>
    <programlisting>
&lt;bean parent="Uif-ActionImage" p:methodToCall="performSave"&gt;
    &lt;property name="actionImage"&gt;
        &lt;bean parent="Uif-Image"
            p:source="@{#ConfigProperties[&apos;krad.externalizable.images.url&apos;]}searchicon.gif"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
        </programlisting>
    <para>Note since we are creating an image submit, an action label is not needed. Furthermore,
            the image placement is not relevant. This example is actually used by the Quickfinder
            widget and is shown below.</para>
    <figure>
      <title>Quickfinder Widget</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="../images/KRAD_Guide/quickFinderWidget.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>Finally, an action link is configured like:</para>
    <programlisting>&lt;bean parent="Uif-ActionLink" p:actionLabel="Do Script" p:actionScript="doYourAjax();"/&gt;</programlisting>
    <para> Which is shown below. </para>
    <figure>
      <title>Action Link</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="../images/KRAD_Guide/actionLink.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <section>
      <title>Action Even and Action Parameters</title>
      <para>Sometimes it can be useful to identify an action based on an event (functional, not
        technical such as onclick) that we can use to make decisions when the action is invoked. For
        example, one common action screens must have is the save operation. This is invoked to save
        the current data on the client to the server. Generally these are labeled as 'Save', but
        they don't have to be. For example the designer might choose to label the action 'Save
        Document', or 'Save Course'. Using the actionEvent property available on the Action
        component, we can configure all these buttons as invoking a 'save' event:</para>
      <programlisting>
&lt;bean parent="Uif-PrimaryActionButton" p:actionLabel="Save Document" p:methodToCall="saveDocument" p:actionEvent="save"/&gt; &#160;

&lt;bean parent="Uif-PrimaryActionButton" p:actionLabel="Save Course" p:methodToCall="saveCourse" p:actionEvent="save"/&gt;
            </programlisting>
      <para>When an action is invoked, the corresponding action event value will be passed as
                a request parameter along with the method to call. We can then inspect the request
                value (using the request object, or if our model extends UifFormBase it provides the
                property for us) and perform the logic associated with the event.</para>
      <para>So exactly what could we do with this? One good use is within the business rules
        framework (discussed in Chapter 13). Business rules are written to respond to an event (a
        rule event), thus the action event name can be mapped to a rule event. Action events can
        also be useful within the view rendering logic. For example, one use the UIF currently has
        is to determine when the add action has been taken for a collection. Since the button could
        be labeled differently between collections and views, the framework determines if the action
        requested was a collection 'add' by looking at the action event. It then sets up a script to
        perform highlighting on the added row once the component refreshes.</para>
      <para>Along with the method to call and action event parameters that are sent for an action,
        there are cases where we might need more information to complete a request. An example of
        this are actions that operate on a collection line. These actions are likely available for
        each line (for instance the delete button), so if we only invoke the deleteLine button or
        send in the 'delete' action event, how will we know which line(s) to delete? Furthermore, if
        there are multiple collections on the page, how will we know which collection? </para>
      <para>The framework allows us to specify additional request data that will be sent when an
        action is taken using the actionParameters property. This is a map type where the key
        specifies the name for the request parameter, and the map value the request parameter value.
        Let's assume we are configuring a button with a collection group (covered in next
        chapter):</para>
      <programlisting>
&lt;bean parent="Uif-PrimaryActionButton" p:actionLabel="delete" p:methodToCall="deleteAccount" 
      p:actionParameters="chart:@{#line.chartCode},account:@{#line.accountNumber}"/&gt;
            </programlisting>
      <para>Here we are using the shorthand map notation to setup two action parameters. The first
        will have name 'chart' and will be equal to the value for the chart code property on the
        current collection line (collections make the '#line' variables available that refers to the
        current line instance for which the component is being built). Likewise the second parameter
        will have name 'account' and will be equal to the value for the account number property on
        the current line.</para>
      <para>When the user takes the action and our controller method is invoked, we will have
        request parameters with names 'chart' and 'account' that we can use to determine which
        account data object instance we should delete. In Chapter 12 we will learn about a base form
        class our model can extend which does many things for us. Among these is providing a map
        property populated with the action parameter sent in the request, and a convenience method
        for getting the value of a parameter by name:</para>
      <programlisting>
public Map&lt;String, String&gt; getActionParameters();
public String getActionParamaterValue(String actionParameterName);
            </programlisting>
      <para>Thus in our controller method we can do the following:</para>
      <programlisting>
public ModelAndView deleteAccount(@ModelAttribute(&quot;KualiForm&quot;) UifFormBase
uifForm, BindingResult result, HttpServletRequest request, HttpServletResponse response) {
    AccountForm accountForm = (AccountForm) uifForm;
    String selectedChartCode = accountForm.getActionParamaterValue("chart");
    String selectedAccountNumber = accountForm.getActionParamaterValue("account");
    // delete account
    ...
}
            </programlisting>
      <para>Along with the action parameters we configure in XML, the framework will add parameters
        for us automatically in certain situations. For example, any action component within a
        collection group will receive a parameters 'selectedCollectionPath' and 'selectedLineIndex',
        which indicate the collection name and line index the action took place on.</para>
    </section>
    <section>
      <title>Field Focus and Anchoring</title>
      <para>An action component can occur anywhere in a view, including in the middle of page. In
        most cases after an action is taken the user wants to continue completing the form at the
        location the action took place (location of the button or link). In a page with lots of
        vertical scrolling, what we don't want to happen is after the user clicks a button in the
        middle of the page, they are pushed back to the top on refresh and have to scroll back down
        to their previous position. Therefore, we want to set anchor points that will be used when
        the page refreshes after the action.</para>
      <para>To set this up,
                the action component provides the jumpToIdAfterSubmit and jumpToNameAfterSubmit
                properties. We can specify one of these properties to set the anchor position. For
                the jump to id, we specify the id for a component on the view. This could be the
                button itself, a group (with a div element) or any other field. For example, on the
                following button we are specifying the page should scroll back to the button
                location on refresh:</para>
      <programlisting>
&lt;bean id="delete_button" parent="Uif-PrimaryActionButton" p:actionLabel="delete"
p:methodToCall="deleteAccount"
p:jumpToIdAfterSubmit="delete_button"/&gt;
            </programlisting>
      <para>If we want to scroll back to
                the location of a data or input field, we can specify the property name for the
                field using the jumpToNameAfterSubmit property:</para>
      <programlisting>
&lt;bean parent="Uif-PrimaryActionButton" p:actionLabel="delete"
p:methodToCall="deleteAccount"
p:jumpToIdAfterSubmit="newAccount.accountNumber"/&gt;
            </programlisting>
      <para>To scroll back to the top or bottom of the page, the keywords "TOP" or "BOTTOM" can be
        given for the jump to id:</para>
      <programlisting>
&lt;bean parent="Uif-PrimaryActionButton" p:actionLabel="Save" p:methodToCall="save" p:jumpToIdAfterSubmit="TOP"/&gt;
            </programlisting>
      <tip>
        <title>Anchoring and Partial Page Refreshes:</title>
        <para>KRAD supports refreshing parts of the page (components) for actions instead of always
          posting the full page. This is done with AJAX and replacing the DOM contents, therefore
          the user is never scrolled away from their current positions and setting an anchoring
          point is not necessary.</para>
      </tip>
      <para>In addition to anchoring, we might want to set focus to a particular field after
                an action is taken. The UIF includes an example of this in the collection group.
                After the add action is taken, the focus is set back to the first field on the
                collection add line.</para>
      <para>We can configure the focused component using the focusOnIdAfterSubmit property. This is
        the id of the field that should receive focus when the page (or component) refreshes. The
        keyword "FIRST" exists to set focus to the first visible input field control on the
        view:</para>
      <programlisting>
&lt;bean parent="Uif-PrimaryActionButton" p:actionLabel="Save" 
p:methodToCall="save" p:focusOnIdAfterSubmit="FIRST"/&gt;
            </programlisting>
    </section>
    <section>
      <title>Disabled</title>
      <para>One other property on the action component that deserves mentioning is the
                disabled property. This performs the same function as the disabled property on
                Control elements. When set to true, the button will not allow the user to take the
                associated action.</para>
      <para>Below shows two buttons.  The first is enabled and the second is disabled.</para>
      <figure>
        <title>Enabled and Disabled Buttons</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../images/KRAD_Guide/enabledAndDisabledButtons.png"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
    <section role="NotInToc">
      <title>Recap</title>
      <para>
                <itemizedlist>
          <listitem>
            <para>The Action component is a content element that allows the user to
                            perform an action, such as posting the form or performing a script
                            function</para>
          </listitem>
          <listitem>
            <para>Out of the box action components can be rendered as HTML button
                            elements, links, or image submit inputs</para>
          </listitem>
          <listitem>
            <para>Types of actions fall into two categories:</para>
            <itemizedlist>
              <listitem>
                <para>Server Requests – These are requests made to the server to perform an action.
                  In most cases this is part of a form submission, but can also be a get request.
                  When configuring a server request, the action property methodToCall must be given.
                  This is the name of the method on the controller class that should be invoked.
                  Mapping of URL is covered in Chapter 9</para>
              </listitem>
              <listitem>
                <para>Client Side Requests – These are requests that execute a piece of JavaScript
                  code (either a code block or function call). The script to execute is configured
                  using the action property actionScript. After the script is finished, it can
                  simply return or make a server request on behalf of the user</para>
              </listitem>
            </itemizedlist>
          </listitem>
          <listitem>
            <para>The label for an action is specified using the actionLabel
                            property</para>
          </listitem>
          <listitem>
            <para>An action button is built using one of the following parent beans:
              'Uif-PrimaryActionButton', 'Uif-SecondaryActionButton',
              'Uif-PrimaryActionButton-Small', or 'Uif-SecondaryActionButton-Small'. The difference
              between these four beans is in the styling to indicate four different levels of
              buttons</para>
          </listitem>
          <listitem>
            <para>An action link is built using the bean parent 'Uif-ActionLink'</para>
          </listitem>
          <listitem>
            <para>An action image is built using the bean parent 'Uif-ActionImage'</para>
          </listitem>
          <listitem>
            <para>Using the #ConfigProperties EL variable is convenient for configuring
                            image paths</para>
          </listitem>
          <listitem>
            <para>In addition to displaying the action label, button and link actions
                            can display an image. The image is configured using the actionImage
                            property</para>
          </listitem>
          <listitem>
            <para>By default an image configured for a button displays to the left of
                            the label, however its position can be changed to TOP, RIGHT, or BOTTOM
                            by setting the property actionImagePlacement (to be renamed to
                            actionImagePosition)</para>
          </listitem>
          <listitem>
            <para>Actions that perform common server side actions (such as the save
                            operation) but might have different labels can be associated with an
                            action event. This is configured using the actionEvent property</para>
          </listitem>
          <listitem>
            <para>Action events give the ability to determine the type of action
                            requested without relying on a label</para>
          </listitem>
          <listitem>
            <para>In certain cases an action needs to send additional parameters that clarify the
              action request. For example collection line actions need to send the collection for
              which the action was chosen, and also the line number</para>
          </listitem>
          <listitem>
            <para>Parameters for actions are built using the actionParameters map. The
                            map key is the name of the parameter that will be sent when the action
                            is selected, and the value is the parameter value that will be
                            submitted</para>
          </listitem>
          <listitem>
            <para>Action parameters can be configured in XML (or added through code). In
                            addition the framework will automatically add parameters in certain
                            situations (for example actions configured for a collection line will
                            get the collection name and line index)</para>
          </listitem>
          <listitem>
            <para>Action parameters can easily be retrieved from a controller method by
                            calling the form method getActionParamaterValue(String
                            actionParameterName)</para>
          </listitem>
          <listitem>
            <para>The EL variable #line refers to the collection line data object the
                            field is being rendered for</para>
          </listitem>
          <listitem>
            <para>Action components support configuring a focus element or anchor
                            element for the page refresh</para>
          </listitem>
          <listitem>
            <para>For setting an anchor point, the properties jumpToIdAfterSubmit or
                            jumpToNameAfterSubmit can be used</para>
          </listitem>
          <listitem>
            <para>The keywords 'TOP' and 'BOTTOM' can be used for the jumpToIdAfterSubmit
              property</para>
          </listitem>
          <listitem>
            <para>The element to focus on after a refresh is configured using the
              focusOnIdAfterSubmit property</para>
          </listitem>
          <listitem>
            <para>Like controls, actions can be disabled by setting the disabled
                            property</para>
          </listitem>
          <listitem>
            <para>Some more properties have been added to the action component which are hooks that
            provide more flexibility to the user <itemizedlist>
                <listitem>
                  <para>preSubmitCall – This property is a script which needs to be invoked before the form is submitted. The script should
                  return a boolean indicating if the form should be submitted or not. </para>
                </listitem>
                <listitem>
                  <para>ajaxSubmit – boolean property which indicates if the data is to be submitted via ajax or
                  otherwise </para>
                </listitem>
                <listitem>
                  <para>successCallback – This property is a script which will be invoked for successful ajax calls </para>
                </listitem>
                <listitem>
                  <para>errorCallback – script which will be invoked on error in ajax calls </para>
                </listitem>
              </itemizedlist></para>
          </listitem>
        </itemizedlist>
            </para>
    </section>
  </section>
  <section>
    <title>Space and Space Field </title>
    <para>Now for an easy one! One HTML entity that is useful for layout purposes is '&amp;nbsp;' (a
      space). To create a space, we use the Space component. This component has no properties, and
      simply renders the '&amp;nbsp;' element. When putting together multiple content elements in a
      group, the space component can be used to adjust the padding between each. To create a space
      component, we specify a bean with parent of 'Uif-Space':</para>
    <programlisting>
&lt;bean parent="Uif-Space"/&gt;
        </programlisting>
    <para>Likewise the space field exists which wraps the space entity in a span. This can be used
      for rendering empty 'blocks' in the layout. To create a space field, we specify a bean with
      parent of 'Uif-SpaceField':</para>
    <programlisting>
&lt;bean parent="Uif-SpaceField"/&gt;
        </programlisting>
    <section role="NotInToc">
      <title>Recap</title>
      <para>
                <itemizedlist>
          <listitem>
            <para>The Space component can be used to render the HTML &amp;nbsp;
                            entity</para>
          </listitem>
          <listitem>
            <para>The Space Field component can be used to render a span with a space. This is
              useful for creating blank 'slots' in a layout</para>
          </listitem>
        </itemizedlist>
            </para>
    </section>
  </section>
  <section>
    <title>ValidationMessages content element </title>
    <para>The ValidationMessages component is used to display
            validation errors and other types of messages to the user. This is the general mechanism
            by which the application communicates to the user about the success or failure of an
            action.</para>
    <para>A ValidationMessages element is different in many ways from the previous components we
      have looked at. First, we don't generally create new errors field components like we do data,
      input, and action fields. Instead, these components are already constructed as properties of a
      container (both the View and Group) and an Input Field. Therefore, all we need to do is
      configure them as needed.</para>
    <para>In the next chapter we will learn about group nesting and how we form the conceptual
      groupings of the view: a page, section, sub-section, and field group. Each of these groups
      contains a ValidationMessages element that displays by default under the group header. It is
      important to understand these group 'levels' when configuring the associated
      ValidationMessages (although the framework attempts to set reasonable defaults out of the
      box). A ValidationMessages element is also included for an Input field by default. This is for
      handling individual field level messages from the server and messages from the client side
      validation.</para>
    <para>Important - even though ValidationMessages are configured at the group level, validation
      messages displayed to the user are only ever shown on the screen for what we consider
      &quot;Sections&quot;. Sections are essentially groups that have a header. If a group does not
      have a header, it displays its messages at the next available section. When no sections are
      present, messages are displayed at the &quot;Page&quot; level. Thus configuring a
      ValidationMessages element for a group without a header will result in no effect. Exception:
      for the PageGroup case - if no header is defined, the framework will still show the messages
      at this level. In addition to this, ValidationMessages for fields can only ever be configured
      for InputFields - because other fields do not allow user input.</para>
    <para>In order to understand how to configure a ValidationMessages element, we need to
      understand how messages are added during application processing. To collect messages for a
      request, KRAD provides the class org.kuali.rice.krad.util.MessageMap. This collects messages
      of type Error, Warning, and Info. At the beginning of each request, a new message map is
      constructed and made available through the org.kuali.rice.krad.util.GlobalVariables class as a
      static method. Therefore application code can get a handle on the message map by calling
      GlobalVariables.getMessageMap(). This means the message map does not have to be passed through
      all the application methods (made possible because the message map is attached to the current
      thread).</para>
    <para>When adding a message to the message map, there are three pieces of data we can specify.
      The first tells the framework what property or container the message is associated with.
      Associating the message allows the framework to give a better indication of the source of the
      error when rendering the page. When associating a message with a group or field, we need to
      give the id for the component. A message for an Input field can also be associated by property
      name, but we need to give the full property path of this field (as is done for binding). To
      display a general message at the page level that doesn't relate to your current page content,
      the present keywords of 'GLOBAL_ERRORS', 'GLOBAL_WARNINGS', and 'GLOBAL_INFO' exist for each
      of the message types.</para>
    <para>The second piece of data we need to give is the property key for the message. In order to
      support customizations and internalization, all messages are externalized from the code
      through a resource bundle. In the current version of Rice, these messages are configured in
      property files, with one being KRADApplicationResources.properties. </para>
    <para>We need to provide the key of the resource and the framework will resolve the actual
      message. The final piece (not always necessary) is any arguments that are necessary for the
      message. With the use of placeholders ('{0}', '{1}', '{2}'), we can have variables in our
      message that get replaced by the runtime data. If the message contains one or more variables,
      the value for each must be given when adding the message. </para>
    <para>To add a message to the message map, we can use one of the following methods based on
            the type of message we want to add and how we want it associated (property or
            component):</para>
    <programlisting>
public AutoPopulatingList&lt;ErrorMessage&gt; putError(String propertyName, String errorKey, String... errorParameters);

public AutoPopulatingList&lt;ErrorMessage&gt; putWarning(String propertyName, String messageKey, String... messageParameters);

public AutoPopulatingList&lt;ErrorMessage&gt; putInfo(String propertyName, String messageKey, String... messageParameters);

public AutoPopulatingList&lt;ErrorMessage&gt; putErrorForSectionId(String sectionId, String errorKey, String... errorParameters);

public AutoPopulatingList&lt;ErrorMessage&gt; putWarningForSectionId(String sectionId, String messageKey, String... messageParameters);

public AutoPopulatingList&lt;ErrorMessage&gt; putInfoForSectionId(String sectionId, String messageKey, String... messageParameters);
        </programlisting>
    <para>Note even though the last three methods named include 'Section', they can be used for any
      UIF container.</para>
    <para>Let's take some examples. Suppose we have the following Group definition:</para>
    <programlisting>
&lt;bean id="BookDocumentOverview" parent="Uif-GridSection" p:title="Book Overview"&gt;
    &lt;property name="items"&gt;
        &lt;list&gt;
            &lt;bean parent="Uif-InputField" p:propertyName="bookId"/&gt;
            &lt;bean parent="Uif-InputField" p:propertyName="bookTitle"/&gt;
            &lt;bean parent="Uif-InputField" p:propertyName="author.name"/&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
        </programlisting>
    <para>Now we want to have a business rule that says the author name cannot be 'Anonymous'. First
      we add a message to our application resources (properties file):</para>
    <para>error.book.authorName.anonymous=Author name cannot be 'Anonymous'</para>
    <para>Next we write application code to check the rule (see 'Writing Business Rules' in Chapter
      13), and if the rule fails we add an error message associated with the author name
      property:</para>
    <programlisting>
if (isAnonymous) {
    GlobalVariables.getMessageMap().putError("author.name","error.book.authorName.anonymous");
}
        </programlisting>
    <para>Since our message did not have any variables, we only needed to pass the property name and
      message key. Note if there is a default binding object path on the view (or was added on the
      group), the property path for our field would be '{object path}.author.name'. The key we
      specify must then also include the object path. The message map allows for a similar concept
      of 'auto-prefixing' the path as is done in the UIF. We can make a call to the method
      addToErrorPath(String parentName) to specify a string that should prefix any message keys
      added from that point on. We can then call removeFromErrorPath(String parentName) to stop the
      prefixing. For example: </para>
    <programlisting>
GlobalVariables.getMessageMap().addToErrorPath("document.newBook");

//results in the full key of 'document.newBook.author.name'
GlobalVariables.getMessageMap().putError("author.name","error.book.authorName.anonymous");
// more validation 

GlobalVariables.getMessageMap().removeFromErrorPath("document.newBook");
        </programlisting>
    <para>This is useful when doing several validations on the same object. KRAD also takes
      advantage of this in certain places to automatically prefix the error paths. For example, in
      the document framework for events that take place on the document, it will add the prefix
      'document'.</para>
    <para>For one last example, let's assume we need to validate all three fields of the book
      overview group. Since this doesn't really tie to one property in particular, we will just
      associate the error with the section. This can be done as follows:</para>
    <programlisting>
if (missingFieldValue) {
    GlobalVariables.getMessageMap().putError("BookDocumentOverview","error.book.overview.misingFieldValue");
}
        </programlisting>
    <para>Ok, so now that we know a little bit about how messages are added, let's go back to
      configuring the ValidationMessages element.</para>
    <para>If we want to then match on additional keys, we can add those using the
<emphasis role="keyword"> additionalKeysToMatch</emphasis> property. This is a List type where each entry
      gives an additional property path or id to match on. Each one of these can be defined with a
      wildcard, as well. So if we wanted to also include any messages associated with the 'author'
      property path, we can do so as follows:</para>
    <programlisting>
&lt;bean id="BookDocumentOverview" parent="Uif-GridSection" p:title="Book Overview" 
p:errorsField.additionalKeysToMatch="author*"&gt;
    ...
        </programlisting>
    <para>The ValidationMessages object and its subclasses have several other properties we can configure which include:</para>
    <itemizedlist>
      <listitem>
        <para><emphasis role="keyword">displayMessages (All levels)</emphasis> – If true, error, warning, and info messages will be displayed at this level. Otherwise, no messages for this
ValidationMessages element will be displayed.
This is a global display on/off switch for all messages.</para>
        <para>Other ValidationMessages elements of the screen react to the display flag being turned
          off at certain levels: if display is off for an Input field, the next level up will
          display that field's full uncollapsed message text; and if display is off at a section,
          the next section up will display those messages nested in a sublist.</para>
      </listitem>
      <listitem>
        <para><emphasis role="keyword">displayFieldLabelWithMessages (GroupValidationMessage level)</emphasis> – Boolean that indicates whether the field label should be displayed
          with messages that are associated with a field in the Section level summary. When set to
          true, the message will be displayed as '{Field Label} – {Message}'. For example: 'Book
          Title – Must not be longer than 50 characters.'.</para>
      </listitem>
      <listitem>
        <para><emphasis role="keyword">collapseAdditionalFieldLinkMessages (GroupValidationMessage level)</emphasis> – When collapseAdditionalFieldLinkMessages is set to true, the
          messages generated on field links will be summarized to limit the space they take up with
          an appendage similar to how [+n message type] is appended for additional messages that are
          omitted. When this flag is false, all messages will be part of the link separated by a
          comma.</para>
      </listitem>
      <listitem>
        <para><emphasis role="keyword">useTooltip (FieldValidationMessage level) </emphasis> – When
          true, use the tooltip on fields to display their relevant messages. When false, these
          messages will appear directly below the control. </para>
      </listitem>
    </itemizedlist>
    <para>Below shows ValidationMessages for various elements of a page which are configured with the default settings and displaying multiple errors:</para>
    <para><figure>
        <title>ValidationMessages for a Page</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../images/KRAD_Guide/page_errors.png" align="center"/>
          </imageobject>
        </mediaobject>
      </figure></para>
    <figure>
      <title>ValidationMessages for a Section</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="../images/KRAD_Guide/section_errors.png" align="center" scalefit="1"/>
        </imageobject>
      </mediaobject>
    </figure>
    <figure>
      <title>ValidationMessages for an InputField</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="../images/KRAD_Guide/field_error.png" align="center"/>
        </imageobject>
      </mediaobject>
    </figure>
<!-- TODO: Add content here
        <note>
            <title>Errors Field Refactoring for Acessibility</title>
            <para>For the 2.2 release the KRAD team will be doing some refactoring on error display to improve 
                accessibility. For the most part things will remain the same; however there will be some added 
                features such as linked from the message to a field, and the use of tooltips to display field 
                level errors</para>
        </note>
        -->    <section role="NotInToc">
      <title>Recap</title>
      <para>
                <itemizedlist>
          <listitem>
            <para>The ValidationMessages component displays validation messages and other
                            information as part of a request/response.</para>
          </listitem>
          <listitem>
            <para>ValidationMessages only really apply to 3 levels: Page, Section (any group with a header), and InputFields.</para>
          </listitem>
          <listitem>
            <para>Groups can be nested to form conceptual groupings of the view such as page,
              section, sub-section, and field groups. Thus we might want to configure the associated
              errors field depending on the grouping 'level'.</para>
          </listitem>
          <listitem>
            <para>There are three types of messages that can be displayed: error,
                            warning, and info.</para>
          </listitem>
          <listitem>
            <para>In application code, messages for each request are collected by a messageMap
              instance.</para>
          </listitem>
          <listitem>
            <para>To add a message we need to specify three arguments. The first part is
                            the property path or component id the message should be associated with.
                            The second part is the key for the message in the resource bundle, and
                            the final part is any arguments for the message (message
                            variables).</para>
          </listitem>
          <listitem>
            <para>We can add messages to the message map by first getting the instance with
              GlobalVariables, then using one of the provided 'put' methods.</para>
          </listitem>
          <listitem>
            <para>For ValidationMessages associated with a container or input field, the
                            framework takes care of automatically adding the component id or
                            property path to the list of matchable keys.</para>
          </listitem>
          <listitem>
            <para>We can configure additional paths or ids to be matched on and displayed for that ValidationMessage level by using the
<emphasis role="keyword"> additionalKeysToMatch</emphasis> property.</para>
          </listitem>
          <listitem>
            <para>We can configure which areas to display messages at, and the framework will
              automatically determine where the next available area is to display this message. So a
              message should never be lost unless display is off for all levels.</para>
          </listitem>
          <listitem>
            <para>The <emphasis role="keyword">displayFieldLabelWithMessages</emphasis> property determines if field label&apos;s should be prepended to messages matched to fields at the section level.</para>
          </listitem>
          <listitem>
            <para>The <emphasis role="keyword">collapseAdditionalFieldLinkMessages</emphasis> property determines if the additional messages beyond the first message associated with a field should be summarized at the section level.</para>
          </listitem>
          <listitem>
            <para>The <emphasis role="keyword">useTooltip</emphasis> property determines if the tooltip
              should be used to display messages at the field level.</para>
          </listitem>
        </itemizedlist>
            </para>
    </section>
  </section>
  <section>
    <title>Generic Field </title>
    <para>So KRAD will do everything for you and you will never have to write a FreeMarker template
      right? In most likelihood, no! Although the UIF is extremely flexible, being about to cover
      everything a visual designer can come up with is not practical. KRAD is meant to provide those
      common components that are generally applicable, and allowing Rice applications to extend
      where needed. </para>
    <para>When a gap is found, there are two routes that can be taken. One is that the application
      can fill the gap by creating the component themselves (and possibly contributing back). In
      Chapter 5 we learned the general guidelines for doing so. However, creating a new component
      might be overkill in some situations. For example, we might need to add something that is
      really very specific to the use case, and it is unlikely other places in the application (or
      other applications) will find it useful. In these cases, we really just want to get the job
      done and not spend extra time making it 'generic'. </para>
    <para>KRAD allows this to be done by creating custom templates. These templates are not for
      rendering a KRAD component, but instead a hook to implement any logic required. However, we
      still need to hook these custom files into the view processing, so that they are invoked and
      rendered in the correct place. One way we can do this is by using the
      org.kuali.rice.krad.uif.field.GenericField component. The generic field has no custom
      properties associated with it, nor does it have a default template. It does, however, contain
      the inherited component and field base properties such as id, style, label, and so on. This
      gives you the ability to write a custom FreeMarker template that will act as a field.</para>
    <para>Since there is no template provided by default, we must create one before using the
      generic field. Unlike other component templates, there are really no rules to follow here;
      this can contain any content we like. Let's assume we have created a FreeMarker file named
      'bookQuestionnaire' in one of our application web folders named '/myapp/ftl':</para>
    <programlisting>&lt;#macro bookQuestionaire field&gt;
  &lt;ul&gt;
      &lt;li&gt;What is your favorite book? &lt;form:input path="questionnaire.favoriteBook"/&gt;&lt;/li&gt;
      &lt;li&gt;What many books do you read a month? &lt;form:input path="questionnaire.booksPerMonth"/&gt;&lt;/li&gt;
      &lt;li&gt;Do you wish you could read more? &lt;form:input path="questionnaire.readMoreIndicator"/&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/#macro&gt;        </programlisting>
    <para>To create a generic field with this FreeMarker file, we create a new bean with parent of
      'Uif-CustomTemplateField' and set the template and template name properties:</para>
    <programlisting>
&lt;bean parent="Uif-CustomTemplateField" p:template="/myapp/ftl/bookQuestionnaire.ftl" p:templateName=&quot;bookQuestionaire&quot;/&gt;
        </programlisting>
    <para>If needed in multiple places, we can create a top level bean with an id:</para>
    <programlisting>
&lt;bean id="BookQuestionnaire" parent="Uif-CustomTemplateField" p:template="/myapp/ftl/bookQuestionnaire.ftl" 
      p:templateName=&quot;bookQuestionaire&quot;/&gt;</programlisting>
    <para>In this way, we can add as many custom templates as needed.</para>
    <para>It is also possible to parameterize our custom template using the templateOptions map
            property (recall this is provided by ComponentBase). For example, if we wanted a
            parameter to determine whether or not we ask the third question, we could do so as
            follows:</para>
    <programlisting>&lt;#macro bookQuestionaire field&gt;
  &lt;#local askReadMore=field.templateOptions[&apos;askReadMore&apos;]/&gt;
  &lt;ul&gt;
      &lt;li&gt;What is your favorite book? &lt;form:input path="questionnaire.favoriteBook"/&gt;&lt;/li&gt;
      &lt;li&gt;How many books do you read a month? &lt;form:input path="questionnaire.booksPerMonth"/&gt;&lt;/li&gt;
          &lt;#if askReadMore&gt;
              &lt;li&gt;Do you wish you could read more? &lt;@spring.input path="questionnaire.readMoreIndicator"/&gt;&lt;/li&gt;
          &lt;/#if&gt;
  &lt;/ul&gt;
&lt;/#macro&gt;        </programlisting>
    <para>Now to specify the variable setting, our bean will be:</para>
    <para>// TODO: need bean example here</para>
    <tip>
      <title>Disadvantages of Generic Fields</title>
      <para>A couple of things should be noted when building a generic field. First, since we don't
        have actual input field components for any included input macros (or other form macros), we
        don't get certain features such as custom property editors, default values, and so on.
        Another route to take for custom templates is to use a Group (with all the fields
        configured) and write a custom template. The custom template can then render a custom
        layout, add additional markup or whatever else is necessary, and invoke the template tag to
        render the individual fields.</para>
    </tip>
    <section role="NotInToc">
      <title>Recap</title>
      <para>
                <itemizedlist>
          <listitem>
            <para>The Generic field component allows a custom FreeMarker template to be created and
              act as a field to the framework</para>
          </listitem>
          <listitem>
            <para>The custom template can reside anywhere in the web module and may
                            contain any content</para>
          </listitem>
          <listitem>
            <para>Generic field components can be created with a bean with parent
              'Uif-CustomTemplateField'</para>
          </listitem>
          <listitem>
            <para>Custom templates can have variables that are passed using the
                            templateOptions map proper</para>
          </listitem>
          <listitem>
            <para>Another way to implement custom templates is by configuring a group (with field
              items) that uses the custom template. The template can then render a custom layout and
              other markup, then invoke the template tag to render each field</para>
          </listitem>
        </itemizedlist>
            </para>
    </section>
  </section>
  <section>
    <title>Iframe </title>
    <para>Although not needed as much these days with the capability of modern web applications,
            KRAD nonetheless provides the Iframe component for generating the HTML Iframe element.
            Iframes are inline frames that can be used to embed another document (including
            cross-site).</para>
    <para>To create an iframe component, we need to create a new bean with parent of 'Uif-Iframe'.
      The only required property is the source property, which is the URL (relative or full) for the
      document that should be embedded.</para>
    <para>For example, we can include the kuali.org webpage in our view as follows:</para>
    <programlisting>
&lt;bean parent=&quot;Uif-Iframe&quot; p:width=&quot;800px&quot; p:height=&quot;550px&quot; p:source=&quot;http://www.kuali.org&quot;/&gt;
        </programlisting>
    <para>Notice here we are also setting the width and height properties which are available on
            the iframe component. This size the frame to the given dimensions.</para>
    <para>The iframe component also provides a property named frameborder which can be used to
            provide a size for a border around the frame. As is the case with all components, we
            have the standard properties such as id, title, and styleClasses that can be set as
            well.</para>
    <section role="NotInToc">
      <title>Recap</title>
      <para>
                <itemizedlist>
          <listitem>
            <para>KRAD provides the iframe component for generating the html iframe
                            elements</para>
          </listitem>
          <listitem>
            <para>Iframes can be used to embed other documents into the view</para>
          </listitem>
          <listitem>
            <para>We create an iframe component with a bean whose parent is 'Uif-Iframe'</para>
          </listitem>
          <listitem>
            <para>When creating an iframe component we must set the source property
                            which gives the relative or full URL to the document that should be
                            embedded</para>
          </listitem>
          <listitem>
            <para>We can restrict the size of the displayed frame using the width and
                            height properties</para>
          </listitem>
        </itemizedlist>
            </para>
    </section>
  </section>
  <section>
    <title>Image and Image Field </title>
    <para>Moving along with the field and content element types, we find the Image and Image Field
      components. Have a guess as to what these components render? Correct! They render the HTML img
      tag. Note the Image component is used to render a static image on the page (not one that can
      be used to generate an action; however script can be added to the image component if
      desired).</para>
    <para>To use an image component we create a bean with parent of 'Uif-Image'. The image component
      requires the <emphasis role="keyword">source</emphasis> property to be specified which is the
      relative or full URL to the image. If we wish to wrap our image in a span and potentially also
      have a label, we can use the Image Field component which has base bean name 'Uif-ImageField'.
      For example:</para>
    <programlisting>
&lt;bean parent=&quot;Uif-ImageField&quot; p:label=&quot;Image field with alt text&quot; p:altText=&quot;pdf 
image&quot; p:source=&quot;@{#ConfigProperties[&apos;krad.externalizable.images.url&apos;]}pdf.png&quot;/&gt;
        </programlisting>
    <para>Here we are bringing in the pdf.png image with the source property. Recall earlier we
      discussed the #ConfigProperties expression variable we can use to retrieve configuration
            parameters. Note also we are setting a property name <emphasis role="keyword">altText</emphasis>.
      This is text that will display if the image cannot be rendered, and it is a good practice to
      always set this.</para>
    <para>Below shows the result of the above configuration.</para>
    <figure>
      <title>Image with alt Text</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="../images/KRAD_Guide/imageAltText.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>There are additional messages we can configure to display with the Image component.
            These are known as the caption header and cutline text (traditional newspaper terms). To
            specify caption header text we use the captionHeaderText property. We can choose to have
            the caption display above or below the image by setting the captionHeaderPlacementAboveImage
            Boolean (defaults to true in base bean). Cutline text gives a summary of the image
            contents and is specified using the cutlineText property. Here is an example of using
            these properties:</para>
    <programlisting>
&lt;bean parent=&quot;Uif-Image&quot; p:altText=&quot;computer programming&quot;&#160;&#160; 
    p:captionHeaderText=&quot;Image Caption Text&quot; p:cutlineText=&quot;Image cutline text 
    here&quot; p:styleClasses=&quot;kr-photo&quot; p:source=&quot;computer_programming.jpg&quot;/&gt;
        </programlisting>
    <para>Notice here we are also setting the styleClasses property, which you will see in the
            next screen shot gives rounded borders to our image.</para>
    <para>The above configuration results in the following.</para>
    <figure>
      <title>Image with Cutline Text</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="../images/KRAD_Guide/imageCutlineText.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>Along with the caption and cutline string properties, the image component contains a
            nested Header and Message Field component corresponding to each. These nested components
            can be used to adjust the styling applied along with other configuration (such as
            possible the header level). </para>
    <section role="NotInToc">
      <title>Recap</title>
      <para>
                <itemizedlist>
          <listitem>
            <para>HTML Images can be rendered using the image or image field
                            components</para>
          </listitem>
          <listitem>
            <para>We create image components with beans with parent of 'Uif-Image'</para>
          </listitem>
          <listitem>
            <para>The <emphasis role="keyword">source</emphasis> property specifies the
                            relative or full URL to the image</para>
          </listitem>
          <listitem>
            <para>The <emphasis role="keyword">altText</emphasis> property is text that
                            will display when the image cannot be rendered</para>
          </listitem>
          <listitem>
            <para>We can add a caption to our image using the <emphasis role="keyword">captionHeaderText</emphasis> property. The caption can be rendered
              above or below the image by setting the <emphasis role="keyword">captionHeaderPlacementAboveImage</emphasis> property</para>
          </listitem>
          <listitem>
            <para>Finally we can add a summary of our image using the <emphasis role="keyword">cutlineText</emphasis> property. By default the cutline
                            text displays underneath the image</para>
          </listitem>
        </itemizedlist>
            </para>
    </section>
  </section>
  <section xml:id="linkAndLinkField">
    <title>Link and Link Field </title>
    <para>The Link and Link Field components are used to generate the HTML a (link) tag. The a
            tag is used to link to another document (the primary mechanism of navigation in the
            web). The link is presented to use by a label, which when clicked on will take the user
            to the linked page.</para>
    <para>To create a link component, we create a bean with parent of 'Uif-Link'. We configure the
      linked source using the hrefText property. As is the case for all URL resources, we can
      specify a relative or full URL. The label for the link (what the user will see) is given by
      the linkLabel property.</para>
    <para>For an example let's build a link to the kuali.org website that displays the text 'Kuali
      Website' to the user. In the XML this will be:</para>
    <programlisting>
&lt;bean parent="Uif-Link" p:hrefText="www.kuali.org" p:linkLabel="Kuali Website"/&gt;
        </programlisting>
    <para>Below shows the resulting link.</para>
    <figure>
      <title>Link Component Example</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="../images/KRAD_Guide/linkComponentExample.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>When using a link component we can also choose the frame target the linked document
            will open up in. This is done by setting the <emphasis role="keyword">target</emphasis>
            property and is used to populate the target attribute on the corresponding element.
            Possible values are:
      <literallayout>    _blank - Opens the linked document in a new window or tab</literallayout>
      <literallayout>    _self - Opens the linked document in the same frame as it was clicked (this is default)</literallayout>
      <literallayout>    _parent - Opens the linked document in the parent frame</literallayout>
      <literallayout>    _top - Opens the linked document in the full body of the window</literallayout>
    </para>
    <para>By setting the <emphasis role="keyword">lightBox</emphasis> property to &quot;Uif-LightBox&quot;, the link will be opened
      in a lightbox.</para>
    <programlisting>
      &lt;bean parent="Uif-Link" p:hrefText="www.kuali.org"&#160; p:linkLabel="Kuali Website"/&gt;
        &lt;property name="lightBox"&gt;
          &lt;bean parent="Uif-LightBox"/&gt;
        &lt;/property&gt;
      &lt;/bean&gt;
    </programlisting>
    <para>If we want to put a link in a field, we can use the Link Field component with base bean
      name 'Uif-LinkField'. All of the above properties are available along with the field's label
      property. </para>
    <section role="NotInToc">
      <title>Recap</title>
      <para>
                <itemizedlist>
          <listitem>
            <para>The link and link field components are used to render the html a
                            tag</para>
          </listitem>
          <listitem>
            <para>The html a tag provides a link to the user for navigating to another
                            page</para>
          </listitem>
          <listitem>
            <para>We create link components using a bean with parent of Uif-Link or
                            Uif-LinkField</para>
          </listitem>
          <listitem>
            <para>When building a link component, we specify the page that should be
                            linked using the <emphasis role="keyword">hrefText</emphasis> property.
                            This gives the relative or full URL to the page that should be
                            linked</para>
          </listitem>
          <listitem>
            <para>The link label is the text that displays to the user. This is set
                            using the <emphasis role="keyword">linkLabel</emphasis> property</para>
          </listitem>
          <listitem>
            <para>We can configure the frame for which the linked document will open in
                            using the <emphasis role="keyword">target</emphasis> property. Values given
                            include _blank (for new tab or window), _self (for same window), _parent
                            (for parent frame), or _top (for top level/window frame)</para>
          </listitem>
        </itemizedlist>
            </para>
    </section>
  </section>
  <section>
    <title>Message Field</title>
    <para>The last component we will look at in this chapter is the Message Field. In this case,
      there is no corresponding HTML element tag. Instead, the message field is used to render
      static text with the HTML markup.</para>
    <para>A message field can be specified anywhere in the view to provide a custom message to the
      user. To create a message field component, we create a bean with parent of 'Uif-MessageField'.
      The message field only has one custom property, the messageText. This is the text that will
      make up the message:</para>
    <programlisting>
&lt;bean parent=&quot;Uif-MessageField&quot; p:messageText=&quot;Message Field 1 Text&quot;/&gt;
&lt;bean parent=&quot;Uif-MessageField&quot; p:messageText=&quot;Message Field with expression text: &apos;@{field88}&apos;&quot;/&gt;
        </programlisting>
    <para>Notice in the second message field we are using an expression to print out the value for
      property 'field88'. Below shows the result</para>
    <figure>
      <title>Message Field</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="../images/KRAD_Guide/messageField.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>Over this chapter we have learned about various messages that can be configured as part of
      the components (for example, instructional and constraint text on the input field). We
      generally set these by using a String component property. However, the components also contain
      a MessageField component that can be used to change the default styling (or other properties)
      for the message rendering. The String properties are simply provided for convenience and,
      during the view processing, are copied to messageText property for the corresponding message
      field.</para>
    <section role="NotInToc">
      <title>Recap</title>
      <para>
                <itemizedlist>
          <listitem>
            <para>The message field component is used to generate static text</para>
          </listitem>
          <listitem>
            <para>We can create a message field component using a bean with parent of
              'Uif-MessageField'</para>
          </listitem>
          <listitem>
            <para>The text for the message is given with the <emphasis role="keyword">messageText</emphasis> property. the value can contain expressions
                            for dynamically building the message</para>
          </listitem>
        </itemizedlist>
            </para>
    </section>
  </section>
  <section>
    <title>Rich Message Content</title>
    <para>Rich message content refer to functionality available in various components (above) which accept text.  Rich message functionality allows textual components to be more robust by providing the power to use almost any KRAD component, html, image, link, or css inline with the rest of the text.</para>
    <para> To use rich message functionality, you just have to declare text with the appropriate tag
      enclosed in brackets "[]". This means that text that needs to use brackets in its content MUST
      use a backslash to escape that character in text properties that expect the use of rich
      message functionality (example, "\[" and "\]"). </para>
    <para> 

Rich message tags can be also be wrapped within other tags allowing for a variety of combinations.</para>
    <para>

The following areas allow rich message content described by this section:
</para>
    <itemizedlist>
      <listitem><para>Uif-Message component – messageText property</para></listitem>
      <listitem><para>Uif-Label component – labelText property</para></listitem>
      <listitem><para>Uif-InputField – label, instructionalText, and constraintText properties</para></listitem>
      <listitem><para>Uif-CheckboxControl - checkboxLabel</para></listitem>
      <listitem><para>Uif-KeyLabelPair (used by radio and checkbox groups 'options' property) – value
          property</para></listitem>
      <listitem><para>Uif-HeaderBase (and children) – headerText property (support to be added)</para></listitem>
      <listitem><para>Groups (Views, Pages, Sections) – instructionalText, and headerText (support to be added)
          properties. Any validation messages from the server or set up through message
          configuration (reduced scope no id or component index tag allowed) </para></listitem>
      <listitem><para>Anywhere the Message component is used</para></listitem>
    </itemizedlist>
    <para>The following KRAD rich message tags are supported (&lt; &gt; represents content to set):</para>
    <para><itemizedlist>
        <listitem><para>[<emphasis role="keyword">id</emphasis>=&lt;component id&gt; property1=value property2=value] - insert component with id specified at that location in the message. You can also set/override properties of the component referenced through by specifying those additional properties (must be separated by spaces). Textual properties must be wrapped in single quotes. </para></listitem>
        <listitem><para>[<emphasis role="keyword">n</emphasis>] - insert component at index n from the <emphasis role="keyword">inlineComponent</emphasis> list.</para></listitem>
        <listitem><para>[&lt;<emphasis role="keyword">html tag</emphasis> and properties&gt;][/&lt;html tag&gt;] - insert html content directly into the message content at that location, without the need to escape the &lt;&gt; characters in xml.</para></listitem>
        <listitem><para>[<emphasis role="keyword">color</emphasis>=&lt;html color code/name&gt;][/color] - wrap content in color tags to make text that color in the message. This is the same as wrapping the content in a span with color style set.</para></listitem>
        <listitem><para>[<emphasis role="keyword">css</emphasis>=&lt;css classes&gt;][/css] - apply css classes specified to the wrapped content . This is the same as wrapping the content in a span with the class property set.</para></listitem>
        <listitem><para>[<emphasis role="keyword">link</emphasis>=&lt;href src&gt;][/link] - an easy way to create an
            anchor that will open in a new page to the href specified. This is the same as wrapping
            the content in an a tag with the target set as "_blank".</para></listitem>
        <listitem>
          <para>[<emphasis role="keyword">action</emphasis>=&lt;action settings&gt; data=&lt;extra data&gt;][/action] - create an action link inline without having to specify a component by id or index. The options below MUST be in a comma separated list in the order specified.  Specify 1-4 always in this order – for example, options CANNOT be skipped if you would like to only set methodToCall  and ajaxSubmit, you must still set validateClientSide to its default value (note: this is parallel to how javascript functions with optional parameters are passed). </para>
          <para> The options (in order) are:</para>
          <itemizedlist>
            <listitem><para><emphasis role="keyword">methodToCall</emphasis>(String)</para></listitem>
            <listitem><para><emphasis role="keyword">validateClientSide</emphasis>(boolean) - true if not set</para></listitem>
            <listitem><para><emphasis role="keyword">ajaxSubmit</emphasis>(boolean) - true if not set</para></listitem>
            <listitem><para><emphasis role="keyword">successCallback</emphasis>(js function or function declaration) - this only works when ajaxSubmit is true</para></listitem>
          </itemizedlist>
          <para>The tag would look something like this:</para>
          <para> [action=<emphasis role="keyword">methodToCall</emphasis>]Action[/action] </para>
          <para>in most common cases. And in more complex cases: </para>
          <para>[action=<emphasis role="keyword">methodToCall,true,true,functionName</emphasis>]Action[/action].
</para>
          <para>In addition to these settings, you can also specify data to send to the server in this fashion (the space is REQUIRED between settings and data):
</para>
          <para>[action=&lt;action settings&gt; <emphasis role="keyword">data</emphasis><emphasis role="keyword">={key1: &apos;value 1&apos;, key2: value2}</emphasis>]</para>
        </listitem>
      </itemizedlist>
      <note><para>Reminder: If the [] characters are needed in message text, they need to be declared with a
          backslash escape character: "\[" and " \]"</para></note>
    </para>
    <section>
      <title>Component Rich Message Tags</title>
      <note><para>These component options cannot be used for validation messages.</para></note>
    <para>Component by id – this example gets the component named Demo-SampleMessageInput, defined elsewhere, by id:</para>
    <para><programlisting>&lt;bean parent=&quot;Uif-Message&quot;&gt;
          &lt;property name=&quot;messageText&quot;
                    value=&quot;Message getting component by id <emphasis role="keyword">[id=Demo-SampleMessageInput]</emphasis> inside its content&quot;/&gt;
        &lt;/bean&gt;</programlisting></para>
    <para>Component by index in the inlineComponents list - can only be used with components that
        have an inlineComponents property. These are Message, RadioControl, CheckboxesControl, and
        Label. In this example component 0 is the first item in the inlineComponents list
        (Uif-InputField) and component 1 is the second item (Uif-Link)</para>
    <programlisting>&lt;bean parent=&quot;Uif-Message&quot;&gt;
          &lt;property name=&quot;messageText&quot;
                    value=&quot;Message with input <emphasis role="keyword">[0]</emphasis> and link <emphasis role="keyword">[1]</emphasis> inline&quot;/&gt;
          <emphasis role="keyword">&lt;property name=&quot;inlineComponents&quot;&gt; &lt;list&gt; &lt;bean parent=&quot;Uif-InputField&quot; p:propertyName=&quot;field1&quot;/&gt; &lt;bean parent=&quot;Uif-Link&quot; p:href=&quot;http://www.kuali.org&quot; p:linkText=&quot;Kuali&quot;/&gt; &lt;/list&gt; &lt;/property&gt;</emphasis>
        &lt;/bean&gt;
</programlisting>
    <section>
      <title>Html, Color, and css Rich Message Tags</title>
      <para>Example that uses all 3 in one message (bold html tag, color for #F78C00 web color, and
          css to add the class 'fl-text-underline' around that content)</para>
      <programlisting>&lt;bean parent=&quot;Uif-Message&quot;&gt;
          &lt;property name=&quot;messageText&quot;
                    value=&quot;<emphasis role="keyword">[b]</emphasis>Message<emphasis role="keyword">[/b]</emphasis> using a <emphasis role="keyword">[color=#F78C00]</emphasis> <emphasis role="keyword">[css=&apos;fl-text-underline&apos;]</emphasis>combination<emphasis role="keyword">[/css]</emphasis> of different options<emphasis role="keyword">[/color]</emphasis>" /&gt;
</programlisting>
    </section>
    <section>
      <title>Link and Action Rich Message Tags</title>
      <para>Example of a link inline with message content</para>
      <programlisting>&lt;bean parent=&quot;Uif-Message&quot;&gt;
          &lt;property name=&quot;messageText&quot;
                    value=&quot;Testing link tag <emphasis role="keyword">[link=&apos;http://www.kuali.org&apos;]</emphasis>Link<emphasis role="keyword">[/link]</emphasis>&quot;/&gt;
        &lt;/bean&gt;</programlisting>
      <para>The main difference between link and action is that action calls a method on the
          controller – this mimics the KRAD Action component's functionality. Example of an action
          that calls the "addErrors" method on the controller:</para>
      <programlisting>&lt;bean parent=&quot;Uif-Message&quot;&gt;
          &lt;property name=&quot;messageText&quot;
                    value=&quot;Testing methodToCall action <emphasis role="keyword">[action=addErrors]</emphasis>Link Text<emphasis role="keyword">[/action]</emphasis>&quot;/&gt;
        &lt;/bean&gt;</programlisting>
      <para>Action that calls the "addErrors" method on the controller, turns off client-side
          validation, and passes an some extra data to the controller (extraInfo with value 'some
          data'):</para>
      <para><programlisting>&lt;bean parent=&quot;Uif-Message&quot;&gt;
          &lt;property name=&quot;messageText&quot;
                    value=&quot;Testing passing data [<emphasis role="keyword">action=addErrors,false data={extraInfo: &apos;some data&apos;}</emphasis>]
           addErrors[/action]&quot;/&gt;
        &lt;/bean&gt;</programlisting></para>
      <para>Action using all available options – calling method "addErrors", turning off client side
          validation, ajaxSubmit on, and on success calling the function specified (which shows an
          alert with "Successful Callback" in it):
          <programlisting>&lt;bean parent=&quot;Uif-Message&quot;&gt;
          &lt;property name=&quot;messageText&quot;
                    value=&quot;Testing custom success callback <emphasis role="keyword">[action=addErrors,false,true,function(){alert(&apos;Successful Callback&apos;)}]</emphasis>addErrors<emphasis role="keyword">[/action]</emphasis>&quot;/&gt;
        &lt;/bean&gt;
</programlisting></para>
    </section>
    <section>
      <title>Checkboxes and Radio Control Rich Message Usage</title>
    
    <para>Example showing usage in CheckboxesControl (RadioControl usage would be very similar):</para>
    <programlisting>…          
&lt;property name=&quot;control&quot;&gt;
            &lt;bean parent=&quot;Uif-VerticalCheckboxesControl&quot;&gt;
<emphasis role="keyword"> &lt;property name=&quot;inlineComponents&quot;&gt; &lt;list&gt; &lt;bean parent=&quot;Uif-InputField&quot; p:propertyName=&quot;field19&quot;/&gt; &lt;bean parent=&quot;Uif-InputField&quot; p:propertyName=&quot;field20&quot;/&gt; &lt;/list&gt; &lt;/property&gt;</emphasis>
              &lt;property name=&quot;options&quot;&gt;
                &lt;list&gt;
                  &lt;bean parent=&quot;Uif-KeyLabelPair&quot; p:key=&quot;1&quot; p:value=&quot;A website: <emphasis role="keyword">[0]</emphasis>&quot;/&gt;
                  &lt;bean parent=&quot;Uif-KeyLabelPair&quot; p:key=&quot;2&quot; p:value=&quot;A magazine: <emphasis role="keyword">[1]</emphasis>&quot;/&gt;
&lt;bean parent=&quot;Uif-KeyLabelPair&quot; p:key=&quot;3&quot; p:value=&quot;<emphasis role="keyword">[color=blue]</emphasis>A Friend<emphasis role="keyword">[/color]</emphasis>&quot;/&gt;
                  &lt;bean parent=&quot;Uif-KeyLabelPair&quot; p:key=&quot;4&quot; p:value=&quot;Other: <emphasis role="keyword">[id=Demo-SampleMessageInput2]</emphasis>&quot;/&gt;
                &lt;/list&gt;
              &lt;/property&gt;
            &lt;/bean&gt;
          &lt;/property&gt;
</programlisting>
    <section>
      <title>Other Rich Message Usages</title>
      <para>Usage in InputField labels:</para>
      <programlisting>&lt;bean parent=&quot;Uif-InputField-LabelTop&quot; p:propertyName=&quot;field100&quot; <emphasis role="keyword">p:label=&quot;Label With [color=green]Color[/color]"</emphasis>/&gt;</programlisting>
      <para>Usage in instructionalText (similar in other areas which are backed by the Message
            component in their Java object):</para>
      <programlisting>…
<emphasis role="keyword">p:instructionalText=&quot;Testing [css=&apos;fl-text-underline&apos;]checkbox and radio groups[/css] below&quot;</emphasis>
…
</programlisting>
      <para>Usage in CheckboxControl - also demonstrating the ability to override a property of the component referenced by id (overriding propertyName with value &apos;field103&apos;):</para>
      <programlisting>...
&lt;bean parent=&quot;Uif-InputField-LabelTop&quot; p:propertyName=&quot;bField1&quot; p:label=&quot;CheckboxControl&quot;&gt;
       &lt;property name=&quot;control&quot;&gt;
                    &lt;bean parent=&quot;Uif-CheckboxControl&quot; <emphasis role="keyword">p:checkboxLabel=&quot;I, [id=Demo-SampleMessageInput4 propertyName=&apos;field103&apos;], agree to the terms and conditions of this form&quot;</emphasis>&gt;
         &lt;/bean&gt;
       &lt;/property&gt;
&lt;/bean&gt;
...</programlisting>
    </section>
  </section>
    </section>     
  </section>
</chapter>
