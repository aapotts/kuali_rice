/*
 * Copyright 2005-2007 The Kuali Foundation
 *
 *
 * Licensed under the Educational Community License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.opensource.org/licenses/ecl2.php
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.kuali.rice.kew.docsearch;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang.StringUtils;
import org.joda.time.DateTime;
import org.kuali.rice.core.api.CoreApiServiceLocator;
import org.kuali.rice.kew.api.document.DocumentStatus;
import org.kuali.rice.kew.api.document.lookup.DocumentLookupCriteria;
import org.kuali.rice.kew.api.document.lookup.DocumentLookupCriteriaContract;
import org.kuali.rice.kew.api.document.lookup.RouteNodeLookupLogic;
import org.kuali.rice.kew.engine.node.RouteNode;
import org.kuali.rice.kew.framework.document.lookup.SearchableAttribute;
import org.kuali.rice.kew.service.KEWServiceLocator;
import org.kuali.rice.kew.util.KEWConstants;
import org.kuali.rice.kns.web.ui.Field;
import org.kuali.rice.kns.web.ui.Row;
import org.kuali.rice.krad.bo.BusinessObject;
import org.kuali.rice.krad.bo.BusinessObjectBase;

import java.sql.Timestamp;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;


/**
 * Model bean representing document searches.  Persisted each search as part of the users saved searches.
 *
 * @author Kuali Rice Team (rice.collab@kuali.org)
 */
public class DocSearchCriteriaDTO extends BusinessObjectBase implements BusinessObject, DocumentSearchEbo, DocumentLookupCriteriaContract {

    private static final long serialVersionUID = -5738747438282249790L;

    public static final String ADVANCED_SEARCH_INDICATOR_STRING = "YES";
    public static final String SUPER_USER_SEARCH_INDICATOR_STRING = "YES";
    public static final int DEFAULT_PAGE_SIZE = 10;

    private String namedSearch; // if populated the name of the search that they want to save
    private Integer pageSize; // the number of items to display on a page of results
    private String documentId; // id generated by KEW
    private String docRouteStatus; // route status of the document
    private String appDocStatus; // application document status
    private String docTitle; // document title provided by the application
    private String appDocId; // application provided ID - defaults to documentId
    private String overrideInd; // flag to indicate overridden business values - set by app
    private String initiator; // network Id of the person who initiated the document
    private String viewer; // network Id of the person who is currently viewing the document
    private String workgroupViewerNamespace; //group namespace of the group that has had an action request to the document
    private String workgroupViewerName; // workgroup Id that has had an action request to the document
    private String approver; // network Id of the person who is approving the document
    private String docRouteNodeId; // current level of routing, i.e. which route method is the document currently in
    private String docRouteNodeLogic; // exactly, before or after
    private String docVersion; // document version
    private String docTypeFullName; // the fullname for the document's docType
    private String workgroupViewerId;

    //date range properties
    private String fromDateCreated; // the begin range for DateCreated
    private String fromDateLastModified; // the begin range for LastModified
    private String fromDateApproved; // the begin range for Approved
    private String fromDateFinalized; // the begin range for Finalized
    private String fromStatusTransitionDate;  // the begin range for app doc status transition
    private String toDateCreated; // the end range for created
    private String toDateLastModified; // the end range for last modified
    private String toDateApproved; // the end range for approved
    private String toDateFinalized; // the end range for finalized
    private String toStatusTransitionDate;  // the end range for app doc status transition
    private java.sql.Timestamp dateCreated; //fake date for DD
    
    // criteria processing
    private List<Row> searchableAttributeRows = new ArrayList<Row>();

    // searchable attribute properties
    private List<SearchAttributeCriteriaComponent> searchableAttributes = new ArrayList<SearchAttributeCriteriaComponent>();

    //properties to preserve view from saved and history searches as well as generate results
    private String isAdvancedSearch;
    private String superUserSearch = "NO";

    // used as an "out" parameter to indicate the threshold for the search
    private Integer threshold = Integer.valueOf(DocumentSearchGenerator.DEFAULT_SEARCH_RESULT_CAP);
    private Integer fetchLimit = Integer.valueOf(0);

    // used as an "out" parameter to indicate that the rows fetched for this criteria are over the indicated threshold
    private boolean isOverThreshold = false;

    // used as an "out" prameter to indicate the number of rows that were filtered for security
    private int securityFilteredRows = 0;

    // below used when doing a document search from API
    private boolean overridingUserSession = false;
    private boolean saveSearchForUser = false;

    private boolean onlyDocTypeFilled = false;
    
    public DocSearchCriteriaDTO() {
        super();
    }

    public boolean isStandardCriteriaConsideredEmpty(boolean excludeDocumentTypeName) {
        boolean docTypeNameIsBlank = StringUtils.isBlank(this.docTypeFullName);
        boolean standardFieldsAreBlank = StringUtils.isBlank(documentId) &&
                StringUtils.isBlank(initiator) &&
                StringUtils.isBlank(workgroupViewerName) &&
                StringUtils.isBlank(docVersion) &&
                StringUtils.isBlank(fromDateCreated) && 
                StringUtils.isBlank(toDateCreated) &&
                StringUtils.isBlank(appDocId) &&
                StringUtils.isBlank(approver) &&
                StringUtils.isBlank(docRouteNodeId) &&
                StringUtils.isBlank(docRouteStatus) &&
                StringUtils.isBlank(docTitle) &&
                StringUtils.isBlank(viewer) &&
                StringUtils.isBlank(fromDateApproved) &&
                StringUtils.isBlank(toDateApproved) &&
                StringUtils.isBlank(fromDateFinalized) &&
                StringUtils.isBlank(toDateFinalized) &&
                StringUtils.isBlank(fromDateLastModified) &&
                StringUtils.isBlank(toDateLastModified);
        if (excludeDocumentTypeName) {
            return standardFieldsAreBlank;
        } else {
            return docTypeNameIsBlank && standardFieldsAreBlank;
        }
    }

    public String getDocRouteNodeLogic() {
        return docRouteNodeLogic;
    }

    public void setDocRouteNodeLogic(String docRouteLevelLogic) {
        this.docRouteNodeLogic = docRouteLevelLogic;
    }

    public String getAppDocId() {
        return appDocId;
    }

    public void setAppDocId(String appDocId) {
        this.appDocId = appDocId;
    }

    public String getApprover() {
        return approver;
    }

    public void setApprover(String approver) {
        this.approver = approver;
    }

    public String getDocRouteNodeId() {
        return docRouteNodeId;
    }

    public void setDocRouteNodeId(String docRouteLevel) {
        this.docRouteNodeId = docRouteLevel;
    }

    public String getDocRouteStatus() {
        return docRouteStatus;
    }

    public void setDocRouteStatus(String docRouteStatus) {
        this.docRouteStatus = docRouteStatus;
    }

    public String getAppDocStatus() {
        return appDocStatus;
    }

    public void setAppDocStatus(String appDocStatus) {
        this.appDocStatus = appDocStatus;
    }

    public String getDocTitle() {
        return docTitle;
    }

    public void setDocTitle(String docTitle) {
        this.docTitle = docTitle;
    }

    public String getDocTypeFullName() {
        return docTypeFullName;
    }

    public void setDocTypeFullName(String docTypeFullName) {
        this.docTypeFullName = docTypeFullName;
    }

    public String getDocVersion() {
        return docVersion;
    }

    public void setDocVersion(String docVersion) {
        this.docVersion = docVersion;
    }

    public String getInitiator() {
        return initiator;
    }

    public void setInitiator(String initiator) {
        this.initiator = initiator;
    }

    public String getOverrideInd() {
        return overrideInd;
    }

    public void setOverrideInd(String overrideInd) {
        this.overrideInd = overrideInd;
    }

    public String getDocumentId() {
        return documentId;
    }

    public void setDocumentId(String documentId) {
        this.documentId = documentId;
    }

    public String getViewer() {
        return viewer;
    }

    public void setViewer(String viewer) {
        this.viewer = viewer;
    }

    public Integer getPageSize() {
        return pageSize;
    }

    public void setPageSize(Integer pageSize) {
        this.pageSize = pageSize;
    }

    public String getFromDateApproved() {
        return fromDateApproved;
    }

    public String getFromDateCreated() {
        return fromDateCreated;
    }

    public String getFromDateFinalized() {
        return fromDateFinalized;
    }

    public String getFromDateLastModified() {
        return fromDateLastModified;
    }

    public String getFromStatusTransitionDate() {
        return fromStatusTransitionDate;
    }

    public String getToDateApproved() {
        return toDateApproved;
    }

    public String getToDateCreated() {
        return toDateCreated;
    }

    public String getToDateFinalized() {
        return toDateFinalized;
    }

    public String getToDateLastModified() {
        return toDateLastModified;
    }

    public String getToStatusTransitionDate() {
        return toStatusTransitionDate;
    }
    public void setFromDateApproved(String fromDateApproved) {
        this.fromDateApproved = safeTrimmer(fromDateApproved);
    }

    public void setFromDateCreated(String fromDateCreated) {
        this.fromDateCreated = safeTrimmer(fromDateCreated);
    }

    public void setFromDateFinalized(String fromDateFinalized) {
        this.fromDateFinalized = safeTrimmer(fromDateFinalized);
    }

    public void setFromDateLastModified(String fromDateLastModified) {
        this.fromDateLastModified = safeTrimmer(fromDateLastModified);
    }

    public void setFromStatusTransitionDate(String fromStatusTransitionDate) {
        this.fromStatusTransitionDate = safeTrimmer(fromStatusTransitionDate);
    }

    public void setToDateApproved(String toDateApproved) {
        this.toDateApproved = safeTrimmer(toDateApproved);
    }

    public void setToDateCreated(String toDateCreated) {
        this.toDateCreated = safeTrimmer(toDateCreated);
    }

    public void setToDateFinalized(String toDateFinalized) {
        this.toDateFinalized = safeTrimmer(toDateFinalized);
    }

    public void setToDateLastModified(String toDateLastModified) {
        this.toDateLastModified = safeTrimmer(toDateLastModified);
    }

    public void setToStatusTransitionDate(String toStatusTransitionDate) {
        this.toStatusTransitionDate = safeTrimmer(toStatusTransitionDate);
    }

    private String safeTrimmer(String value) {
        if (!org.apache.commons.lang.StringUtils.isEmpty(value)) {
            return value.trim();
        }
        return value;
    }

    public String getNamedSearch() {
        return namedSearch;
    }

    public void setNamedSearch(String namedSearch) {
        this.namedSearch = namedSearch;
    }

    public String getDocumentSearchAbbreviatedString() {
        StringBuffer abbreviatedString = new StringBuffer();
        String dateApprovedString = getRangeString(this.toDateApproved, this.fromDateApproved);
        String dateCreatedString = getRangeString(this.toDateCreated, this.fromDateCreated);
        String dateLastModifiedString = getRangeString(this.toDateLastModified, this.fromDateLastModified);
        String dateFinalizedString = getRangeString(this.toDateFinalized, this.fromDateFinalized);
        String dateStatusTransitionString = getRangeString(this.toStatusTransitionDate, this.fromStatusTransitionDate);
        if (appDocId != null && !"".equals(appDocId.trim())) {
            abbreviatedString.append("Application Document Id=").append(appDocId).append("; ");
        }
        if (approver != null && !"".equals(approver.trim())) {
            abbreviatedString.append("Approver=").append(approver).append("; ");
        }
        if (docRouteNodeId != null && !"".equals(docRouteNodeId.trim())) {
            RouteNode routeNode = KEWServiceLocator.getRouteNodeService().findRouteNodeById(docRouteNodeId);
            abbreviatedString.append("Document Route Node=").append(routeNode.getRouteNodeName()).append("; ");
        }
        if (docRouteStatus != null && !"".equals(docRouteStatus.trim())) {
            abbreviatedString.append("Document Route Status=").append(docRouteStatus).append("; ");
        }
        if (docTitle != null && !"".equals(docTitle.trim())) {
            abbreviatedString.append("Document Title=").append(docTitle).append("; ");
        }
        if (docTypeFullName != null && !"".equals(docTypeFullName.trim())) {
            abbreviatedString.append("Document Type=").append(docTypeFullName).append("; ");
        }
        if (initiator != null && !"".equals(initiator.trim())) {
            abbreviatedString.append("Initiator=").append(initiator).append("; ");
        }
        if (documentId != null) {
            abbreviatedString.append("Document Id=").append(documentId).append("; ");
        }
        if (viewer != null && !"".equals(viewer.trim())) {
            abbreviatedString.append("Viewer=").append(viewer).append("; ");
        }
        if (workgroupViewerName != null) {
            abbreviatedString.append("Group Viewer=").append(workgroupViewerName).append(";");
        }
        if (dateLastModifiedString != null) {
            abbreviatedString.append("Date Last Modified=").append(dateLastModifiedString).append("; ");
        }
        if (dateFinalizedString != null) {
            abbreviatedString.append("Date Finalized=").append(dateFinalizedString).append("; ");
        }
        if (dateCreatedString != null) {
            abbreviatedString.append("Date Created=").append(dateCreatedString).append("; ");
        }
        if (dateApprovedString != null) {
            abbreviatedString.append("Date Approved=").append(dateApprovedString).append("; ");
        }
        if (dateStatusTransitionString != null) {
            abbreviatedString.append("Date Status Transition=").append(dateStatusTransitionString).append("; ");
        }

        Set<String> alreadyAddedRangeAttributes = new HashSet<String>();
        for (SearchAttributeCriteriaComponent searchableAttribute : searchableAttributes)
        {
            if (!org.apache.commons.lang.StringUtils.isEmpty(searchableAttribute.getValue()))
            {
                // single value entered
                if (searchableAttribute.isRangeSearch())
                {
                    // if search attribute criteria component is member of a range we must find it's potential matching partner to build the string
                    if (!alreadyAddedRangeAttributes.contains(searchableAttribute.getSavedKey()))
                    {
                        // the key has not been processed yet
                        String lowerSearchAttributeRangeValue = (searchableAttribute.getFormKey().startsWith(KEWConstants.SearchableAttributeConstants.RANGE_LOWER_BOUND_PROPERTY_PREFIX)) ? searchableAttribute.getValue() : null;
                        String upperSearchAttributeRangeValue = (searchableAttribute.getFormKey().startsWith(KEWConstants.SearchableAttributeConstants.RANGE_UPPER_BOUND_PROPERTY_PREFIX)) ? searchableAttribute.getValue() : null;
                        // loop through the attributes to find this search attribute criteria components potential match
                        for (SearchAttributeCriteriaComponent searchableAttribute1 : searchableAttributes)
                        {
                            if ((searchableAttribute1.getSavedKey().equals(searchableAttribute.getSavedKey())) && (!(searchableAttribute1.getFormKey().equals(searchableAttribute.getFormKey()))))
                            {
                                // we found the other side of the range
                                if (lowerSearchAttributeRangeValue == null)
                                {
                                    lowerSearchAttributeRangeValue = (searchableAttribute1.getFormKey().startsWith(KEWConstants.SearchableAttributeConstants.RANGE_LOWER_BOUND_PROPERTY_PREFIX)) ? searchableAttribute1.getValue() : null;
                                }
                                if (upperSearchAttributeRangeValue == null)
                                {
                                    upperSearchAttributeRangeValue = (searchableAttribute1.getFormKey().startsWith(KEWConstants.SearchableAttributeConstants.RANGE_UPPER_BOUND_PROPERTY_PREFIX)) ? searchableAttribute1.getValue() : null;
                                }
                                break;
                            }
                        }
                        // we should have valid values for the 'to' and 'from' range field values by now
                        abbreviatedString.append(searchableAttribute.getSavedKey()).append("=").append(getRangeString(lowerSearchAttributeRangeValue, upperSearchAttributeRangeValue)).append(";");
                        alreadyAddedRangeAttributes.add(searchableAttribute.getSavedKey());
                    }
                } else
                {
                    abbreviatedString.append(searchableAttribute.getSavedKey()).append("=").append(searchableAttribute.getValue()).append(";");
                }
            } else if (!CollectionUtils.isEmpty(searchableAttribute.getValues()))
            {
                // multiple values entered
                StringBuffer tempAbbreviatedString = new StringBuffer();
                tempAbbreviatedString.append(searchableAttribute.getSavedKey()).append("=");
                boolean firstValue = true;
                for (String value : searchableAttribute.getValues())
                {
                    if (StringUtils.isNotBlank(value))
                    {
                        if (firstValue)
                        {
                            tempAbbreviatedString.append(value);
                            firstValue = false;
                        } else
                        {
                            tempAbbreviatedString.append(" or ").append(value);
                        }
                    }
                }
                String testString = tempAbbreviatedString.toString().replaceAll("=", "").replaceAll(" or ", "");
                if (testString.trim().length() > 0)
                {
                    abbreviatedString.append(tempAbbreviatedString).append(";");
                }
            }
        }

        return abbreviatedString.toString();
    }

    private String getRangeString(String to, String from) {
        String dateString = null;
        if (to != null && !"".equals(to.trim()) && from != null && !"".equals(from.trim())) {
            dateString = "(" + from + " - " + to + ")";
        } else {
            if (to != null && !"".equals(to.trim())) {
                dateString = "to " + to;
            } else if (from != null && !"".equals(from.trim())) {
                dateString = "from " + from;
            } else {
                //
            }
        }
        return dateString;
    }

    /**
     * TODO this is here for historic reasons and has been replaced by a managed state in the CriteriaDTO... eliminate
     * @deprecated
     */
    public boolean isAdvancedSearch() {
        return ((appDocId != null && !"".equals(appDocId.trim())) || (approver != null && !"".equals(approver.trim())) || (docRouteNodeId != null && !"".equals(docRouteNodeId.trim())) || (docRouteStatus != null && !"".equals(docRouteStatus.trim())) || (docTitle != null && !"".equals(docTitle.trim())) || (viewer != null && !"".equals(viewer.trim())) || (fromDateApproved != null && !"".equals(fromDateApproved.trim())) || (toDateApproved != null && !"".equals(toDateApproved.trim())) || (toDateFinalized != null && !"".equals(toDateFinalized.trim())) || (fromDateFinalized != null && !"".equals(fromDateFinalized.trim())) || (toDateLastModified != null && !"".equals(toDateLastModified.trim())) || (fromDateLastModified != null && !"".equals(fromDateLastModified.trim())));
    }

    public String getWorkgroupViewerName() {
        return workgroupViewerName;
    }

    public void setWorkgroupViewerName(String workgroupViewerName) {
        this.workgroupViewerName = workgroupViewerName;
    }

    public String getIsAdvancedSearch() {
        return isAdvancedSearch;
    }

    public void setIsAdvancedSearch(String isAdvancedSearch) {
        this.isAdvancedSearch = isAdvancedSearch;
    }

    public String getSuperUserSearch() {
        return superUserSearch;
    }

    public void setSuperUserSearch(String superUserSearch) {
        this.superUserSearch = superUserSearch;
    }

    public boolean isOverThreshold() {
        return isOverThreshold;
    }

    public void setOverThreshold(boolean isOverThreshold) {
        this.isOverThreshold = isOverThreshold;
    }

    public int getSecurityFilteredRows() {
        return securityFilteredRows;
    }

    public void setSecurityFilteredRows(int securityFilteredRows) {
        this.securityFilteredRows = securityFilteredRows;
    }

    public Integer getThreshold() {
        return this.threshold;
    }

    public void setThreshold(Integer threshold) {
        this.threshold = threshold;
    }

    public Integer getFetchLimit() {
        return this.fetchLimit;
    }

    public void setFetchLimit(Integer fetchLimit) {
        this.fetchLimit = fetchLimit;
    }

    public void addSearchableAttribute(SearchAttributeCriteriaComponent searchableAttribute) {
        searchableAttributes.add(searchableAttribute);
    }

    public void setSearchableAttributes(List<SearchAttributeCriteriaComponent> searchableAttributes) {
        this.searchableAttributes = searchableAttributes;
    }

    public List<SearchAttributeCriteriaComponent> getSearchableAttributes() {
        return searchableAttributes;
    }

    public void setSearchableAttributeRows(List<Row> searchableAttributeRows) {
        this.searchableAttributeRows = searchableAttributeRows;
    }

    public List<Row> getSearchableAttributeRows() {
        return searchableAttributeRows;
    }

    public List<Row> getProcessedSearchableAttributeRows() {
        return searchableAttributeRows;
    }

    public void addSearchableAttributeRow(Row row) {
        searchableAttributeRows.add(row);
    }

    public Row getSearchableAttributeRow(int index) {
        while (getSearchableAttributeRows().size() <= index) {
            Row row = new Row(new ArrayList<Field>());
            getSearchableAttributeRows().add(row);
        }
        return (Row) getSearchableAttributeRows().get(index);
    }

    public void setSearchableAttributeRow(int index, Row row) {
        searchableAttributeRows.set(index, row);
    }

    public boolean isOverridingUserSession() {
        return this.overridingUserSession;
    }

    public void setOverridingUserSession(boolean overridingUserSession) {
        this.overridingUserSession = overridingUserSession;
    }

	public boolean isSaveSearchForUser() {
		return this.saveSearchForUser;
	}

	public void setSaveSearchForUser(boolean saveSearchForUser) {
		this.saveSearchForUser = saveSearchForUser;
	}

    /**
	 * @deprecated
	 */
    public String getWorkgroupViewerNamespace() {
        return this.workgroupViewerNamespace;
    }
    /**
     * 
     * @deprecated
     */
    public void setWorkgroupViewerNamespace(String workgroupViewerNamespace) {
        this.workgroupViewerNamespace = workgroupViewerNamespace;
    }

	public void refresh() {
		// TODO chris - THIS METHOD NEEDS JAVADOCS
	}

	public java.sql.Timestamp getDateCreated() {
		return this.dateCreated;
	}

	/**
	 * @param dateCreated the dateCreated to set
	 */
	public void setDateCreated(java.sql.Timestamp dateCreated) {
		this.dateCreated = dateCreated;
	}

	/**
	 * @return the onlyDocTypeFilled
	 */
	public boolean isOnlyDocTypeFilled() {
		return this.onlyDocTypeFilled;
	}

	/**
	 * @param onlyDocTypeFilled the onlyDocTypeFilled to set
	 */
	public void setOnlyDocTypeFilled(boolean onlyDocTypeFilled) {
		this.onlyDocTypeFilled = onlyDocTypeFilled;
	}

	/**
	 * @return the workgroupViewerId
	 */
	public String getWorkgroupViewerId() {
		return this.workgroupViewerId;
	}

	/**
	 * @param workgroupViewerId the workgroupViewerId to set
	 */
	public void setWorkgroupViewerId(String workgroupViewerId) {
		this.workgroupViewerId = workgroupViewerId;
	}

    @Override
    public List<DocumentStatus> getDocumentStatuses() {
        List<DocumentStatus> documentStatuses = new ArrayList<DocumentStatus>();
        if (StringUtils.isNotBlank(getDocRouteStatus())) {
            // in the case where they submit more than one status
            String[] splitStatuses = getDocRouteStatus().split(",");
            for (String statusValue : splitStatuses) {
                DocumentStatus status = DocumentStatus.fromCode(statusValue.trim());
                if (status == null) {
                    throw new IllegalStateException("Encountered an invalid status code: " + statusValue);
                }
                documentStatuses.add(status);
            }
        }
        return Collections.unmodifiableList(documentStatuses);
    }

    @Override
    public String getTitle() {
        return getDocTitle();
    }

    @Override
    public String getApplicationDocumentId() {
        return getAppDocId();
    }

    @Override
    public String getInitiatorPrincipalName() {
        return getInitiator();
    }

    @Override
    public String getViewerPrincipalName() {
        return getViewer();
    }

    @Override
    public String getViewerGroupId() {
        return getWorkgroupViewerId();
    }

    @Override
    public String getApproverPrincipalName() {
        return getApprover();
    }

    @Override
    public String getRouteNodeName() {
        return getDocRouteNodeId();
    }

    @Override
    public RouteNodeLookupLogic getRouteNodeLookupLogic() {
        if (StringUtils.isBlank(getDocRouteNodeLogic())) {
            return null;
        }
        return RouteNodeLookupLogic.valueOf(getDocRouteNodeLogic());
    }

    @Override
    public String getDocumentTypeName() {
        return getDocTypeFullName();
    }

    @Override
    public DateTime getDateCreatedFrom() {
        return convertDateString(getFromDateCreated());
    }

    @Override
    public DateTime getDateCreatedTo() {
        return convertDateString(getToDateCreated());
    }

    @Override
    public DateTime getDateLastModifiedFrom() {
        return convertDateString(getFromDateLastModified());
    }

    @Override
    public DateTime getDateLastModifiedTo() {
        return convertDateString(getToDateLastModified());
    }

    @Override
    public DateTime getDateApprovedFrom() {
        return convertDateString(getFromDateApproved());
    }

    @Override
    public DateTime getDateApprovedTo() {
        return convertDateString(getToDateApproved());
    }

    @Override
    public DateTime getDateFinalizedFrom() {
        return convertDateString(getFromDateFinalized());
    }

    @Override
    public DateTime getDateFinalizedTo() {
        return convertDateString(getToDateFinalized());
    }

    @Override
    public Map<String, String> getDocumentAttributeValues() {
        Map<String, String> documentAttributeValues = new HashMap<String, String>();
        for (SearchAttributeCriteriaComponent searchAttributeComponent : getSearchableAttributes()) {
            documentAttributeValues.put(searchAttributeComponent.getSavedKey(), searchAttributeComponent.getValue());
        }
        return Collections.unmodifiableMap(documentAttributeValues);
    }

    @Override
    public Integer getStartAtIndex() {
        return new Integer(0);
    }

    @Override
    public Integer getMaxResults() {
        return getThreshold();
    }

    private DateTime convertDateString(String dateString) {
        if (StringUtils.isBlank(dateString)) {
            return null;
        }
        try {
            Timestamp timestamp = CoreApiServiceLocator.getDateTimeService().convertToSqlTimestamp(dateString);
            return new DateTime(timestamp.getTime());
        } catch (ParseException e) {
            // for now, ignore this issue, validation should catch this
            return null;
        }
    }

    /**
     * Applies the values from the given DocumentLookupCriteria to this criteria object by copying them
     * over to the appropriate fields based on the mapping between these two classes.
     */
    public void apply(DocumentLookupCriteria criteria) {
        // TODO - Rice 2.0 - implement this method!
        throw new UnsupportedOperationException("Implement me!");
    }
}
