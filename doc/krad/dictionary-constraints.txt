{toc}

h1. Attribute Definition Constraints

In the earliest versions of the Kuali Nervous System, it was recognized that forcing developers to write Java-based rules to check if a required field was filled in or if it matched a date pattern was a hefty load of work that easily could be transferred to the data dictionary.  And therefore, every AttributeDefinition defined for a property of a data object had the ability to define validations.  For instance, let's take a generic date field from KFS's org/kuali/kfs/sys/businessobject/datadictionary/GenericAttributes.xml file:

{code:xml}
1.  <bean id="GenericAttributes-genericDate" parent="GenericAttributes-genericDate-parentBean"/>
2.  <bean id="GenericAttributes-genericDate-parentBean" abstract="true" parent="AttributeDefinition">
3.    <property name="name" value="genericDate"/>
4.    <property name="forceUppercase" value="false"/>
5.    <property name="label" value="Generic Date Style Attribute"/>
6.    <property name="shortLabel" value="GenericDate"/>
7.    <property name="maxLength" value="22"/>
8.    <property name="validationPattern" ref="DateValidation" />
9.    <property name="control" ref="DateControl" />
10.   <property name="formatterClass" value="org.kuali.rice.kns.web.format.DateFormatter"/>
11. </bean>
{code}

It's a simple enough example, but lines 7 and 8 pack quite a bit of power: together, they limit the length of the field to a size which can fit in the database (evidently twenty-two characters) and they add the DateValidation, which requires that any user input fits a certain pattern defined as a regular expression.  Two lines of configuration, and the developer gets a fair amount of error checking.

That's wonderful, of course, but it has limits.  There's no way to only run constraints based on the values present in other attributes.  There wasn't a general way to enforce a data type for a user input value.  There wasn't a way to say, for instance, that one or another field was required - either a field was required or it wasn't.  Such logic, not that much more complex, all required a Java-based rules solution.

However, thanks to some enterprising work from the Kuali Student team, the data dictionary for the Kuali Rapid Application Development framework (better known as KRAD) has gained a lot of power in the validation space.  Much more complex logic is available than ever before.  Not only that, but it can be enabled to work on the client side via JavaScript as well.  Finally, for even more flexibility, the processors which act on the constraints have been pulled out into injectable classes - meaning that applications can override the logic for a constraint if needed.  Furthermore, constraints need not act only on AttributeDefinitions; new interfaces have been developed which allow any configuration class to participate in being validated.

Obviously, there's a lot of functionality to cover - from the classic constraints which continue on in the framework to the powerful constraints that the Kuali Student team contributed to KRAD.  This article will do an overview of the specific "built-in" constraints available to developers.  It will then look at the architecture of the constraint framework, with a special emphasis on how constraint logic may be overridden, how new constraints would be constructed, and non-attributes could have Constraint logic built for them.

h2. Simple Constraints

As will be covered in more detail in [The Constraint Interface|#constraint_interface], every constraint in KRAD implements the org.kuali.rice.kns.datadictionary.validation.constraint.Constraint interface.  This interface is a simple marker interface.  Children of that interface tend to define the data they would need from the configuration to figure out if the value put into the attribute is valid or not.  For instance, in the GenericAttributes-genericDate example above, the maxLength property is set to 22.  One would expect a length-based constraint to require a getMaxLength() method which could then be fed to the Constraint to find the maximum length.

org.kuali.rice.kns.datadictionary.validation.constraint.SimpleConstraint defines what we might call a "nervous system classic" constraint.  It is built from normal fields on AttributeDefinition - required; maxLength and minLength (the latter has been added as part of KRAD); exclusiveMin and exclusiveMax; and finally, minOccurs and maxOccurs, which will be covered in more detail presently.  The required constraint, of course, means that some value must be set for the attribute.  The maxLength and minLength attributes typically apply to String data, which must be a certain size.  Likewise, exclusiveMin and exclusiveMax apply to numeric data which must fit within some set range.

h3. Collection Size Constraints

Another common rule situation is when a collection is the child of a data object or document, and for that data object or document to be valid, a certain number of elements must be available in the collection.  For instance, on an Add Course Document, one would expect the "coursesToAdd" collection to have at least one course in it and to be less than the total number of courses a student is allowed to take in a semester or quarter.  Therefore in the [JAMES! WHERE WOULD THIS BE DEFINED??], one adds a constraint as follows:

{code:xml}
1. <bean name="AddDocument-coursesToAdd" parent="AttributeDefinition">
2.   <property name="minOccurs" value="1" />
3.   <property name="maxOccurs" value="74" />
4. </bean>
{code}

Evidently, some students can take up to seventy four classes.  Busy student.  At any rate, the CollectionSizeConstraint is handled as a special type of SimpleConstraint.  Simply set the minOccurs and maxOccurs for the attribute and there will be an error if the collection size falls outside those limits. Naturally, either the minOccurs or maxOccurs can be left out for collections which should be unbounded in either lower or upper size limit.

h2. ValidCharactersConstraint

Another hold over from the nervous system constraints, ValidCharactersConstraint exists to make sure that a String value matches against a regular expression.  For instance, let's say that a KRAD application requires that all phone numbers must be in the form of (###) ###-####  (Evidently, the attribute does not accept international numbers...but as developers, we must rest assured that's the requirement.)  In the data dictionary for that attribute, the following could be set:

{code:xml}
1.  <bean id="DataObject-phoneNumber" parent="AttributeDefinition">
2.    <property name="name" value="phoneNumber" />
3.    <property name="validCharactersConstraint">
4.      <bean class="org.kuali.rice.kns.datadictionary.validation.constraint.ValidCharactersConstraint">
5.        <property name="value" value="\(\d{3}\) \d{3}-\d{4}" />
6.      </bean>
7.    </property>
8.  </bean>
{code}

In lines 3 through 7, we set the validCharactersConstraint property on the AttributeDefinition, handing the bean we just created a regex which should match the phone number pattern which the requirements say all phone numbers should match.  This regex is passed in as the value property to the ValidCharactersConstraint bean.

[JAMES - STANDARD VALID CHARACTERS CONSTRAINTS?]

Finally, note that the ValidCharactersConstraint has a second property, "jsValue".  In most cases, Java's regular expression engine (ValidCharactersConstraint uses the built-in regular expression engine) will accept the same expressions as the JavaScript engine.  That's good, because the same regular expression can be passed to the client and handled client side, as will be covered in more detail soon.  However, there's a small number of discrepancies between the two engines, so sometimes an extra, JavaScript version of the regular expression must be supplied.

*Side note:* So what are those discrepancies?  It's hard to say.  Part of the issue is that each browser basically has its own JavaScript regular expression engine.  The best idea is to keep validation regular expressions to the use of broadly supported features, and keep on eye on engine comparison pages such as [http://en.wikipedia.org/wiki/Comparison_of_regular_expression_engines].

h2. Dependency Constraints

[JAMES R - TRUE THAT?]

A dependency constraint reuses the org.kuali.rice.kns.datadictionary.validation.constraint.PrerequisiteConstraint but outside the context of the min occurs/max occurs of the MustOccurConstraint.  Basically, if the attribute is non-empty, then it is expected that any prerequisite constraints will also be non-empty.

{code:xml}
1.  <bean id="DataObject-phoneNumber" parent="AttributeDefinition">
2.    <property name="name" value="phoneNumber" />
3.    <property name="dependencyConstraints">
4.      <list>
5.        <bean class="org.kuali.rice.kns.datadictionary.validation.constraint.PrerequisiteConstraint" p:attributePath="phoneExtension" />
6.      </list>
7.    </property>
8.  </bean>
{code}

In this case, if phoneNumber is non-empty, then phoneExtension must be non-empty as well.

h2. Lookup Constraints

These are constraints on values returned from lookups into an attribute.  As of the time of this writing, they're still in process of implementation.

h2. Conditional Logic Constraints

All of the constraints so far covered are static, in a fashion.  Once declared, they will apply to their attributes no matter what.  However, let's say that a constraint should only be tested when the attribute has a certain value.  How could the constraint be turned off if that value isn't present and only be applied if the attribute has the given value?

The final constraint to look at is org.kuali.rice.kns.datadictionary.validation.constraint.CaseConstraint, which will turn on and off child constraints if attributes match certain values.  The classic example of using this is in an international address form.  If the country code is the United States, then the state code should be filled in as well.  If the country code is for Canada or Turkey, a province should be filled in.  That would be done via a configuration like this:

{code:xml}
 1. <bean id="DataObject-countryCode" parent="AttributeDefinition">
 2.   <property name="name" value="countryCode" />
 3.   <property name="caseConstraint">
 4.     <bean class="org.kuali.rice.kns.datadictionary.validation.constraint.CaseConstraint">
 5.       <property name="whenConstraint">
 6.         <list>
 7.           <bean class="org.kuali.rice.kns.datadictionary.validation.constraint.WhenConstraint">
 8.             <property name="values">
 9.               <list>
10.                 <value>US</value>
11.               </list>
12.             </property>
13.             <property name="constraint">
14.               <bean class="org.kuali.rice.kns.datadictionary.validation.constraint.PrerequisiteConstraint" p:attributePath="state" />
15.             </property>
16.           </bean>
17.           <bean class="org.kuali.rice.kns.datadictionary.validation.constraint.WhenConstraint">
18.             <property name="values">
19.               <list>
20.                 <value>CA</value>
21.                 <value>TR</value>
22.               </list>
23.             </property>
24.             <property name="constraint">
25.               <bean class="org.kuali.rice.kns.datadictionary.validation.constraint.PrerequisiteConstraint" p:attributePath="province" />
26.             </property>
27.           </bean>
28.         </list>
29.       </property>
30.     </bean>
31.   </property>
32. </bean>
{code}

Obviously, for such a powerful constraint, configuration becomes a bit more complex.

A CaseConstraint has a List of WhenConstraints.  WhenConstraints match values to constraints that should be run when the attribute's value matches the WhenConstraint's values.  Here, values are hard coded (lines 8 through 12 and lines 18 through 23) but they need not be.  If the values are in other attributes, a List of valuePaths can be specified.

A WhenConstraint also has one child constraint to match.  In both of the WhenConstraints above, a PrerequisiteConstraint is used to make sure that another attribute - either state or province - is non-empty (lines 14 and 25).  Any Constraint could be used as the child of the WhenConstraint - a SimpleConstraint, another CaseConstraint, and so on.

The ability to turn on and off constraints such can lead to very powerful validations being built directly in the DataDictionary.

h2. Occurrences Constraints

An occurrence constraint states that for a given attribute to be valid, a certain number of prerequisite conditions must be matched.  A prerequisite condition simply means that another attribute with a specified attribute path is non-empty (so Strings must have some text in them; Collections must have at least one member; or the attribute must otherwise not be null).  These constraints thus handle situations where one or more of a number of fields are required.

An occurrence constraint is specified via the MustOccurConstraint constraint.  Let's say that an application requires either a phone number, an e-mail address, or a time for showing up be specified as contact information.  The following example sets up that validation in the data dictionary, adding the error to the phone number attribute (though the same constraint could be copied to the other attributes just as easily):

{code:xml}
1.   <bean id="DataObject-phoneNumber" class="org.kuali.rice.kns.datadictionary.DataObjectEntry"> <!-- SCOTT! NO BEAN FOR THIS ALREADY? -->
2.     <property name="objectClass" value="edu.sampleu.contact.ContactInformation" />
3.     <property name="mustOccurConstraints">
4.       <list>
5.         <bean class="org.kuali.rice.kns.datadictionary.validation.constraint.MustOccurConstraint">
6.           <property name="min" value="1" />
7.           <property name="max" value="3" />
8.           <property name="prerequisiteConstraints">
9.             <list>
10.              <bean class="org.kuali.rice.kns.datadictionary.validation.constraint.PrerequisiteConstraint" p:attributePath="phoneNumber"/>
11.              <bean class="org.kuali.rice.kns.datadictionary.validation.constraint.PrerequisiteConstraint" p:attributePath="emailAddress"/>
12.              <bean class="org.kuali.rice.kns.datadictionary.validation.constraint.PrerequisiteConstraint" p:attributePath="showUpTime"/>
13.            </list>
14.          </property>
15.        </bean>
16.      </list>
17.    </property>
18.  </bean>
{code}

Lines 1 and 2 surprising show that this constraint has been set at the DataObjectEntry level, not that of the AttributeDefinition.  While MustOccurConstraints can be set in pretty much the same way on AttributeDefinitions, since several attributes are involved, it makes more sense to have the validation at a higher level.  At the time of this writing, MustOccurConstraint is the only validation which can be set at the DataObjectLevel.

The min and max properties of lines 6 and 7 tell the constraint how many of the following properties must be present and the maximum number of filled in properties we expect.  Here, the min is 1 - so at least one of the properties must be filled in - and the max is 3, so if all three are filled in, the validation will still work fine.  If there was a desire to only have one attribute filled in, the max could have been set to 1.

The MustOccurConstraint has a list of prerequisiteConstraints - lines 8 through 14 - which describe which attributes are grouped by this constraint.

A MustOccurConstraint can also have a list of child MustOccurConstraints.  Why would such a thing be desirable?  Because it provides a way to set up nested validations.  Let's say that, instead of specifying a show up time, we had an address which needed to be filled in.  If that was the case, we'd need every field of the address - street, city, state, and zip filled in - for the constraint to pass.  In that case, we would have left min and max at 1 and 3 respectively; but instead of line 12, we would have specified a value for the property mustOccurConstraints at line 15, and added a list of constraints asking for all the address attributes to be filled in.

h2. Constraints on the Client Side

One of the tasks that org.kuali.rice.kns.uif.field.AttributeField does in its Finalization stage is to convert constraints to JavaScript.  For all of the following constraints, AttributeField automatically will push the Constraint to the client side:

* Exclusive Minimum and Inclusive Maximum constraints
* ValidCharactersConstraint
* CaseConstraint
* DependencyConstraint
* MustOccursConstraint

When the user attempts to take action on the page, this level of Constraints will kick in - meaning that feedback comes much more quickly. [JAMES R - true on when constraints invoked?]  Of course, the constraints are still run just the same on the server side once the page has been submitted; that way, if the user has scripting turned off, the constraints are still run and user input data gets validated.

h2. Changing Error Messages

All of the covered constraints come are associated with standard error messages.  For instance, if a "required" constraint has been violated, the user will get the following message:

{code}
Phone Number is a required field.
{code}

...which has taken the label from the attribute which violated the constraint and formatted that in to the standard error.required message in the KR-ApplicationResources.properties file.

With most of the constraints, the message can be overridden on the constraint, by specifying the "labelKey" property.  For instance, a configuration like this:

{code:xml}
1.  <bean class="org.kuali.rice.kns.datadictionary.validation.constraint.MustOccurConstraint">
2.    <property name="min" value="1" />
3.    <property name="max" value="3" />
4.    <property name="labelKey" value="error.must.be.able.to.track.down" />
{code}

...instead of using the standard message, the error message show will be the message associated with the "error.must.be.able.to.track.down" key.  This allows for a great deal more flexibility in what message gets displayed - though, the classic messages will still show up as they always did if nothing else is specified.

h1. Constraint Architecture

Obviously, the constraints added to KRAD provide a lot of power through configuration.  Validating user input will be easier than ever.  And yet, the constraint sub-system of KRAD was built with the realization that even more constraints will be added in the future.  Because of that, there needs to be an easy way for Kuali application developers or even future versions of Rice to add new constraints into the system.  And so, there is.

{anchor: constraint_interface}Once again, a Constraint is a marker interface which is implemented by any Constraint bean.  These Constraint beans are purely configuration - they only hold what regex should be parsed against, if a field is required or not: basic information.  The Constraint, in turn, is passed to an implementation of org.kuali.rice.kns.datadictionary.validation.processor.ConstraintProcessor.  Note that implementations of ConstraintProcessors can be genericized with both the type of value that the processor expects and the type of Constraint that the processor will work on.  Most ConstraintProcessor implementations only genericize the Constraint, accepting any Object as a value to validate.

ConstraintProcessors have four methods.  First, the getName() method returns the name that the constraint processor holds.  The getConstraintType() method returns the implementation of Constraint that this processor has the business logic for.  The isOptional() method returns a boolean: true if the processor can be turned off in certain situations by another piece of code, false otherwise.  The only constraint which is currently optional is the ExistenceConstraint; it is turned off by passing a false in the doOptionalProcessing parameter of DictionaryValidationService#processConstraints.

The final method is the one that contains the ConstraintProcessor's business logic: process.  Process takes in DictionaryValidationResult, a value of some type, the Constraint information to apply to the value, and an AttributeValueReader if the value needs yet to be read; it returns an instance of org.kuali.rice.kns.datadictionary.validation.result.ProcessorResult.

ProcessorResults typically wrap instances of org.kuali.rice.kns.datadictionary.validation.result.ConstraintValidationResult.  A ConstraintValidationResult encapsulates a number of possible outcomes for the validation, all generated by org.kuali.rice.kns.datadictionary.validation.result.DictionaryValidationResult.  DictionaryValidationResult's addError method, for example, returns a ConstraintValidationResult which contains an error about a constraint being broken.  Likewise, DictionaryValidationResult's addSuccess method indicates that the result of the constraint test was positive - the value passed the constraint.  The other outcomes that DictionaryValidationResult can generate is addWarning - which gives an informative message that something is wrong with the attribute's value but which will not "fail"; addSkipped, which says that the value could not be tested and therefore the validation was not run; and finally addNoConstraint, which means that the constraint was configured in such way as to not run for the given value or at all.  These ConstraintValidationResults are passed back to KRAD wrapped within the ProcessorResults; the ProcessorResults then ensures that proper logic - whether that be the display of a message, the stopping of logic, or - if everything passed - carrying on with the transaction - occurs.

[ProcessorResult, DictionaryValidationResult, ConstraintValidationResult - oh my!  WHAT IS THE DIFFERENCE BETWEEN THESE THINGS??]

That covers ConstraintProcessors then.  How are they called then?  Just as always, an implementation of org.kuali.rice.kns.service.DictionaryValidationService is responsible for checking all of the attributes which are passed in as part of a request into a KRAD form.  The configuration of the default implementation of DictionaryValidationService has all of the ConstraintProcessors for KRAD passed into it:

{code:xml,title=from KNSSpringBeans.xml}
 1. <bean id="dictionaryValidationService" class="org.kuali.rice.kns.service.impl.DictionaryValidationServiceImpl">
      ...
      contents trimmed
      ...
 2.   <!-- Collection constraint processors are classes that determine if a feature of a collection of objects satisfies some constraint --> 
 3.	  <property name="collectionConstraintProcessors">
 4.	    <list>
 5.		  <bean class="org.kuali.rice.kns.datadictionary.validation.processor.CollectionSizeConstraintProcessor"/>
 6.		</list>
 7.	  </property>
 8.	  <!-- Element constraint processors are classes that determine if a passed value is valid for a specific constraint at the individual object or object attribute level -->
 9.	  <property name="elementConstraintProcessors">
10.     <list>
11.		  <bean class="org.kuali.rice.kns.datadictionary.validation.processor.CaseConstraintProcessor" 
12.		        parent="mandatoryElementConstraintProcessor"/>
13.		  <bean class="org.kuali.rice.kns.datadictionary.validation.processor.ExistenceConstraintProcessor"/>
14.		  <bean class="org.kuali.rice.kns.datadictionary.validation.processor.DataTypeConstraintProcessor"
15.				parent="mandatoryElementConstraintProcessor"/>
16.		  <bean class="org.kuali.rice.kns.datadictionary.validation.processor.RangeConstraintProcessor"
17.		        parent="mandatoryElementConstraintProcessor"/>
18.		  <bean class="org.kuali.rice.kns.datadictionary.validation.processor.LengthConstraintProcessor"
19.		        parent="mandatoryElementConstraintProcessor"/>
20.		  <bean class="org.kuali.rice.kns.datadictionary.validation.processor.ValidCharactersConstraintProcessor"
21.		        parent="mandatoryElementConstraintProcessor"/>
22.		  <bean class="org.kuali.rice.kns.datadictionary.validation.processor.PrerequisiteConstraintProcessor"
23.		        parent="mandatoryElementConstraintProcessor"/>
24.		  <bean class="org.kuali.rice.kns.datadictionary.validation.processor.MustOccurConstraintProcessor"
25.		        parent="mandatoryElementConstraintProcessor"/>
26.	    </list>
27.   </property>
28.	  <!-- Constraint providers are classes that map specific constraint types to a constraint resolver, which takes a constrainable definition -->
29.	  <property name="constraintProviders">
30.	    <list>
31.	      <bean class="org.kuali.rice.kns.datadictionary.validation.constraint.provider.AttributeDefinitionConstraintProvider">
32.		    <!-- 
33.		        individual constraint resolvers can be injected as a map keyed by constraint type as string, or the default 
34.	            resolvers can be instantiated into the map by adding 'init-method="init"' to the bean declaration above
35.	        -->
36.	        <property name="resolverMap">
37.			  <map>
38.			    <entry key="org.kuali.rice.kns.datadictionary.validation.constraint.CaseConstraint">
39.				  <ref bean="dictionaryValidationCaseConstraintResolver"/>
40.				</entry>
41.				<entry key="org.kuali.rice.kns.datadictionary.validation.constraint.ExistenceConstraint">
42.				  <ref bean="dictionaryValidationDefinitionConstraintResolver"/>
43.				</entry>
44.				<entry key="org.kuali.rice.kns.datadictionary.validation.constraint.DataTypeConstraint">
45.	              <ref bean="dictionaryValidationDefinitionConstraintResolver"/>
46.				</entry>
47.				<entry key="org.kuali.rice.kns.datadictionary.validation.constraint.LengthConstraint">
48.				  <ref bean="dictionaryValidationDefinitionConstraintResolver"/>
49.				</entry>
50.				<entry key="org.kuali.rice.kns.datadictionary.validation.constraint.ValidCharactersConstraint">
51.				  <ref bean="dictionaryValidationValidCharactersConstraintResolver"/>
52.				</entry>
53.				<entry key="org.kuali.rice.kns.datadictionary.validation.constraint.PrerequisiteConstraint">
54.				  <ref bean="dictionaryValidationPrerequisiteConstraintsResolver"/>
55.				</entry>
56.				<entry key="org.kuali.rice.kns.datadictionary.validation.constraint.MustOccurConstraint">
57.				  <ref bean="dictionaryValidationMustOccurConstraintsResolver"/>
58.				</entry>
59.				<entry key="org.kuali.rice.kns.datadictionary.validation.constraint.CollectionSizeConstraint">
60.				  <ref bean="dictionaryValidationDefinitionConstraintResolver"/>
61.				</entry>
62.	          </map>
63.	        </property>
64.	      </bean>
65.       <bean class="org.kuali.rice.kns.datadictionary.validation.constraint.provider.ObjectDictionaryEntryConstraintProvider">
66.         <!-- 
67.			    individual constraint resolvers can be injected as a map keyed by constraint type as string, or the default 
68.			    resolvers can be instantiated into the map by adding 'init-method="init"' to the bean declaration above
69.			-->
70.	        <property name="resolverMap">
71.			  <map>
72.			    <entry key="org.kuali.rice.kns.datadictionary.validation.constraint.MustOccurConstraint">
73.				  <ref bean="dictionaryValidationMustOccurConstraintsResolver"/>
74.				</entry>
75.			  </map>
76.			</property>
77.		  </bean>
78.	    </list>
79.	  </property>
80. </bean>
{code}

That's a lot of configuration, but it's done in such a way that Spring's list and map merges should be possible.  Let's go through the injection properties one by one.

Lines 3 through 7 are the collectionConstraintProcessors - constraints which apply to collections.  Here is where CollectionSizeConstraint - the constraint that handles the maxOccurs and minOccurs constraint attributes - goes.  In line 5, the CollectionSizeConstraintProcessor is injected in.  DictionaryValidationServiceImpl then matches the active Constraints on an attribute with the ConstraintProcessors passed in, and runs the logic against the constrained attribute. [JAMES - DO WE NEED MORE DETAIL? THIS IS ALL VERY VAGUE]

If the ConstraintProcessor acts only on a single attribute, it is passed into the elementConstraintProcessor property.  Here are injected the ConstraintProcessors for most of the constraints examined in this article.

[JAMES - HERE!  WHAT ARE CONSTRAINT PROVIDERS?  WHY DO WE NEED THEM?]

[WHAT ELSE SHOULD BE COVERED?]

h2. Applying Constraints to non-Attributes

[BESIDES ATTRIBUTEFIELD AND ATTRIBUTE DEFINITION, WHERE WOULD CONSTRAINABLE BE USED - USES CASES?]