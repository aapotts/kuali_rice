{toc}

h2. Goals

One of the founding modules of Kuali Rice was the Kuali Nervous System.  Designed to help developers create powerful, open-source, enterprise available applications such as Kuali Financial Systems and Kuali Coeus Research Administration, the Kuali Nervous System provided a framework which gave developers an easy course to rapid development by utilizing configuration for what would normally be tedious coding details.  It provided a standard set of tools - lookups, inquiries, documents - based on Java technologies with proven values.  And it provided these capabilities in a way which provided excellent integration with the rest of the growing Kuali Rice stack, especially with Kuali Enterprise Workflow.  Obviously, in its support of KC and KFS, the Nervous System has proven that it can act as the bedrock framework of a robust enterprise application.

Yet: web technology is constantly evolving.  Over the past few years, a great deal of progress has been made in the development of strong client-side web technologies, driven by asynchronous web requests (AJAX) and powerful, cross-browser-enabled JavaScript libraries.  The experience of the typically web user has changed over the years, and so have their expectations.  There's a greater sense that web applications should be more interactive and should support a progression-based interface.

Meanwhile, the needs of applications also evolve.  The initial functional requirements the Kuali Nervous System needed to support were modest and straight-forward.  But each application built on the KNS ended up complicated those requirements, sometimes in ways the KNS could not solve in a straight forward way.

Given the intense interactivity required by the Kuali Student application, there came a general consensus that the Kuali Nervous System was going to have to embrace new web technologies while providing even better rapid development tools.  Also, the whole concept of a "Nervous System" struck many users as slightly gross.  (And wrong: the Kuali Nervous System seems like the skeleton that holds the application together, rather than the brain.)

And so, the Kuali Rice team embarked on creating a better, more interactive Kuali Nervous System, now rechristened KRAD: the Kuali Rapid Application Development framework.

KRAD's current development targets are focused on three major goals: better support for rich user interfaces, more flexibility in the user interface, and improved configuration and tooling for KRAD applications.

h3. Rich UI Support

Over the past few years, web-based user interfaces have taken off.  Many of these technologies have leveraged browser-based JavaScript and Cascading Style Sheets to create impressive effects or to radically increase interactivity by communicating with a web-server in between the normal request/response page cycle.  Because of these huge advances, today's web application users have much higher expectations of interactivity.

KRAD will power up its interactivity offerings by using the JQuery library, currently the de facto standard of rich functionality over the web.  Integrating with JQuery means that KRAD will be able to provide several long-requested interactive features:
- *Lightboxes* Anyone who has opened an inquiry page in a Kuali application knows that it creates a new tab or even a new window to display, stealing focus away from the originating page.  Users can easily end up with a slew of inquiry tabs to navigate among.  With a Lightbox, an inquiry would display on top of the original page, something like a dialogue box, allowing quick return to the original page and reducing the danger of tab clutter.  Lightboxes can also be used with quick finder lookups on maintenance or transactional documents - anywhere where it would be useful to keep the user on a single page.
- *Messages* There are many ways in which rich functionality can be incorporated to inform the user of their progress in an application.  KRAD will support many different kinds of notification schemes to keep the user on top of application progress.  On forms, there will be much more flexibility than in the KNS to display simple constraint messages on fields and fields can also be preset with sample data - known as a watermark - which is removed when focus is given to the field but hints the user into entering the appropriate data.  Notifications will appear when background processes have completed.  There will be rollover help on fields and time notifications (such as progress bars) when a given process is completing which help the user understand that the application needs to finish a process.  This wide range of interactive messages will make it easier for users to have a fuller picture of all the application is doing.
- *Progressive Disclosure* No one likes forms which present too many choices, especially choices that don't apply to the user's current circumstance.  If a user has to enter a state tax rate on a form, the tax rate field shouldn't show up until the user has chosen a state and the application has determined that the state needs to have a tax rate filled in.  The KNS adopted a principle of "progressive disclosure" - that a form should only show the parts that a user needs currently, and that those parts should appear or disappear based on earlier decisions by the user.  However, this was difficult to implement in the KNS and the fact that a return/request cycle was necessary before the form changed made the experience trying for users as well.  KRAD will support a much more interactive progressive disclosure experience, making "mini-trips" to the server through AJAX, pulling back needed pieces of the form only when key fields have been entered.
- *Client Side Validation* The KNS provided a lot of validations which could be configured in the data dictionary: making sure required fields were filled in, checking that entered text followed a specific format pattern, verifying that the length of the field did not surpass some set limit.  In the KNS, though, all of these checks took place during request processing: the user had to submit the form before any validation could happen - and in the cases of some documents, that took quite a while.  KRAD will have the ability to push some of these validations to the client side to be checked via JavaScript, meaning that the user gets feedback on errors much quicker and in a less frustrating fashion.
- *Table Tools* A lot of data in KNS documents gets presented in tables: all the diverse kinds of lookup results, maintenance document collections, KFS accounting lines, KC (*FORTHCOMING: EXAMPLE FROM KC*).  KRAD will make all of those tables more powerful.  It allows client side sorting of several kinds of tables - meaning that users can find the data they want without having to get all the data back from the server.  It allows filtering of tables too.  If the table is editable, it even adds the line in the client side, only pushing it to the server when the user is ready for a full server push.  Tables in KRAD applications will help application users have their complex data just how and when they need it.
- *Themes* Practically the first customization implementing institutions work on in deployed Kuali applications is skinning the site with their own schools' colors.  Rightly so that institutions should be able to customize their colors as tradition dictates.  By heavy leveraging of CSS, a requirement simply of making much rich user interface technology work, it will become much easier to redesign a look and feel of a site to match the expectations of your users...or the desire to show off some school pride.
- *AJAX Enabled Fields* In KNS applications, there are many controls where the user tabs out of the control and information about that value pops up - for instance, a Person lookup where tabbing out of a field where a principalId has been added fills in the full name of the Person so the user gets instant verification that they entered the right authorization name.  IN KRAD, there will be even more support for this kind of information so that the read only information pulled back from the server can be more complete and assist the user that much more in the process of creating documents.

This is just a subset of the way that richer user interface functionality will be integrated into KRAD.  There are many possibilities but one overriding goal: to make it easier for users to interact with applications built on the Kuali platform.

h3. More UI Flexibility

One of the features of the Nervous System users pick up on quickly is the fact that so many screens can be generated purely through configuration.  A business object lookup and inquiry, as well as the screen for maintenance documents: all can be generated entirely from an XML file.  Freeing developers from having to concern themselves with the particulars of the HTML generation for these screens makes the user interface of Kuali applications more consistent, to say nothing of the boost to developer productivity it gives.

However, there were other screens which could not be so easily generated.  Transactional documents depended on perhaps several JSP files, supported by hierarchies of traditional taglets.  Non-document screens had to be coded in JSP as well.  The KNS provided a standard library of taglets - such as documentPage, tab, htmlControlAttribute, and so on - which eased the development task a bit, but the hard fact was that developers still had to spend much more time coding these pages.

It should therefore be little surprise that one of KRAD's major goals is improving this situation.  If transactional documents and non-document screens could make use of the Rich UI support through configuration, that would make it much easier to develop these incredibly important pieces of functionality.

However, as any KNS developer knows, transactional documents are much more flexible than lookups or maintenance documents.  Maintenance documents are almost always stacks of two or four columns, perhaps broken up by a standard subcollection interface.  A transactional document can look like practically anything.  Transactional documents are also the main user interfaces for most Kuali applications.  Therefore, how can the twin goals of developer productivity and user interface flexibility be achieved?

The designers of KRAD take a step back in building user interfaces.  Instead of deferring to the free-form power of a JSP page, isn't it possible to see a page in terms of granular components, grouped together and laid out in a standard fashion?  KRAD will provide precisely this: a series of fields and widgets, all of which are groupable through various means (for example, to create a tab interface already so common in Kuali applications) and sharing a common parent View, which can be configured through XML.  They will be laid out on the page by one of a number of layout managers, a concept familiar from the Java Swing user interface framework.

Each of these granular components will, in turn, be backed by a visual rendering provided by the Apache Tiles library.  Specific tiles can be switched out with custom tiles via Spring, so if customization needs to happen at the JSP level, it can.

These improvements will bring an extraordinary amount of flexibility to the UI rendering system.

h3. Improved Configuration and Tooling

A lot of user feedback about the Kuali Nervous System centered on the repetitive tasks of setting up configuration.  Every business object has an object-relational mapping and an entry in the data dictionary; that entry is made up of field configuration, which gets tediously long fairly quickly; and then there's building the corresponding Java code to be the actual business object.  Even more pieces are added to this recipe when attempting to put together a document.

KRAD is adopting a series of design principles to alleviate some of the work required for this configuration.  KRAD intends to introduce a series of simple-to-use tools to generate configuration based on defaults, letting developers focus on tweaking the configuration to match business logic.

KRAD is also simplifying configuration in general.  The idea of "convention over configuration" will mean that standard defaults will be provided for what had to be manually configured before.  These defaults can be overridden but if they fit the needs of the application, no further configuration will be necessary.  This will cut down a huge amount on the "XML push-ups" required by KRAD application developers, but still provide a great deal of flexibility.

h3. Other Goals

KRAD will not only attempt to improve these areas of development, but it will also improve what it already does so well: provide support for lookups, inquiries, and maintenance documents, by making the layout for all of these more flexible.

KRAD's ultimate goal is to provide the kind of framework which will allow more interactive, more complex application functionality.  This has been pushed especially by the requirements of Kuali Student, an application which needs to handle incredibly complex transactions and yet be usable by a large population, many of whom - such as applying students - completely untrained in its use.  At the same time, KRAD is still going to provide the tight integration with the other components of Kuali Rice, such as Kuali Enterprise Workflow.  Because it is built with such complex requirements in mind, there's little doubt that KRAD is going to be able to support the next generation of open source enterprise applications.

h2. Visual Hierarchy in KRAD applications

One of the most appreciated features of the Kuali Nervous System was that it allowed the set up of the view of certain kinds of documents - Maintenance documents, which maintain rarely changing reference data - inside of the data dictionary for the document.  There was no need to go to JSP: simply configure sections, explain which fields should be on each section, and the KNS generated the view for the document as easily as that.

Of course, the views for maintenance documents did not have too many complexities associated with them.  They showed fields in either two or four columns - depending on if the document was creating a new record or editing an old one - and they supported two levels of collections (collections of collections) on the business object - but no deeper level than that.  Over the years, a great deal of work has been done to make the maintenance document framework more flexible in its view, but the trade off for being so easy to set up was that it couldn't reach the functional complexity that transactional documents allowed.  And of course transactional documents required JSP.

With KRAD, increasing the flexibility of the view so that more of it could be configured became a top feature requirement.

KRAD introduces a concept of a "View" and a hierarchy of pieces which can be added to a view.  A View can represent a whole page or even, in some cases, multiple document pages.  Inside the View, a number of different groups are arranged - some as tabs, perhaps, others as field sets within other groups or even collections of field sets.  Some of these groups finally are made up of fields, controls, and widgets (controls providing an extra level of interactive functionality by incorporating rich user interface techniques).  All of these - views, groups, fields, controls, and widgets - all are Components of a KRAD render, and therefore all implement the org.kuali.rice.kns.uif.Component interface.

Every Component has both a name and an id.  The id is the automatically generated unique identifier for a given Component.  It is assigned by KRAD, but KRAD does follow some naming conventions so that developers can make use of a Component by id.  This is important: the Component id will be what KRAD uses as its wrapping HTML tag's id, and therefore, access to the id means that the Component can be accessed by jQuery's $() method and thus modified programmatically through JavaScript.

How does this automatically generated id get generated in such a way that developers can access it?  It makes use of the name.  The name is the developer's sure fire way to access a Component - both within configuration and, because the id generation process takes the Component name into account, within scripts.  Now, a developer need not name every Component on a page - only those which need to be accessed either by configuration or by script.  Of course, since names are required in configuration, that means that certain elements - most notably Views - must always have a name set by the developer to be used anywhere in the application.

Names do not need to be unique within the whole application - only unique to the model.  This means that two different business objects can create a view called "inquiryView" and KRAD will know the difference.

h3. Containers

In KRAD, a Container is simply a Component with a main job of containing other components to render.  Several Containers have the ability to Contain other Containers - Views can Contain Groups, for instance, and Groups, in turn, can contain any other kind of component - including other Groups.

By default, Containers have three areas: a header, encapsulated in a HeaderField; a footer, which is just a Group, and then any other encapsulated items which make up the body.  The renderHeader and renderFooter properties of the Container can be set to false to turn off heater and footer rendering.  Body rendering cannot be turned off because the point of the Container is to render some kind of contained body elements.  Body elements are also laid out on a page by a LayoutManager, which are [discussed in more detail|#layout_managers].

There are two main Containers: the View and the Group, each of which have various children that add functionality.

h4. Views

As discussed, Components arrange other Components inside a tree.  A Container may hold other Containers, just as the branches of a tree can grow out of other branches.  These Container branches also can hold Fields, and Fields, in turn, can hold Controls, Widgets, or other Fields - the leaves of the visual component hierarchy tree.

And every tree needs a trunk rooted to the ground.  org.kuali.rice.kns.uif.container.View represents a root Container for all visual Components to be rendered for a document or a screen.  It holds the header and footer as well as any navigation that needs to be available for the document.  On multiple page documents, like the Proposal document in Kuali Coeus, each page is a child Group of a single View.

A given model may hold several different Views.  Many business objects in an application will have at least one View to represent the lookup and one View to represent the inquiry - though some business objects will have multiple lookups and multiple inquiries to be used in different contexts.

Each trunk View is rooted down by having name that can be referenced in configuration.  A business object may name Views "inquiryView" and "lookupView" but of course any named can be used.  Best practices dictate that the name of a View should communicate what task within the application that the View is performing.

Common pieces of functionality have rendering encapsulated into a standard View, so they can be reused.  Developers of KNS applications will find it intuitive that there's an InquiryView, a LookupView, as well as a MaintenanceDocumentView and a TransactionalDocumentView.  Applications can also extend views for common views of their own: for example, Kuali Financial Systems will likely extend TransactionalView to create the AccountingDocumentView.

The View also manages data processing for the data that is bound to its components.  The View is configured to know what data needs to be persisted in the session rather than merely the request scope and how form posting should be processed.  It also holds information on how to conduct validation of models.

h5. The View Lifecycle

When a View is rendered, the process from HTTP request to completely furnished HTTP response goes through a standard set of stages.  Together, these stages make up the View Lifecycle and having an understanding of these stages gives the developer the knowledge of where to "hook in" to the lifecycle in order to tweak the rendering of the View in powerful ways.

The rendering of a View is initiated by either an HTTP GET or POST request.  In the case of a GET, the View and the model it is associated with are considered "brand new" - they'll regenerate from scratch.  In the case of a POST, the model is assumed to exist in the session, wrapped in the form; if it does not, then the database is queried to retrieve the latest version of the form.  These three entry points: GET (start with fresh form and View), POST (pull form and View from session), and POST (retrieve form from the database and reconstruct the View) are the three trails of the View Lifecycle. 

!KRADViewLifecycleGET.jpg|border=1!
GET: starting from scratch

Above, we see a diagram of the lifecycle stages for the GET version of the View lifecycle.  A GET request runs through any configured HandlerInterceptors (these are Spring MVC configured versions of Servlet filters, giving the ability to perform actions at a very low level during the request/response lifecycle) and, those complete, creates the form to be populated with data.  That form is then passed to the configured DataBinder which, in addition to populating the form, makes a call to org.kuali.rice.kns.uif.service.ViewService's.getView(String viewId, Map<String, String> parameters).  This, in turn, calls the View's associated ViewHelperService implementation to call ViewHelperService.performInitialization to initialize the View Component and all contained child Components.

Many custom Views will have custom ViewHelperService implementations.  For instance, InquiryView uses org.kuali.rice.kns.inquiry.KualiInquirableImpl (or a child) as its ViewHelperService implementation.  LookableHelperServices will likely also act as ViewHelperServices.

Spring MVC then takes over again, populating the form, which populates all allowed fields possible from the HTTP request parameters or the retrieval of the model from the database, formats and masks or unmasks values, and sets default values.  After that, Spring MVC invokes the form's postBind and finally reaches the controller's method to perform business logic.  All of that complete, the ViewService.updateView is called to make sure that the View can respond to any changes to the form which took place during the call to the controller before the View is rendered.  

ViewService.updateView is responsible for moving the View through the next two stages of the lifecycle: the Apply Model phase, which is carried out by a call to the View's ViewHelperService implementation of performUpdate().  This phase is specifically meant to make changes to the View based on any changes which occurred to the model during the controller phase.  

Then ViewService.updateView calls the ViewHelperService's performFinalize() which, as the method name subtly suggestions, performs the Finalization phase.

The differentiation between the Apply Model phase and the Finalization phase is a bit tricky, but it comes down to responsibility.  The Apply Model phase is all about changing View state based on anything known about the model.  State may change drastically during this phase - often times, the Component tree is changed with new Fields being created.  The Finalization phase is about doing the last bit of tidying up based on the changes that Apply Model just made; the shape of the Component tree is not changed, though each Component in the tree may be modified in response to the changes that occurred during the Apply Model phase.

Still confused?  Here's an example of the responsibility split.  Components have performInitialization(), performUpdate(), and performFinalization() as methods that they can react to as well - every custom Component can react to the stages of the View lifecycle - and Containers take that opportunity to update their layout managers.  TableLayoutManager reacts to both the Apply Model and the Finalization phase differently.  In the Apply Model, it build a header row as well as data rows for every line of the collection that it holds.  Now that it has that collection - ie, now that the model has been set - it can build the actual table.  Then, in the Finalization phase, it does bookkeeping: it figures out the number of columns it's holding.  Obviously, the table needed to be built for that to be completed, and now that work is separated into a different View lifecycle phase to keep each method clean.

That done, Spring runs the form and the View it holds through another set of configured HandlerInterceptors and then the View is rendered into HTML.  The HTTP response is sent back to the user and the lifecycle is complete.

!KRAD View LIfecycle Post Session.jpg|border=1!
POST: form and View in session

If a POST request is made and the formKey parameter finds the associated form in the session, then we have the simplest version of the lifecycle.  There is no View to initialize, so the Initialization phase is simply skipped.  Instead, right before rendering, ViewService.updateView is called, and that moves the View through the Apply Model and Finalization stages before rendering to HTML.

!KRAD View Lifecycle Post No Session.jpg|border=1!
POST: form is not in session, must be reconstructed

If the POST request is made and the formKey parameter does not an associated form from the session, then things get complex.  After the HandlerInterceptors are run through, the form is pulled from the long term session persistent storage in the database, and ViewService.reconstructView is called to create a new View and populate it to what it was before the session died.  ViewService.reconstructView moves the View through all three stages of the lifecycle, one after another: Initialization, Apply Model, and finally Finalization.  But then, as the graph shows, the View continues its normal course.  So after the controller is processed, ViewService.updateService is called as always, and the View moves through the Apply Model and Finalization phases for the second time during the rendering, as the model may well have changed during controller processing.

By understanding the View lifecycle, and how those phases filter down through every Component nested within the View, a fuller understanding of how KRAD interacts with the HTTP request/response cycle is achieved - as well as providing powerful ways to customize that process and knowing just which hooks to place customizations into.

h4. Groups

The Group is the workhorse of Containers.  It basically acts as the branches of the Component hierarchy tree: it can hold any other kind of Component, including other Groups.  Groups are highly flexible: they can represent an entire page of components, a single tab within that page, or even a set of components within the tab.  Every visual element that KRAD renders is going to be a nesting of groups within groups within groups.

Because they're so common, a number of bean definitions for very common Group configurations have been set up: Page, Panel, and MenuNavigation to name just a few. When designing a page, any set of components that share a layout likely belong in a single Group together.

These Group configurations are slightly different from the special groups like CollectionGroup and NavigationGroup.  These Groups extend org.kuali.rice.kns.uif.container.Group to change the plain vanilla Group's behavior.  These will be considered in more detail below.  Configuration of these Group types will differ slightly from regular groups.

For normal Groups, though, despite their ubiquity, there isn't any significant configuration beyond what ContainerBase provides, making the configuration of multiple groups very straightforward.  And again, common configurations will have abstract parent beans already set up - such as Page and Panel.

As promised, there are also specialized kinds of Group types, which change the behavior of groups for use in rendering collections or rendering page navigation.  Let's explore each of these Group types in more detail.

h5. CollectionGroup

A very common practice among rendering frameworks is that all members of a java.util.Collection are rendered using the same set of Components, often within a table.  KRAD naturally associates each member row of the table with a Group - but to accomplish this, a special kind of Group - org.kuali.rice.kns.uif.container.CollectionGroup - was created.  The developer needs to set the collectionName.  There are a number of other properties on CollectionGroup which KRAD populates as it builds the View; the developer need not concern herself with explaining to the CollectionGroup the full path to the collection.

CollectionGroups can also show a set of actions on each row.  An example would be the edit and copy tags that show up in each row of a Lookup.  The CollectionGroup can also render a sequence associated with the Collection, so that each row is numbered "1", "2", etc. which makes it easier for users to differentiate among many rows.  There's also an option to turn header labels on and off for each row.  Finally, a CollectionGroup can have a number of sub-CollectionGroups associated with it, making rendering very flexible indeed.

h5. Navigation Groups

A NavigationGroup is, like a CollectionGroup, a special kind of Group which renders elements used in navigation such as the different pages which make up a multiple page document like the KC Proposal document.  NavigationGroup has one special property: navigationType which needs to be set to one of the values given in org.kuali.rice.kns.uif.UifConstants.NavigationType: either VERTICAL_MENU, which places the navigation at the very left part of the rendered page with links stacked atop each other, or the traditional HORIZONTAL_TABS which renders the links side by side and displays the menu at the very top of the page.

h4. Layout Managers{anchor:layout_managers}

Controls, Fields, and Widgets - and even other Groups - can be thrown into a Container.  The question then becomes how KRAD will lay out those controls.

The designers of KRAD decided to apply a venerable idea present in the first version of the Java Advanced Window Toolkit - the concept of Layout Managers.  A LayoutManager is simply a bean which will build the HTML to display Components with a certain algorithm.

For instance, there is the GridLayoutManager.  The GridLayoutManager places sub-Components into a set of side-by-side columns.  For instance, in when a KNS maintenance document copies a business object, it shows four columns side by side: two columns for the original business object's labels and controls and two columns for the copied object's labels and controls.  In KRAD, GridLayoutManager will provide the support for that kind of layout

GridLayout manager has properties to define numberOfColumns, applyAlternatingRowStyles (often used so that the background color of rows alternate), and renderLabelFieldsSeparately.  Also, each Component has some properties which GridLayout consults in rendering: colSpan and rowSpan which say how many columns or rows in the grid a Component should fill, and width, which is the width the cell the Component is in should take up (often in tables, these are listed as percentages - "50%" would take up half the table's own width).

There's also the BoxLayoutManager, which works just like the BoxLayoutManager in the Java AWT.  A BoxLayoutManager is given an aspect - either HORIZONTAL or VERTICAL - and it renders all sub-Components either side by side in the case of HORIZONTAL or on top of each other in the case of VERTICAL.  A simple enough behavior, but nesting Groups with different BoxLayoutManager aspects provides a simple yet flexible way to arrange sub-Components.  The BoxLayoutManager also provides the ability to set the padding in between sub-Components.

When laying out the rendering of collections, TableLayoutManager provides a lot of power for rendering that data in a tabular fashion. The TableLayoutManager holds a List of Fields and a List of LabelFields.  For each row in a collection, TableLayoutManager will generate a rendered row of the specified Fields.  By default, the LabelFields will be rendered once at the very top; there is a property to repeatHeater, which would cause the Header to show up above every line of Fields. LabelFields default to using regular labels for fields, but by setting the property useShortLabels to true, shorter labels will be used which may conserve valuable screen real estate.

By default, TableLayoutManager provides a sequence field for each row of Fields, at the very left of each line.  This typically shows a number, but through the sequenceFieldPrototype property, a different rendering for the sequence can be shown.  The sequence fields can be turned off by setting the renderSequenceField property to false.  There's also the ability to specify an actionFieldPrototype, which will show up in the rightmost cell of a line of Fields, which contains actions that can be performed on that specific row of the collection.

When rendering a Collection, maybe a TableLayoutManager is too much of a straight jacket for each row.  Perhaps, for each row in a Collection, a whole different Group needs to be specified which can be customized to show the rows in a very different way than the line of Fields TableLayoutManager provides.  A good example comes from the Maintenance Document framework, where collection rows aren't tabular but rather boxed.  In cases like this, there's the StackedLayoutManager which takes a List of Groups and renders each row of a collection within that List of Groups.

The StackedLayoutManager provides a way to add a summaryTitle and summaryFields for each collection row: special information that will be featured prominently in rendering so each row line can be quickly recognized for what data it holds.  There's also a lineGroupPrototype property which can be used to override the Groups that each line will render as.

h3. Fields

Containers are great, but surely wrapping Containers within Containers does not a full-featured application make.  Developers need ways to interact with the users, to put up text and images, to create interactive and informative web pages in their applications.  To accomplish this, there are three families of Components - Fields, Controls, and Widgets - that provide all of the elements that are contained in the Containers.

However, only one of these families of Components can actually be placed in a Group - the Field.  For a Control or a Widget to exist in any Group, they need to be wrapped within a Field somehow.  This makes Fields fundamental - indeed, a large amount of functionality can be created through specifying Views, Groups, and Fields alone and letting Fields figure out what text and which controls are needed on a page.

This also makes Fields terribly diverse.  Think of all the different kinds of not Group visual elements on a page: images, buttons, messages, even blank space.  Each of these elements are encapsulated at different kinds of Fields.

All Fields implement the org.kuali.rice.kns.uif.field.Field interface, an interface that allows pretty much any child to have an associated label.  (Of course, there's a LabelField which itself represents a Label).  Beyond that, Fields can be very different from one another - but again, all are powerful and important for the KRAD developer to be familiar with.

Here's a tour of the Fields that KRAD offers.

h4. ActionField

An ActionField represents an element that gives the user the ability to perform an action.  Many actions kick off a web request/response cycle.  For instance, the submit button of a Form would be represented as an ActionField.  A link in a menu would be represented as an ActionField.  Even rich scripts could be represented as an ActionField as well - some of which do Ajax calls to the server to pull more data into a page, and some of which just perform some client side JavaScript call.  No matter what, an ActionField represents the user telling the application to get something done.

An ActionField must have either a methodToCall or navigateToPageId set.  Setting the methodToCall will end up calling a method on a controller, and the great majority of ActionFields will populate this property.  navigateToPageId would be used for ActionFields which move the user around in a multi-page document, like the Kuali Coeus Proposal.

The actionParameters property is a map of parameters which will be passed along as part of the HTTP request (these parameters are embedded into the page, each as <input type="hidden" /> by the actionParamters.tag - tag which can embed parameters in other contexts as well if a developer is creating custom Tiles).  The actionLabel property represents the text which will be displayed on the button or link.  Finally, ActionField has a boolean property, clientSideCall, which will be set to true if the ActionField represents an action which is handled by Javascript.

h4. AttributeField

An AttributeField represents an Attribute on a page.  This means that the Field will display a Control - for user input into the Attribute - as well as error messages associated with the Field, instructions, watermarks: basically everything the Attribute needs to display correctly on the page. This is easily the most functional of all Fields, so let's look at what all it does in detail.

An AttributeField correlates directly to an AttributeDefinition set on either a BusinessObject or a Document.  Every AttributeDefinition represents a single property on its related object.  The AttributeDefinition then defines a great deal of information about that property: what kind of Control it should be associated with, the maximum length of the input, labels, validation patterns, and how to format the property - so that if the property represents non-String data, it can be converted into the data type of the property.

The vast majority of properties which populate the pages of a KRAD application will be represented by DataDictionary AttributeDefinitions.  KRAD's support of translating AttributeDefinitions to all of the equivalent rendered HTML on a page through the AttributeField is very powerful.

There are several encapsulated properties at the heart of the AttributeField.  Let's start with the most basic: propertyName.  This is the name of the property of the form which the AttributeField represents.  AttributeField uses propertyName merely as a pointer to the binding in the form where it can find the value it represents.  That's all it really needs to know about the value in question; KRAD tracks the full data binding field leading to the AttributeField (setting it in the bindingInfo, covered below), and that is communicated to Spring MVC during population or rendering.  This way, the model holds the data and all AttributeField has to know is where to find the data - it need to do any other work to hold the data beyond that.

This leads to an unexpected benefit.  In the KNS, formatted version of the values had to be held in the objects which rendered the value and then the form had to format the value back during population - all of this was controlled by the formatter in the data dictionary.  Spring MVC lets developers configure the formatting within the MVC configuration itself, meaning that values will be converted to their proper formats during data binding and during rendering: a big simplification for the developer.  

Next comes the control which, of course, is the associated Control Component, allowing the user to input data into the value.

Of course, the DataDictionary AttributeDefinition defines a lot of text about the attribute: the label and summary texts as well as a possible default value.  The AttributeField holds all of these as well.  The AttributeField also holds the most important validation defined in AttributeDefinition - that of maxLength.  (It's the most important because if values exceed maxLength, they will likely cause exceptions when inserted into the database.)

AttributeField also holds errors associated with the attribute.  If the Control associated with this attribute put in data that failed validation, or if a special warning message needs to be associated with the attribute, AttributeField encapsulates that as well, by holding these errors in an ErrorsField.  There's also an errorPlacement property which tells KRAD what aspect of the rendered field to render errors to.

The AttributeField also holds the Formatter responsible for taking Strings in the HTTP request and translating them into different data types.  If the attribute's control is a MultiValueControl with an OptionsFinder, the AttributeField also holds that.

Finally, the AttributeField has an org.kuali.rice.kns.uif.BindingInfo object which holds information on how the attribute should be rendered to HTTP responses and from HTTP requests.  Data bindings are discussed [below|#data_bindings] but the short of it is that AttributeField remembers its path in the complex tree of the document and can use that information to get data back and forth to the page.  Developers don't need to worry about those details.

The AttributeField, of course, populates all of these values precisely from the data dictionary.  However, any AttributeField can override any of the data dictionary's values by having the equivalent properties set in configuration.  This makes AttributeFields all the more flexible.

That's a lot of information for AttributeField to hold.  What does AttributeField render?  First, it renders a Label for the attribute, often by creating a LabelField which then can be rendered beside or above the Control as the parent View demands.  It also renders summary information for the AttributeField.  Obviously, the AttributeField will render a Control for the attribute - assuming the attribute hasn't been rendered hidden or read only by some other participant in the rendering process, such as a KIM permission.  When rendering a Control, the AttributeField will render a classic Kuali quick finder magnifying glass icon for attributes which need separate lookups, and AttributeField will render any specified constraint text for attributes which demand a specific input format.  AttributeField will also render help for the attribute if applicable.

Certainly, all of this makes AttributeField the most powerful of Fields, but, importantly, it has a single concern: the proper rendering if an attribute to a View.  KRAD gets a lot of power by putting metadata about attributes on documents and business objects into the Data Dictionary.  AttributeField concentrates that power by offering a focused point which coordinates the full rendering of the attribute.

h4. BlankField

A BlankField represents empty visual space on a page, typically to act as a place holder in the layout  For instance, think of a collection of accounting lines in a KFS document.  The very bottom line is a total line, where the totals line up under the amounts on the lines, very near the right.  Blank space is needed to push the totals over to line up correctly, and that is what BlankField provides.

h4. ErrorsField

This Field represents error messages, warning messages, and info messages which should be rendered in a Container.  Each set of messages - error, warning, and info - can have a unique title set as well as a unique CSS class (such that errors can show up bolded, say, and warnings can be displayed in italics).

The ErrorsField does have a property keyMatch, which, as developers of KNS applications will recognize, is the prefixes of the errors which should be displayed within the current field.  Only messages relevant to children will be rendered by the ErrorsField.  However, there is a difference here from the KNS: in KRAD, a Container knows the paths of all Fields and ultimately all Controls it has rendered.  Therefore, Containers with ErrorsFields will typically set the keyMatch itself with the default values.  The only reason a developer would need to set this property would be in the case of some special overriding.

h4. GroupField

A GroupField encapsulates a Group for display without headers and footers.  It has one property, group, which should be injected with the Group to display.  If a Group needs to be displayed without headers and footers inside another Container, then likely, a developer will use a GroupFiled to wrap the Group and then place it inside the containing Group.

h4. HeaderField

A HeaderField will display Header text on a page.  Headers often create a sense of visual hierarchy to a page and therefore are very important structural markers.  HeaderFields have passed in a headerLevel: a number between 1 and 6 representing the importance of the Header on the page (1 being the most important, 6 being the least) and headerText, which is the text the header will display.


h4. ImageField

The ImageField renders an image.

h4. LabelField

A LabelField represents a Label.  Labels are most often associated with controls.  A text control with no explanatory text to say what kind of data is expected to be filled in isn't very useful; LabelFields give users the general gist of the Control.

In a great majority of cases, AttributeField will automatically create a LabelField when it displays.  There are rare times when Controls are created outside of attribute definitions, however, and in those cases, a LabelField will have be configured manually.  There may also be cases when an application needs to override the default label by specifying different message text; LabelFields allow that as well.

A LabelField has a property for labelText.  There's also a property for labelForComponentId - the id of the Component which the Label relates to; setting this helps with accessibility issues for sight-disabled users.  There is a boolean property on whether to render a colon or not, renderColon, and finally an encapsulated MessageField, requiredMessageField, which should be populated if the Label represents a required Control.

h4. LinkField

A LinkField represents a Link on a page and is rendered with an HTML <a> tag.  It needs to have its hrefText set to the target of the link and linkLabel set to the text which will be rendered as the link.  There is also an optional target attribute which can be used to set where the linked content should open up; for instance, setting target to "_blank" will open the link into a new browser tab or window.

h4. MessageField

A messageField displays text on the rendered page within a span.  Its messageText property holds the text which it will display.  It also has a messageType property which helps uniquely identify all messages of this type on the screen.

Those are KRAD's fields.  But how do Controls, Fields, and Widgets get the data they should display during render or populate the underlying page model when a request occurs?  That happens through Spring's Data Bindings mechanism.

h4. Fields and Messages

Several Fields display various kinds of text to the user: not only MessageField but also LabelField, HeaderField, ErrorsField, and AttributesField.  In practically all of these cases, the text to be displayed can be added via a property.  However, that's not the preferred method of getting text.  As Java developers well know, text should come from a properties file which contains all the messages used in the application.  These can be switched out easily, allowing for easy customization and internationalization.  Given this, KRAD helps developers use messages.

For example, let's say a Group has a HeaderField for its header.  The text could be passed in via property - or KRAD will simply take the name of the group (say, "TravelAccount-Officers") and look in the configured messages for a property "TravelAccount-Officers.title".  A label for an AttributeField would look for "\{group name\}.\{attribute property name\}.label".  This convention will make it much easier to assign properties for all the text used in an application built on KRAD.

h3. Data Bindings{anchor:data_bindings}

One of the major changes that KRAD will bring will be a move away from Apache Struts 1.2\+ to Spring 3.0's Web MVC.  This means many things: changes to Controllers, some updates to Forms - though the KRAD team is working on scripts to make these changes as painless as possible.

A major concept invoked by WebMVC is that of data binding.  Data binding simply means that parameter names from a request will be mapped into the form.  Spring handles much of this automatically, by simply using the Form as the root of a property tree and then mapping nested, indexed, or even indexed and nested properties into the form.

Spring does need help on mapping parameters into classes it doesn't handle automatically - KualiDecimal, for instance.  In these cases, Java provides PropertyEditors which can convert Strings into complex objects.  There are a number of mechanisms that help Spring associate a PropertyEditor implementation with a complex object like KualiDecimal.  Commonly used PropertyEditors, like the one used with KualiDecimal, will be globally registered in org.kuali.rice.kns.web.spring.UifConfigurableWebBindingInitializer.

The Spring documentation covers how it uses data bindings in much more detail [on the SpringSource website|http://static.springsource.org/spring/docs/2.0.x/reference/validation.html] Spring has a heavy reliance on this mechanism throughout its source code beyond populating form data; thankfully, Spring's developers exposed their standard way to populating business objects as an easy way KRAD can populate a form from an HTTP request's posted variables.

As KRAD renders a page with form data, it will properly generate the data binding path that will properly populate the form when the page is submitted.  It will create indexed property names for values within collections and it will create nested names for all the attributes on a page...meaning that for the most part, developers will never concern themselves with data binding - KRAD will just make it happen in the background.

What if the developer of a new Component wants to participate in the data binding process?  In that case, the new Component should implement the org.kuali.rice.kns.uif.DataBinding interface.  This interface has one method, getBindingInfo(), which returns a populated instance of org.kuali.rice.kns.uif.BindingInfo.  BindingInfo encapsulates a number of properties:
* bindingName - this is the name of the property to bind to, either within the form or the model.
* bindByNamePrefix - this is a prefix generated by KRAD, typically when rendering a Collection.  Basically, it generates the proper name and index (for example, "collectionItem[0]") and holds that for the sake of the current binding.
* bindToForm - when true, this makes sure that the given property is bound to the Struts MVC form itself.

Easily, the most important Component implementing this interface is the AttributeField.  AttributeFields display and read data on business objects and documents, so naturally they participate in the data binding process.

h3. Controls

Anyone who has developed a KNS application knows that property attributes in the data dictionary for a business object or document can be associated with a control - a way to get input for the attribute.  Normal web controls include text fields, text areas, drop down select boxes, and more.  Much like the KNS, KRAD associates each of these input types with an object implementing the org.kuali.rice.kns.uif.control.Control interface.

h4. TextControl

An org.kuali.rice.kns.uif.control.TextControl represents a simple HTML text field, mapping to an <input type="text" /> tag.  Simple, indeed, but widely used as well - easily the most frequently used of all Controls.

TextControls have two major properties.  First, the size property limits the text that can be entered in the TextControl to a certain size.  There is also a boolean datePicker property which decides if a DatePicker Widget should be associated with this TextControl - ie, that the TextControl is to act as the input for a date.

h4. TextAreaControl

This Control represents a text area on the page, a control which accepts large amounts of text.  It maps to the HTML <textarea> tag.  TextAreas can be associated with a BigTextArea Widget *FORTHCOMING: real widget name* which pops up a window allowing the user to enter text in a large space without losing space in the page's real estate.  This functionality is used extensively in Kuali Coeus.

h4. FileControl

A Control which uploads files.  It maps to the HTML <input type="file" /> tag.

h4. HiddenControl

This Control represents an attribute which stores its value in HTML, so that its state can be maintained, but which does not render in any meaningful way that an application user can see.  It maps to the <input type="hidden" />

h4. Checkbox Control

The org.kuali.rice.kns.uif.control.CheckboxControl is KRAD's favored way of getting input for boolean values.  It maps to an <input type="checkbox" /> HTML tag but it also adds a hidden variable to tell the input that the checkbox was rendered.  If the hidden field is present in the request parameters but not the checkbox itself, then KRAD knows to set the value on the business object as false.  On lookup fields, CheckboxControls convert into groups of radio buttons with values "Yes", "No", and "All".

Developers who worked with checkboxes in the KNS may remember that KNS rendered checkboxes as two controls - the <input type="checkbox" /> and an associated <input type="hidden" /> to say that the checkbox was present.  This was done because if a checkbox isn't checked, it actually passes nothing into the HTTP POST's variables and since the KNS pulled values from the parameters passed in, it would miss unchecked checkboxes and therefore fail to set certain values to "false."  The hidden variable forced the KNS to look for the associated checkbox and set the value no matter if the checkbox parameter was present in the POST or not.  With KRAD moving to a base of Spring MVC, however, this will no longer be necessary as Spring's rendering of the checkbox handles the checkbox parameter check.

h4. MultiValue Controls

Certain controls let the user choose among multiple values.  All of these controls extend org.kuali.rice.kns.uif.control.MultiValueControlBase.  To make these controls work, KRAD needs to know what the set of choice values are and MultiValueControlBase supports those through the property options which takes a java.util.List of venerable org.kuali.rice.core.util.KeyLabelPair objects.  Each KeyLabelPair maps a code value to a the display label which is what the user sees for the control (these two values could be the same but often times, the label is a more user-friendly representation of the key code).

This List is often passed in via a bean configuration.  This means that KRAD will be able to use an innovation from the KC team which created a generic bean to create the List of KeyLabelPair objects and then configured the bean with the business object and fields to tap.  Bottom line: any MultiValueControl will be much easier to configure in KRAD than in the KNS.

h5. SelectControl

A SelectControl presents a list of clickable elements to the user, where each clickable element shows a label.  These controls map to the HTML <select> tag.  By default, only one value in a SelectControl can be chosen, but by setting the multiple property to true, multiple rows can be chosen.

The SelectControl has three properties.  The first is options - a List of org.kuali.rice.core.util.KeyLabelPair objects for the choices which should appear in the given SelectControl; this property is required.  The second is multiple, a boolean value which defaults to false.  If multiple is set to true, then the SelectControl will allow the user to select multiple values in the box, by ctrl\- or cmd-clicking each of the various option they want to select.  If multiple is true, then likely the developer will want to select the size property: the number of options which should show at once if the SelectControl allows multiple option selection.

h5. RadioGroupControl

A RadioGroupControl represents several <input type="radio" /> HTML tags.  Unlike the SelectControl, which displays all of its values as one visual element, the RadioGroupControl represents each label as a value sitting by a friendly button which can be pushed.  Also in contrast to the SelectControl, RadioGroupControls only ever let one value at a time be chosen.  They're fairly rare in traditional KNS applications, being used only where there's an extremely limited number of choices, one of which must be unequivocally chosen.

RadioGroupControl has but one special property - options, which, just like SelectControl, is injected with the List of KeyValuePair objects that represent the choices the user will have.

h3. Widgets

A Widget is a grouping of several related rendering items which provide a single functionality.  Take, for instance, the quickfinder: the useful magnifying glass icon that takes a user to an appropriate lookup for a field.  Here, we have an image and a created link: together, that functionality forms a widget.  Widgets are something like Controls in that each has a single function, but Widgets don't map directly to to a single HTML input.  Several widgets, though, are used in conjunction with Controls to make those controls more powerful.

As Widgets are functionality that do not map directly to HTML tags, client side behavior can be encapsulated as a Widget.  For instance, the DatePicker widget is an icon that pulls up a JavaScript based calendar to populate a TextControl which maps to a Date in the model.  Because it's a single piece of functionality wrapping a script, a Widget is in charge of rendering it.  jQuery plugins to be rendered are also associated with special Widgets.

h4. BreadCrumbs

Bread crumbs remember the context of a page and provide a set of links that can take the user back to a "root" page.

For instance, in a hypothetical KRAD application, a user goes from the portal to a lookup.  The current context is the lookup and the root is the portal, so the breadcrumbs will provide a link back to the portal.

On the lookup, the user clicks a quick finder to lookup a secondary business object.  In this hypothetical scenario, the business object specifically is a Kuali Enterprise Workflow document type.  On this lookup, there are links back to the portal and the previous lookup.

As the user gets deeper into the nest of functionality, the breadcrumbs provide links to get the user back to all previous steps in the process.  This makes it much easier for users to know where they are in the application and to get back to previous steps in the process - thus allowing users to escape from confusing or mistaken steps in a process.

h4. DatePicker

This widget is often used in conjunction with a Text Control if the data binds to a date.  It basically adds an icon that will shows a pop-up calendar on click, thus making it easier for the user to enter date related data (and guaranteeing that if the user clicks the calendar, the date will be in the format that the Kuali application accepts).

h4. Help

This is an icon which pops up a window with explanatory text to instruct the user.  The Help widget is context aware - it knows which kind of help to display: whether it is help for an entire document (that is, the icon is placed next to a document title) or help for a single field (in which case the icon is rendered next to the field).  The source of the help is also configurable: whether it comes from text in a parameter or from a static url.  Finally, Help can be extended so that as different help contexts exist in client applications, they can be added.

h4. Inquiry

This widget represents a direct inquiry icon: an icon which, when pressed, opens an inquiry page based on values in Controls (rather than the traditional inquiry which is a link in lookup results).

h4. QuickFinder

The traditional Kuali magnifying glass icon has been around since the very first version of the Kuali Financial System: it's as venerable as Kuali functionality gets.  Rendered next to a field, it opens a lookup so that users can choose an appropriate value for the field.


h3. Component Architecture

Now that we've explored each component type in detail, let's see what they share and what all KRAD visual elements have in common. The table explains all of the properties inherited by all children of org.kuali.rice.kns.uif.Component.

|| Property | Type | Explanation ||
| id | java.lang.String | The Component's unique name within the application space.  This property is autogenerated by KRAD and should never be reset by the developer |
| componentTypeName | java.lang.String | The type name of the Component: "Text" for the Text Control, for instance, or "Quickfinder" for the Quickfinder widget.  This helps KRAD find the tile associated with the Component in the data dictionary.|
| template | java.lang.String | As discussed in [Tiles as Templates|#tiles_as_templates], the path to the JSP representing the tile for this component |
| componentInitializers | List<org.kuali.rice.kns.uif.initializer.ComponentIntializer> | A list of all ComponentInitializers that should be run on the component upon initialization.  Covered in more detail in [Component Intializers|#component_initializers] |
| name | java.lang.String | The developer set identifier for this Component, which can be used to refer to this Component either in data dictionary configuration or in scripts. |
| render | boolean | Determines if this Component should be rendered. |
| hidden | boolean | Determines if the Component should be rendered in a way not visible to the user, for instance via an <input type="hidden"/> tag. |
| readOnly | boolean | Determines if the Component should be rendered as readOnly (in the case of Controls, this means just data is shown-there is no ability to input a different value) |
| required | java.lang.Booolean | Determines whether the Component is required to be filled in.  Again, typically used in conjunction with Controls. |
| style | java.lang.String | The style attributes of the Component.  The value of this will be rendered in a "style" attribute on the Component. |
| styleClass | java.lang.String | The name of the CSS class which this component will render in. |
| width | java.lang.String | The width of the Component, in any measurement that HTML supports |
| align | java.lang.String | The horizontal alignment of the Component within its Container. The allowed values are "left" (which is the default for Western character sets); "right"; "center"; and "justify" which attempts left and right alignment on lines. |
| valign | java.lang.String | The vertical alignment of the Component within its Container. The allowed values are "baseline" (which aligns the baseline of the characters of this Component to align with the baseline of the parent - this is the default); "sub" (making the text align as subscript); "super" (making the text align as superscript); "top" (which aligns the text of the Component with the top of the tallest element - text or non-text - on the rest of the line); "text-top" (which aligns the text of the Component with the top of the tallest text element on the rest of the line); "middle"; "bottom"; or "text-bottom" (which, like "text-top" aligns with the bottom of only text elements on the rest of the line). |
| colSpan | int | The number of table columns in the parent Container that this Component will span. |
| rowSpan | int | The number of table rows in the parent Container that this Component will span. |
| componentDecorator | org.kuali.rice.kns.uif.decorator.ComponentDecorator | The decorator for the component, as discussed in the section on [Component Decorators|#component_decorators]\\ |
| decoratorChain | org.kuali.rice.kns.uif.decorator.DecoratorChain | Set by KRAD, this property contains an encapsulation of the decorated Component - ie, this - and the chain of decorators which are supposed to affect the rendering of that Component. |

h4. Tiles as Templates{anchor:tiles_as_templates}

In the Spring configuration for every Component, a template is injected.  This is a path to a JSP page which is actually responsible for rendering the Component.  Each KRAD JSP page utilizes Apache Tiles to do the rendering.  This means that variables are passed around from tile to tile in a standard fashion, using the tiles:putAttribute tag for writing and the tiles:useAttribute tag for reading.  Because variable passing is standardized, Tiles can nest JSP pages within each other in a much more flexible manner than standard JSP tags.

This is incredibly important because the injection of a Tile template path into the Spring configuration for a Component means that rendering of all Components is entirely customizable.  If, for instance, an application developer wanted to make a change to every single text field rendered through the application - a change which could not be achieved through the already incredible flexibility of CSS stylesheets - then the developer would simply override the TextControl bean and set the template property to point to a different JSP template.  KRAD would still pass all the variables it normally would to the new Tile.  Of course, the switching out of a major Control likely won't happen too often.  But adding a new Component - a Widget that makes some innovative use of the jQuery UI library, say - is incredibly easy to accomplish in KRAD's Tiles scheme.  Simply create a Java bean which extends the WidgetBean base class and then create a Tile that renders the new Component and the new Component is available for use in the application.

Furthermore, since each Component bean handles its own rendering Tile template, gone are the generic KNS tags - like kul:rowDisplay and kul:htmlControlAttribute - which depended on complex logic within the tag itself to decide rendering and which were nearly impossible to customize.  It's a huge step forward for application developers to be able to customize the user interface of their application.

Every tile associated with a Component expects the instance of the Component configuration passed in.  For instance, the Group tile (web/src/main/webapp/krad/WEB-INF/jsp/container/group/group.jsp) expects an attribute called "group" which holds the Group's configuration.  By passing in the actual configuration bean and adhering to a standard contract, templates can be switched out without breaking caller's calls to them.  Let's look at each of the template contracts.

||Template Type||Expected Attributes||
|View Container| * *view* - the view to be rendered by the tile |
|Group Container| * *group* - the group to be rendered by the tile |
|Layout| * *items* - the items which are to be laid out within the rendered tile
* *manager* - the instance of the LayoutManager implementation responsible for laying child Components out within the tile
* *container* - the container which holds the items being laid out |
|Field| * *field* - the field to be rendered by the tile |
|Control| * *control* - the control to be rendered in the tile
* *field* - the AttributeField which the control is associated with |
|Widget| * *widget* - the widget to be rendered by the tile
* *componentId* - the id of the component this widget is supporting |
|Decorator| * *decorator* - the decorator that this tile will be rendering 
* *decoratorChain* - the chain of decorators the to-be-rendered decorator is a member of, with the component being decorated at the beginning of the chain
* *templateParameters* - a Map of parameters passed to the decorator's template to control various dynamic aspects of rendering |
|State| These templates simply store information which should be passed on POST requests; the View automatically decides which State templates to render.  There are no expected attributes. |

h4. Component Initializers{anchor: component_initializers}

It's often useful for Components, upon initialization, to perform different initializations in different contexts.  For instance, when an AttributeField which uses a checkbox as its Control is rendered in a Lookup, that checkbox should be rendered as special radio button group (offering the choices "Yes", "No", and "Both").  A ComponentInitializer applied to the LookupView can traverse the Component tree, switching out these instances of AttributeField without affecting any other View contexts.  Any Component can have associated with it a List of org.kuali.rice.kns.uif.initializer.ComponentIntializer implementations, and that List of initializations will change within the different View contexts that it participates in.

Each ComponentIntializer has two methods which must be given implementations.  getSupportedComponents returns the Class of the Components which support the initializer.  performInitialization is passed in the parent view and the Component that this initializer is working on, and that is where the manipulation of the Component tree is carried out.

h4. Component Decorators{anchor: component_decorators}

Components are powerful, it's true, but putting too much power into a single Component often violates the principle of separation of concerns.  Classes which implement org.kuali.rice.kns.uif.decorator.ComponentDecorator provide a little extra functionality to another Component, without making the code for that wrapped Component more complex.

For instance, many Groups represent tabs which can be opened or closed.  A Group was written simply to be a simple Container of Components - making all of them understand collapsing behavior seems a bit overkill, especially considering how general Groups are.  Therefore, a ComponentDecorator - org.kuali.rice.kns.uif.decorator.AccordianDecorator - was created to add collapsing behavior to Groups.  Parent Containers which want to apply collapsing behavior to child Groups will add the name of the Group and the ComponentDecorator to a map called "componentDecorators" and the collapsing behavior will be added during rendering.

Each Component can have a single ComponentDecorator set on it as a property.  However, each ComponentDecorator allows a single ComponentDecorator to be added as a property, and therefore, a long chain of ComponentDecorators can be created.  KRAD will support clever ways to flatten out that chain when configuring, so that each ComponentDecorator will have its own properties set separately, without having to refer to the chain.