{toc}

This tutorial is designed to start with the concept of a page in a KRAD application and build all of the configuration to turn that page into an actual View. In this example, we'll build a conference reservation form, starting with a sketch of what we want the form to look like and then building up the pieces of the configuration.

First, we look at the Java classes we need to create to handle data mapping for our page: a form, a controller, and a view.  Then we build the configuration which maps the data objects we want to populate with data to the view - first splitting the page into major groups and then associating fields with properties.

h1. Views, Controllers, and Forms

KRAD uses Spring MVC to interact with the web, and so it makes a lot of sense that the first design decisions in building a KRAD page all have to do with the M, the V, and the C: the Model (called, in KRAD, a Form); the View; and the Controller.

h2. Base Data Model and Forms

The Form is an excellent place to start.  Looking back at our page, we have to expect that several data objects already exist to put data into the database.  There must be a Contact business object, as well as a ConferenceGuest that we have a collection of.  Some wise developer likely created a single record, ConferenceParty, to meld that information together.  ConferenceParty then has a many-to-many relationship with ConferenceTracks to hold the "Interests" section, and there's likely an optional AcademicInstitution object.  In short, the classes probably look like this:

{code:java}
class Contact {
    protected Integer contactId;
    protected String companyName;
    protected String contactName;
    protected String contactEmail;
    protected String contactPhone;
    protected String addressLine1;
    protected String addressLine2;
    protected String city;
    protected String state;
    
    // getters and setters for all!
}

class ConferenceGuest {
    protected Integer conferencePartyId;
    protected Integer partySequenceNumber;
    protected String name;
    protected String email;
    protected String phone;
    
    // getters, setters
}

class ConferenceTrack {
    protected String trackCode;
    protected String trackName;
    protected String sortCode;
    
    public final static String SORT_PROPERTY = "sortCode";
    
    // getters and setters
}

class AcademicInstitutionInformation {
    protected Integer institutionInformationId;
    protected String institutionFundingTypeCode;
    protected String name;
    protected Integer numberOfStudents;
    
    // getters and setters
}

class ConferencePartyInterests {
    protected Integer conferencePartyId;
    protected String trackCode;
    
    // setters and getters
}

class ConferenceParty {
    protected Integer conferencePartyId;
    protected Integer contactId;
    
    protected Contact contact;
    protected List<ConferenceGuest> guests;
    protected List<ConferencePartyInterests> interests; // sorted by ConferenceTrack.sortCode
    protected AcademicInstitutionInformation academicInstitutionInformation;
    
    // these need getters and setters
}
{code}

All of these classes are instrumented either with JPA annotations or OJB metadata, and they likely have more relationships than spelled out here.  Also, data dictionary entries should be created for each of these data objects.  [ ANY NEED TO SHOW THESE CONFIGURATIONS? ]  Still: this is an excellent start to the data model.

A KRAD form is simply a class which extends org.kuali.rice.kns.web.spring.form.UifFormBase.  The form wraps the data model into an convenient object associated with the page.  In this case, our form will definitely need to hold a ConferenceParty data object since that is the data that the page is meant to populate.

This particular form, though, needs to hold more than that.  Any data exposed on the View should exist on the form.  What other data is there?  First, there's that "Academic Institution" check box, which determines if the Academic Institution group is visible or not.  This isn't held by any of the data objects above, but it needs to be held somewhere.

There's also the case of lists shown on the screen.  In the case of "State," there should be a values finder which will provide the state codes; a similar situation exists with the funding type for the Academic Institution.  However, in the case of Interests, we need to hold a list of all the ConferenceTrack objects sorted.  [ JAMES - TRUE THAT? COULD THIS BE A VALUES FINDER AS WELL? ]  This List will be held on the form as well.

Given that, our form should look something like:

{code:java, title=edu.sampleu.conferencesignup.web.spring.form.ConferenceSignupForm}
 1. class ConferenceSignupForm extends UifFormBase {
 2.    protected ConferenceParty conferenceParty;
 3.    protected List<ConferenceTrack> conferenceTracks;
 4.    protected boolean academicInstitution;
 5.    protected BusinessObjectService businessObjectService;
 6.
 7.    /** Always Javadoc! */
 8.    public ConferenceParty getConferenceParty() {
 9.      return conferenceParty;
10.    }
11.
12.    public void setConferenceParty(ConferenceParty conferenceParty) {
13.      this.conferenceParty = conferenceParty;
14.    }
15.
16.    public boolean isAcademicInstitution() {
17.      return academicInstitution;
18.    }
19.
20.    public void setAcademicInstitution(boolean academicInstitution) {
21.      this.academicInstitution = academicInstitution;
22.    }
23.
24.    public List<ConferenceTrack> getConferenceTracks() {
25.      if (conferenceTracks == null) {
26.        conferenceTracks = (List<ConferenceTrack>)businessObjectService.findAllOrderBy(ConferenceTrack.class, ConferenceTrack.SORT_PROPERTY, true);
27.      }
28.      return conferenceTracks;
29.    }
30.
31.    public BusinessObjectService getBusinessObjectService() {
32.      return businessObjectService;
33.    }
34.
35.    public void setBusinessObjectService(BusinessObjectService businessObjectService) {
36.      this.businessObjectService = businessObjectService;
37.    }
38. }
{code}

Not hard at all, but it holds all the data needed to properly render the View.  [ FORMS ARE SPRING BEANS, RIGHT?  HOW TO INJECT SERVICES?  WHY DOES DOCUMENT CONTROLLER USE KNSLOCATOR? ]

h2. Controllers

Next is the controller.  In this case, we extend org.kuali.rice.kns.web.spring.controller.UifControllerBase.  Unlike with UifFormBase, UifControllerBase has an abstract method which we are forced to override: createInitialForm.  This method takes in the request as a parameter and returns a child of UifFormBase.  Since ConferenceSignupForm is already complete, this shouldn't be any problem.

UifControllerBase also has a number of methods which we can call from our View.  For instance, it has an addLine method which it would be helpful to call for adding guests to that collection.  However, it does not contain methods which respond to our submit, save, and cancel buttons.  Basically, any element on our View which could initiate a post back to the server should have a method on the controller for it.  The names for these methods change but they all have:
* a standard annotation associated with the method: @RequestMapping, which takes a method (the HTTP method to use), and params, which should include the "methodToCall" parameter which should initiate a call to the given controller method
* a standard return type - controller methods responding to View actions should always return an instance of org.springframework.web.servlet.ModelAndView
* a set of standard parameters: one for the form, for the BindingResult, and for the request and response.  The form parameter should be annotated with @ModelAttribute("KualiForm"), which means that the form will be pulled from either the request via the key "KualiForm" [ JERRY - TRUE THAT? ]

Finally, a Spring MVC controller class must have the @Controller annotation assigned to it as well as a class-wide @RequestMapping parameter which gives the URL (or at least, the portion of the URL after the server name) which will result in calls to the controller class.  This can be configured in Spring XML as well, but throughout Rice, annotations have been used.

Given that, let's take a look at our controller:

{code:java,title=edu.sampleu.conferencesignup.web.spring.controller.ConferenceSignupController}
 1  @Controller
 2. @RequestMapping(value = "/conferenceSignup")
 3. class ConferenceSignupController extends UifControllerBase {
 4.   public UifFormBase createInitialForm(HttpServletRequest request) {
 5.     return new ConferenceSignupForm();
 6.   }
 7.  
 8.   @RequestMapping(method=RequestMethod.POST, params="methodToCall=submit")
 9.   public ModelAndView submit(@ModelAttribute UifFormBase uifForm, BindingResult result, HttpServletRequest request, HttpServletResponse response) {
10.     // do submit stuff...
11.     return getUIFModelAndView(uifForm);
12.   }
13.  
14.   @RequestMapping(method=RequestMethod.POST, params="methodToCall=save")
15.   public ModelAndView save(@ModelAttribute UifFormBase uifForm, BindingResult result, HttpServletRequest request, HttpServletResponse response) {
16.     // do save stuff...
17.     return getUIFModelAndView(uifForm);
18.   }
19.  
20.   @RequestMapping(method=RequestMethod.POST, params="methodToCall=cancel")
21.   public ModelAndView cancel(@ModelAttribute UifFormBase uifForm, BindingResult result, HttpServletRequest request, HttpServletResponse response) {
22.     // do cancel stuff...
23.     return getUIFModelAndView(uifForm);
24.   }
25. }
{code}

[ WHAT ABOUT START METHOD THAT INQUIRY CONTROLLER USES?  IS THERE A BASE "GET" METHOD DEFINED, WITH NO METHODTOCALL PARAM? ]

Of course, in practice, this code would have thorough documentation; the controller, as well, would likely delegate most of the work for the submit, save, and cancel methods out to a separate service defined in Spring [JERRY, ARE WE STILL RECOMMENDING THIS NOW THAT THE CONTROLLER LIVES IN SPRING?  I'M GUESSING SO JUST FOR THE SAKE OF GRANULARITY]  However, this code, while incomplete, does offer several interesting features.  First, on line 1, the @Controller annotation lets Spring know that this class is a controller, and on line 2, the @RequestMapping tells Spring that any request which goes to /conferenceSignup should be calling methods on an instance of this controller class.

As can be seen from lines 6-7, lines 12-13, and lines 18-19, each method defined has the @RequestMapping annotation, they all return ModelAndView objects, and they have the standard set of parameters.  The params portion of the @RequestMapping on those lines is very important.  No matter which button is pushed, it will always route to the same URL: /conferenceSignup.  There needs to be some way for the button to differentiate precisely which controller method it wants to use.  KRAD's ActionField will do that by rendering a query parameter with a methodToCall value.  For instance, the "Submit" button will route to "/conferenceSignup?methodToCall=submit".  That will match the @RequestMapping's params value, and the submit method will be called.

On lines 9, 15, and 21, that UifControllerBase provides a convenience method, getUIFModelAndView, which takes the UifFormBase and builds the ModelAndView object to return. 

That completes the controller.  Finally, we turn to View: the easiest of all, since only Spring configuration is needed to set the View up.

h2. Views

When a Rice application is created, there are typically three directories for each module which hold data dictionary files: one for data object definitions including business objects; one for document definitions; and one for UIF definitions.  In the UIF definitions' folder, a new file should be created - ConferenceSignupView.xml.  In that, a bean will be created which defines the "look" of the page, as well as mapping it to ConferenceSignupView as well as the url that ConferenceSignupController responds to.

{code:xml,title=ConferenceSignupView.xml}
 1. <?xml version="1.0" encoding="UTF-8"?>
 2. <beans xmlns="http://www.springframework.org/schema/beans"
 3.   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
 4.   xmlns:p="http://www.springframework.org/schema/p" 
 5.   xsi:schemaLocation="http://www.springframework.org/schema/beans         
 6.                       http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
 7.
 8.  <bean id="CondferenceSignupView" parent="ConferenceSignupView-parentBean" />
 9.  <bean id="ConferenceSignupView-parentBean" abstract="true" parent="FormView">
10.    <property name="id" value="ConferenceSignupView" />
11.    <property name="title" value="Conference Signup" />
12.    <property name="items">
13.      <list>
14.        <!-- this will be filled in over time -->
15.      </list>
16.    </property>
17.    <property name="formClass" value="edu.sampleu.conferencesignup.web.spring.form.ConferenceSignupForm" />
18.    <property name="controllerRequestMapping" value="conferenceSignup" />
19.    <property name="footer">
20.      <!-- This will be filled in -->
21.    </property>
22.    <property name="singlePageView" value="true"/>
23.    <property name="viewName" value="default"/>
24.  </bean>                           
25.
26. </beans>
{code}

As promised, in line 17, the View is associated with the ConferenceSignupForm created earlier.  On line 18, the View is associated with the controllerRequestMapping of "conferenceSignup" - which matches the "/conferenceSignup" url we specified in the controller.

On line 10, the view is also given an id.  This id should be unique among all views in the system.  It is used for a number of purposes: it is worked into the actual html "id" attribute for all rendered elements on the page.  Also, if a data model has different views, the viewId can be passed as a url parameter with the id value and override the default view of the form and controller combination:

{code}
/conferenceSignup?viewId=DifferentConferenceSignupView
{code}

This would have the ConferenceSignup form and controller show the page configured by DifferentConferenceSignupView instead. [ JERRY - TRUE THAT? ]  Also, on line 23, the viewName for this View is set to "default", which tells KRAD that ConferenceSignupView is the default View to associated with the ConferenceSignup form and controller [ JERRY - TRUE THAT? ]

On line 11, the title for the page is specified, and on line 22, KRAD is notified that there is only one page associated with this View.

Since this was a one-off page, ConferenceSignupView-parentView, on line 9, extends FormView, the Chronos-like parent bean of all View beans.  Sometimes common View information is shared among many pages - for instance, Inquiries or Lookups.  Further information about how to set up custom view classes is in the [Custom Views|#Custom Views] section.

That leaves lines 12-16 and 19-21 - which the developer has, in comments, promised will be filled in over time.  These are the properties which get the groups which actually display text, buttons, and controls on the page.  Very important properties indeed!  The next section covers what beans will go into those properties.

h1. Splitting into Groups

To complete View configuration, though, the visual design is going to have to be split into group configurations.

There are three big identifiers that a section of a View should be separated into its own Group.  First, if a section has its own header and/or footer, then that visual section needs to be configured into its own Group.  In the page sketch above, we can see there this covers four visual sections: the one labeled Contact Info, the one labeled Members of Party, the one labeled Interests, and the one labeled Academic Institution.  Each has a big header text to separate it from everything else - that's the easiest way to tell that a visual section should be its own group.

The second identifier is if a major visual section may or may not be present on the page.  It has already been decided that "Academic Institution" will be its own group, but too: it is conditional if that Group will be rendered, based on if the Academic Institution checkbox is checked.  Twice over, "Academic Institution" needs to be its own Group.

Finally, Groups have their own autonomous layout.  If a layout drastically changes within a visual section, that's an indicator that a sub-group needs to be created there.  These sub-groups typically lack headers and footers, and therefore, they are added via GroupFields.  In the page sketch, note that the fields for Contact Address break the label on the left, control on the right layout of the rest of the Contact Info Group (the "City" and "State" fields especially).  Therefore, Contact Address is going to have to live within its own GroupField.

What about the buttons at the bottom?  The buttons are special because a View, too, has a header and footer.  The "Submit", "Save", and "Cancel" buttons will all be part of the View's footer.  And it just so happens that the Footer will the the last group which needs to be defined for the page.

[ JERRY - SUGGESTED LAYOUTS? ]
The Groups have been identified.  Next, two determinations need to be made.  First, is the Group a common Group that a definition already exists for?  For instance, common tabs that appear across KRAD documents have Groups already defined in impl/src/main/resources/org/kuali/rice/kns/uif/datadictionary/UifGroupDefinitions.xml, such as Group_DocumentRouteLog (the tab which shows past, current, and future KEW action requests on a document); Group_DocumentNotes (the notes tab); Group_DocumentOverview and Group_DocumentHeader which display the top portions of a document.  More common Group definitions are sure to be created as more functionality is added to KRAD.

Also, there are Groups defined which have certain layouts and certain decorators already applied.  For example, GroupSection_Accordion applies to AccordionDecorator to a Group, making the Group collapsible.  In this case, the user should really be filling everything out, so the collapsible behavior won't be used.  There's also CollectionGroup, a pre-configured Group which provides, for instance, the add line button and correctly labels the add line, and there is CollectionGroupTableLayout which will display a collection in a table layout.  That sounds just great for the "Members of Party" Group.  GroupGridLayout configures a basic grid layout; since the "Contact Information" has two columns of fields, GroupGridLayout is probably necessary there (it isn't configured but the default GridLayout uses two columns).  The Address field, too, has two columns, though the top two address fields span both columns; in any case, this is still GridLayout.  Finally, plainly named GroupSection provides a simple VERTICAL box layout - most of the other Groups need that layout.  The only Group left will be the buttons in the footer; in that case, the layout - a HORIZONTAL box layout - will have be configured manually.  Aw.  However, it will extend the abstract bean definition for Group which does a lot of configuration for every Group that exists in KRAD.

Here's what the View configuration looks like now that the Groups have been added.

{code:xml,title=ConferenceSignupView.xml}
 1. <?xml version="1.0" encoding="UTF-8"?>
 2. <beans xmlns="http://www.springframework.org/schema/beans"
 3.   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
 4.   xmlns:p="http://www.springframework.org/schema/p" 
 5.   xsi:schemaLocation="http://www.springframework.org/schema/beans         
 6.                       http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
 7.
 8.  <bean id="CondferenceSignupView" parent="ConferenceSignupView-parentBean" />
 9.  <bean id="ConferenceSignupView-parentBean" abstract="true" parent="FormView">
10.    <property name="id" value="ConferenceSignupView" />
11.    <property name="title" value="Conference Signup" />
12.    <property name="items">
13.      <list>
14.       <bean parent="ConferenceSignupView-ContactInformationGroup" /> 
15.       <bean parent="ConferenceSignupView-PartyMembersGroup" />
16.       <bean parent="ConferenceSignupView-InterestsGroup" />
17.       <bean parent="ConferenceSignupView-AcademicInformation" /> <!-- eventually, this needs to be conditional -->
18.      </list>
19.    </property>
20.    <property name="renderHeader" value="false" />
21.    <property name="formClass" value="edu.sampleu.conferencesignup.web.spring.form.ConferenceSignupForm" />
22.    <property name="controllerRequestMapping" value="conferenceSignup" />
23.    <property name="footer">
24.      <bean parent="ConferenceSignupView-Footer" />
25.    </property>
26.    <property name="singlePageView" value="true"/>
27.    <property name="viewName" value="default"/>
28.  </bean>                           
29.
30. <bean id="ConferenceSignupView-ContactInformationGroup" parent="GroupGridLayout">
31.   <property name="header.headerText" value="Contact Information" />
32.   <property name="layoutManager.numberOfColumns" value="2" />
33.   <property name="items">
34.     <list>
35.       <!-- this will be filled in in the Fields section -->
36.     </list>
37.   </property>
38. </bean>
39.
40. <bean id="ConferenceSignupView-PartyMembersGroup" parent="CollectionGroupTableLayout">
41.   <property name="header.headerText" value="Members of Party" />
42.   <property name="propertyName" value="conferenceParty.guests" />
43.   <property name="layoutManager.renderSequenceField" value="true" />
44.   <property name="renderAddLine" value="true" />
45.   <property name="collectionObjectClass" value="edu.sampleu.conferencesignup.businessobject.ConferenceGuest" />
46.   <property name="items">
47.     <list>
48.       <!-- this will be filled in in the Fields section -->
49.     </list>
50.   </property>
51. </bean>
52. 
53. <bean id="ConferenceSignupView-InterestsGroup" parent="GroupSection">
54.   <property name="header.headerText" value="Interests" />
55.   <property name="items">
56.     <list>
57.       <!-- this will be filled in in the Fields section -->
58.     </list>
59.   </property>
60. </bean>
61. 
62. <bean id="ConferenceSignupView-AcademicInstitution" parent="GroupSection">
63.   <property name="header.headerText" value="Academic Institution" />
64.   <property name="items">
65.     <list>
66.       <!-- this will be filled in in the Fields section -->
67.    </list>
68.   </property>
69. </bean>
70. 
71. <bean id="ConferenceSignupView-Footer" parent="Group">
72.   <property name="styleClasses" value="wrap" />
73.   <property name="layoutManager">
74.      <bean parent="BoxLayoutManager" p:orientation="HORIZONTAL" />
75.   </property>
76.   <property name="items">
77.     <list>
78.       <!-- this still needs to be filled in! -->
79.     </list>
80.   </property>
81. </bean>
82. 
83. <bean id="ConferenceSignupView-AddressField-Group" parent="GroupGridLayout">
84.   <property name="items">
85.     <list>
86.       <!-- this still needs to be filled in! -->
87.     </list>
88.   </property>
89. </bean>
90. </beans>
{code}

[ JERRY - BEST PRACTICE SPECIFYING TITLES? JAMES - CHECK OUT TRAVEL-TESTVIEW1.PROPERTIES ]

The configuration is certainly getting longer.  There's several areas to focus on.

In lines 12-19, ConferenceSignupView finally has its items to render - four groups, defined below in the page.  Lines 23-25 define the Group to use as the footer, and on line 20, header rendering is turned off (since the mockup does not show a title for this page).

In lines 30-38, the first Group is defined: ConferenceSignupView-ContactInformationGroup, which displays the Contact Information.  A title is specified for the Group via the header.headerText property on line 31.  On line 32, the number of columns on the layout manager (again, a grid layout) is set to be 2 - though this is not strictly necessary, since GridLayout defaults to 2 columns.

ConferenceSignupView-PartyMembersGroup also defines a title and then defines several properties which are unique to CollectionGroups.  On line 42, the property for the collection to render is given; obviously, every CollectionGroup will need to have this set.  Line 43 instructs the TableLayoutManger to render sequence fields so there will be a 1, 2, 3, etc. in front of added members.  Line 44 tells the CollectionGroup that an add line should be rendered - ie, the blank line at the top where more data can be entered.  On line 45, a hint is set to tell KRAD what the class of each object in the collection is; it's best practice to set that. [ JERRY - TRUE THAT? ]

ConferenceSignupView-InterestsGroup and ConferenceSignupView-AcademicInstitution are very simple Groups - Group configuration is actually pretty easy.  ConferenceSignupView-AddressField-Group uses GroupGridLayout; this is two columns, but again, GridLayout defaults to that, so in this case, best practice will be followed and no numberOfColumns will be set.  ConferenceSignupView-Footer has one interesting property: it sets the styleClass to wrap on line 72, so that the rendered HTML will wrap the buttons around if they do not fit within their div.  Also, since the Footer's parent is Group, a layout manager needs to be set.  On lines 73-75, a HORIZONTAL BoxLayoutManager, setting each button side by side, is injected into the Group.

There is one extra point of configuration for ConferenceSignupView-AcademicInstitution worth mentioning: we only want it to appear when the academicInstitution property of ConferenceSignupForm is true.  That is easily accomplished by setting the "conditionalRender" property of the Group:

{code:xml}
 1. <bean id="ConferenceSignupView-AcademicInstitution" parent="GroupSection">
 2.  <property name="conditionalRender" value="@{academicInstitution}"/>
 3.  ...
 4. </bean>
{code}

Line 2 sets the conditionalRender property; if the value for that property turns out to be false, then the Group will not be rendered at all. The value for this property probably looks a bit odd.  The \@\{...\} syntax tells KRAD to make use of Spring Expressions for this value. Basically, \@\{academicInstitution\} will return the value of ConferenceSignupForm.isAcademicInstitution() after all the data has been populated and the ConferenceSignupView-AcademicInstitution will be rendered based on that.  It's pretty slick and covered in much fuller detail in [expressions|#expressions].

[ JERRY - I DON'T SEE "setConditionalRender" ONLY "setConditionalReadOnly" - AM I MISSING SOMETHING? ]

Groups are easy to set up but there's still a fair amount of missing configuration: all of the fields.

h1. Fields

For every label and control, an AttributeField needs to be configured.  Thankfully, if the property the AttributeField maps to an AttributeDefinition within the data object's data dictionary entry, fields can be incredibly easy to configure.  For instance, in the Contact Information Group and in the Address Group which is inside it, there is no need to override the AttributeDefinitions for any of the given fields.  In that case, the two groups can be configured simply as follows:

{code:xml}
 1. <bean id="ConferenceSignupView-ContactInformationGroup" parent="GroupGridLayout">
 2.   <property name="header.headerText" value="Contact Information" />
 3.   <property name="layoutManager.numberOfColumns" value="2" />
 4.   <property name="items">
 5.     <list>
 6.       <bean parent="AttributeField_Form" p:propertyName="conferenceParty.contact.companyName" p:required="true" />
 7.       <bean class="org.kuali.rice.kns.uif.field.BlankField" />
 8.       <bean parent="AttributeField_Form" p:propertyName="conferenceParty.contact.contactName" p:required="true" />
 9.       <bean parent="AttributeField_Form" p:propertyName="conferenceParty.contact.contactEmail" p:required="true" />
10.       <bean parent="GroupField" p:rowSpan="3">
11.         <property name="group">
12.           <bean parent="ConferenceSignupView-AddressField-Group" />
13.         </property>
14.         <property name="labelField">
15.           <bean parent="LabelField">
16.             <property name="labelText" value="Contact Address" />
17.           </bean>
18.         </property>
19.       </bean>
20.       <bean parent="AttributeField_Form" p:propertyName="conferenceParty.contact.contactPhone" p:required="true" />
21.       <bean parent="AttributeField_Form" p:propertyName="academicInstitution" p:label="Academic Institution?" p:labelPlacement="RIGHT">
22.         <property name="control">
23.           <bean parent="CheckboxControl"/>
24.         </property>
25.       </bean>
26.     </list>
27.   </property>
28. </bean>
29. 
30. <bean id="ConferenceSignupView-AddressField-Group" parent="GroupGridLayout">
31.   <property name="items">
32.     <list>
33.       <bean parent="AttributeField_Form" p:propertyName="conferenceParty.contact.addressLine1" p:required="true" p:labelFieldRendered="false" p:colSpan="2"/>
34.       <bean parent="AttributeField_Form" p:propertyName="conferenceParty.contact.addressLine2" p:required="true" p:labelFieldRendered="false" p:colSpan="2"/>
35.       <bean parent="AttributeField_Form" p:propertyName="conferenceParty.contact.city" p:required="true"/>
36.       <bean parent="AttributeField_Form" p:propertyName="conferenceParty.contact.state" p:required="true"/>
37.     </list>
38.   </property>
39. </bean>
{code}

Already, there's a lot going on. However, it's all very straightforward stuff.  Let's start with ConferenceSignupView-AddressField-Group.  Basically, every Group is defined by the items which sit inside it.  In the case of ConferenceSignupView-AddressField-Group, there are four fields (lines 33-36).  Each has a parent bean of AttributeField_Form.  Be careful in choosing a parent of AttributeFields.  There are two very common ones: AttributeField and AttributeField_Form; AttributeField_Form extends AttributeField but turns on binding for the properties they display.  That's very important for forms like this (less important for, say, Groups in InquiryViews which are read only).

Each AttributeField_Form has a propertyName set, with the path from the form class to the attribute which should be displayed.  These fields are all required, so the required property has been set to true for all; it defaults to false.  Looking through the configuration for ConferenceSignupView-ContactInformationGroup, practically all the AttributeField_Forms defined share these properties.

Lines 33 and 34 have two extra properties, though.  p:labelFieldRendered="false" tells KRAD not to render a label for these fields; the mockup doesn't have a label so none should be rendered.  Also, the colSpan for each of these fields has been set to 2, so that the control spans the width of both grid columns [ JERRY - SHOULD THAT HAVE BEEN 4? ]

On line 7, there's an interesting field: org.kuali.rice.kns.uif.field.BlankField.  This field simply fills out a space in the grid, pushing down the contactName attribute to the next line as the mockup shows.

Since the address is its own group, there needs to be a way to embed that group within the parent group.  Groups embedded within other Groups needed to be embedded first into a GroupField, as was done above in lines 10-19.  Simply inject the Group to be inside the Field (lines 11-13).  In this case, a LabelField is also added (lines 14-18) so that the word "Address" shows up next to the field.  Since this Group should take up three rows of the grid, a rowSpan of 3 is set on line 10.

That works for all the fields which have been defined in AttributeFields.  However, the academicInstitution property was declared on the form - it has no AttributeDefinition associated with it in the data dictionary.  In this case, the AttributeField_Form must be created "from scratch"; all the information KRAD needs to know about the attribute will be defined in the AttributeField_Form definition: including the control for the attribute (a checkbox, just as the mockup indicates), the label for the attribute, and since the label goes to the right of the checkbox, the labelPlacement property has been set to "RIGHT" ("LEFT" is the default; "TOP" and "BOTTOM" are also valid choices). [ JERRY - ANY MISSED REQUIRED FIELDS IN THAT DEFINITION? ]

Just as an AttributeField can be created without an AttributeDefinition - as the academicInstitution property did - an AttributeField can be used to override any property. For example, in line 36 above, the state is shown.  Let's say that the control for the state is a text field - whereas the bizarre down arrow on the mockup seems to suggest that a drop down was intended.  That can be easily overridden as so:
{code:xml}
35.       <bean parent="AttributeField_Form" p:propertyName="conferenceParty.contact.city" p:required="true"/>
36.       <bean parent="AttributeField_Form" p:propertyName="conferenceParty.contact.state" p:required="true">
37.          <property name="control">
38.            <bean parent="SelectControl">
39.              <property name="options">
40.                <bean class="StateCodeNameList" />
41.              </property>
42.            </bean>
43.          </property>
44.        </bean>
45.     </list>
{code}

Of course, a bean with the id StateCodeNameList and the KeyLabelPairs for all the state codes will need to be defined.  That would look something like:

{code:xml}
<bean id="StateCodeNameList" class="org.springframework.beans.factory.config.ListFactoryBean">
  <property name="sourceList">
    <list>
      <bean class="org.kuali.rice.core.util.KeyLabelPair" p:label="">
        <property name="key">
          <null />
        </property>
      </bean>
      <bean class="org.kuali.rice.core.util.KeyLabelPair" p:key="AK" p:label="AK" />
      <bean class="org.kuali.rice.core.util.KeyLabelPair" p:key="AL" p:label="AL" />
      <bean class="org.kuali.rice.core.util.KeyLabelPair" p:key="AR" p:label="AR" />
      <bean class="org.kuali.rice.core.util.KeyLabelPair" p:key="AZ" p:label="AZ" />
      ... there are a lot of states. like fifty, and territories on top of that ...
      <bean class="org.kuali.rice.core.util.KeyLabelPair" p:key="WY" p:label="WY" />
    </list>
  </property>
</bean>
{code}

What about errors? There needs to be some way for the ConferenceSignupView-ContactInformationGroup to display errors associated with the attributes inside the Group.

Since errors are rendered in a specific location in the Group - below the header but above any attributes - Groups have a special property called "errorsField" which allows an instance of org.kuali.rice.kns.uif.field.ErrorsField to be declared for the Group.  The "Group" bean which all Groups inherit from actually defines an "ErrorsField_Group" to put into the errorsField.  KRAD will automatically keep track of which attributes are rendered in the Group and associate error keys with them - no additional work is necessary beyond the configuration above.

Of course, if there's a need to configure additional error keys, that can be done by overriding the errorsField property and in the extension of the "ErrorsField_Group" bean, setting the "addtionalKeysToMatch" property. This property uses the same wildcard system that was used in the KNS; for instance, the key "attendees*" will match any error which has an attribute that starts with the name "attendees", such as "attendees.firstName".  Be aware, as well, that Views have errorFields associated as well which can have the same property overridden.

Since there's no extra configuration for errors, that does it for the "Contact Information Group" and the Address GroupField within it.  Next is the PartyMembersGroup.  That configuration is as follows:

{code:xml}
 1. <bean id="ConferenceSignupView-PartyMembersGroup" parent="CollectionGroupTableLayout">
 2.   <property name="header.headerText" value="Members of Party" />
 3.   <property name="propertyName" value="conferenceParty.guests" />
 4.   <property name="layoutManager.renderSequenceField" value="true" />
 5.   <property name="renderAddLine" value="true" />
 6.   <property name="collectionObjectClass" value="edu.sampleu.conferencesignup.businessobject.ConferenceGuest" />
 7.   <property name="items">
 8.     <list>
 9.       <bean parent="AttributeField_Form" p:propertyName="name" p:required="true" />
10.       <bean parent="AttributeField_Form" p:propertyName="email" p:required="true" />
11.       <bean parent="AttributeField_Form" p:propertyName="phone" p:required="true" />
12.     </list>
13.   </property>
14. </bean>
{code}

The twist here is that all of the AttributeField_Form property names (lines 9-11) are relative not the form - as was the case with ContactInformation - but relative to the ConferenceGroup object. [ JERRY - TRUE THAT? ]  This only makes sense: since each of the items will be shown once per line, the full attribute propertyName is not really known at configuration time.  However, since the propertyName for the CollectionGroup in general is "conferenceParty.guests", KRAD knows it needs to iterate over all of those objects, and thus, for the items that will display on each line, only the property name relative to that is necessary.

Jumping ahead, the Footer needs some interesting configuration since it doesn't have any attributes at all, but rather buttons. What does the configuration for that look like?

{code:xml}
 1. <bean id="ConferenceSignupView-Footer" parent="Group">
 2.   <property name="styleClasses" value="wrap" />
 3.   <property name="layoutManager">
 4.      <bean parent="BoxLayoutManager" p:orientation="HORIZONTAL" />
 5.   </property>
 6.   <property name="items">
 7.     <list>
 8.       <bean parent="ActionField" p:methodToCall="submit" p:actionLabel="Submit"/>
 9.       <bean parent="ActionField" p:methodToCall="save" p:actionLabel="Save"/>
10.       <bean parent="ActionField" p:methodToCall="cancel" p:actionLabel="Cancel"/>
11.     </list>
12.   </property>
13. </bean>
{code}

The only difference between the fields in this Group and the AttributeField_Forms of other Groups is that these fields are extensions of the ActionField bean (lines 8-10).  Two properties need to be set.  The methodToCall, of course, makes sure that the button adds a "methodToCall" parameter with the request, which the controller we defined above then leverages to figure out which controller method to call.  Buttons have been defined here for each of the three controller methods: submit, save, and cancel.  Also, an actionLabel property needs to be defined; that label is the text which is rendered on the button itself.

[ JERRY - HOW TO GET ACADEMICINSTITUTION CHECKBOX TO REFRESH FORM ONCE IT IS CLICKED OR UNCLICKED ]

Here's the full configuration once the fields are added:

{code:xml,title=Complete ConferenceSignupView.xml}
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
       xmlns:p="http://www.springframework.org/schema/p" 
       xsi:schemaLocation="http://www.springframework.org/schema/beans         
                       http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

<bean id="CondferenceSignupView" parent="ConferenceSignupView-parentBean" />
<bean id="ConferenceSignupView-parentBean" abstract="true" parent="FormView">
<property name="id" value="ConferenceSignupView" />
  <property name="title" value="Conference Signup" />
  <property name="items">
    <list>
     <bean parent="ConferenceSignupView-ContactInformationGroup" /> 
     <bean parent="ConferenceSignupView-PartyMembersGroup" />
     <bean parent="ConferenceSignupView-InterestsGroup" />
     <bean parent="ConferenceSignupView-AcademicInformation" /> <!-- eventually, this needs to be conditional -->
    </list>
  </property>
  <property name="renderHeader" value="false" />
  <property name="formClass" value="edu.sampleu.conferencesignup.web.spring.form.ConferenceSignupForm" />
  <property name="controllerRequestMapping" value="conferenceSignup" />
  <property name="footer">
    <bean parent="ConferenceSignupView-Footer" />
  </property>
  <property name="singlePageView" value="true"/>
  <property name="viewName" value="default"/>
</bean>                           

<bean id="ConferenceSignupView-ContactInformationGroup" parent="GroupGridLayout">
 <property name="header.headerText" value="Contact Information" />
 <property name="layoutManager.numberOfColumns" value="2" />
 <property name="items">
   <list>
     <bean parent="AttributeField_Form" p:propertyName="conferenceParty.contact.companyName" p:required="true" />
     <bean class="org.kuali.rice.kns.uif.field.BlankField" />
     <bean parent="AttributeField_Form" p:propertyName="conferenceParty.contact.contactName" p:required="true" />
     <bean parent="AttributeField_Form" p:propertyName="conferenceParty.contact.contactEmail" p:required="true" />
     <bean parent="GroupField" p:rowSpan="3">
       <property name="group">
         <bean parent="ConferenceSignupView-AddressField-Group" />
       </property>
       <property name="labelField">
         <bean parent="LabelField">
           <property name="labelText" value="Contact Address" />
         </bean>
       </property>
     </bean>
     <bean parent="AttributeField_Form" p:propertyName="conferenceParty.contact.contactPhone" p:required="true" />
     <bean parent="AttributeField_Form" p:propertyName="academicInstitution" p:label="Academic Institution?" p:labelPlacement="RIGHT">
       <property name="control">
         <bean parent="CheckboxControl"/>
       </property>
     </bean>
   </list>
 </property>
</bean>
 
<bean id="ConferenceSignupView-AddressField-Group" parent="GroupGridLayout">
 <property name="items">
   <list>
     <bean parent="AttributeField_Form" p:propertyName="conferenceParty.contact.addressLine1" p:required="true" p:labelFieldRendered="false" p:colSpan="2"/>
     <bean parent="AttributeField_Form" p:propertyName="conferenceParty.contact.addressLine2" p:required="true" p:labelFieldRendered="false" p:colSpan="2"/>
     <bean parent="AttributeField_Form" p:propertyName="conferenceParty.contact.city" p:required="true"/>
     <bean parent="AttributeField_Form" p:propertyName="conferenceParty.contact.state" p:required="true"/>
   </list>
 </property>
</bean>

<bean id="ConferenceSignupView-PartyMembersGroup" parent="CollectionGroupTableLayout">
 <property name="header.headerText" value="Members of Party" />
 <property name="propertyName" value="conferenceParty.guests" />
 <property name="layoutManager.renderSequenceField" value="true" />
 <property name="renderAddLine" value="true" />
 <property name="collectionObjectClass" value="edu.sampleu.conferencesignup.businessobject.ConferenceGuest" />
 <property name="items">
   <list>
     <bean parent="AttributeField_Form" p:propertyName="name" p:required="true" />
     <bean parent="AttributeField_Form" p:propertyName="email" p:required="true" />
     <bean parent="AttributeField_Form" p:propertyName="phone" p:required="true" />
   </list>
 </property>
</bean>

<bean id="ConferenceSignupView-InterestsGroup" parent="GroupSection">
 <property name="header.headerText" value="Interests" />
 <property name="items">
   <list>
     <!-- [ JERRY - I AM COMPLETELY UNSURE OF THIS ONE. MAYBE I SHOULD GET RID OF IT? ] -->
   </list>
 </property>
</bean>

<bean id="ConferenceSignupView-AcademicInstitution" parent="GroupSection">
 <property name="conditionalRender" value="\@\{academicInstitution\}"/>
 <property name="header.headerText" value="Academic Institution" />
 <property name="items">
   <list>
     <bean parent="AttributeField_Form" p:propertyName="conferenceParty.academicInstitutionInformation.institutionFundingTypeCode" />
     <bean parent="AttributeField_Form" p:propertyName="conferenceParty.academicInstitutionInformation.name" />
     <bean parent="AttributeField_Form" p:propertyName="conferenceParty.academicInstitutionInformation.numberOfStudents" />
  </list>
 </property>
</bean>

<bean id="ConferenceSignupView-Footer" parent="Group">
 <property name="styleClasses" value="wrap" />
 <property name="layoutManager">
    <bean parent="BoxLayoutManager" p:orientation="HORIZONTAL" />
 </property>
 <property name="items">
   <list>
     <bean parent="ActionField" p:methodToCall="submit" p:actionLabel="Submit"/>
     <bean parent="ActionField" p:methodToCall="save" p:actionLabel="Save"/>
     <bean parent="ActionField" p:methodToCall="cancel" p:actionLabel="Cancel"/>
   </list>
 </property>
</bean>
</beans>
{code}

And with that, a new KRAD View has been created!  [ JERRY - TRUE THAT? ]

h1. Common Cases

Some Views have a common look throughout all KRAD applications.  These views were generally treated specially in the Nervous System, so that configuration for them was easy to accomplish - since these views always looked the same, much could be standardized.  However, as KC and KFS were built, there were often attempts to expand beyond what the standard configuration provided: maintenance documents could show tags, for instance, and lookups could be configured to give fairly different looks.  This created a tension in KNS applications: stay with standard, plain vanilla views or complicated to configure free-for-all views.

KRAD mitigates this tension.  It provides base Views for the standard KNS pages which make configuration of a standard version a snap.  At the same time, though, these custom Views are simply Views - they can be traded out for more complex Views.  Because such choices can be made on the basis of each data object, a great deal of freedom has been granted the developer.

Each standard View will be explored.

h2. Inquiry

Inquiries are read only presentations of reference data.  In the search results for lookups, fields from a DataObject will be linked - those links open the Inquiry views for the DataObject itself or related DataObjects.

Most inquiries, therefore, are pretty simple affairs: tabs with two columns - a label column and the read only value.  And configuration for the InquiryView is standard as well.  Each InquiryView should set an id (as is standard with Views) and a title.  It should also set a dataObjectClassName, the name of the class this particular inquiry will work for.  Finally, the groups which make up the Inquiry should be set with an AttributeField for each attribute to display.  Here's a simple example from the Travel sampleapp which comes as part of the Rice distribution (slightly simplified; at the time of this writing, the actual example in Rice uses multiple pages for the inquiry):

{code:xml}
 1. <bean id="FiscalOfficerInfo-InquiryView" parent="InquiryView">
 2.   <property name="title" value="Fiscal Officer Inquiry"/>
 3.   <property name="dataObjectClassName" value="edu.sampleu.travel.dto.FiscalOfficerInfo"/>
 4.   <property name="viewHelperServiceClassName" value="edu.sampleu.travel.service.FiscalOfficerInfoInquiryViewHelperServiceImpl" />
 5.   <property name="singlePageView" value="true"/>
 6.   <property name="items">
 7.     <list>
 8.       <ref bean="InquiryView-information"/>
 9.       <ref bean="InquiryView-accounts"/>
10.     </list>
11.   </property>
12. </bean>
13.  
14. <bean id="InquiryView-information" parent="GroupSectionGridLayout">
15.   <property name="layoutManager.numberOfColumns" value="2"/>
16.   <property name="items">
17.     <list>
18.       <bean parent="AttributeField" p:propertyName="id"/>
19.       <bean parent="AttributeField" p:propertyName="userName"/>
20.     </list>
21.   </property>
22.   <property name="title" value="Fiscal Officer Information"/>
23. </bean>
24.
25. <bean id="InquiryView-accounts" parent="CollectionGroupSectionTableLayout" p:layoutManager.numberOfColumns="3">
26.   <property name="title" value="Travel Accounts"/>
27.  	<property name="collectionObjectClass" value="edu.sampleu.travel.dto.TravelAccountInfo"/>
28.  	<property name="propertyName" value="accounts"/>
29.  	<property name="summary" value="Travel Accounts for Fiscal Officer"/>
30.  	<property name="layoutManager.sequencePropertyName" value="number"/>
31.  	<property name="items">
32.  	  <list>
33.  	    <bean parent="AttributeField" p:propertyName="number"/>
34.  	    <bean parent="AttributeField" p:propertyName="name"/>
35.  	    <bean parent="AttributeField" p:propertyName="createDate"/>
36.  	  </list>
37.  	</property>           
38. </bean>
{code}

Lines 1 through 12 build the basic InquiryView, extending the InquiryView bean.  Line 2 sets the title for the Inquiry; line 3 sets the class name of the dataObject class this will display read only information for; and line 4 sets the Inquirable class.  The View has only a single page and then in lines 6-11, the Groups for the View are set to be InquiryView-information and InquiryView-accounts.

One line 13, notice how blank the line is.  It's so completely blank.  Contrast this with line 24 which seems far less blank.

Both InquiryView-information and InquiryView-accounts are normal Groups of the type we're completely used to by now.  InquiryView-information shows a grid with the default 2 columns (line 15 makes sure that 2 columns are set in any case) and then has the AttributeFields to show in the Group: id and userName. Line 22 sets the title for this Group.

InquiryView-accounts is a CollectionGroup, as accounts are a Collection property on the edu.sampleu.travel.dto.FiscalOfficerInfo DataObject.  Here a title is set as well as a summary for the collection.  On line 27, the class for each Data Object in the Collection is specified and on line 28, the property where the Collection can be found in the parent object is set.  This example has the layoutManager keep track of a sequence for every line which will be stored in the variable "number".  Lines 31 through 37 set the AttributeFields, just like always: number, the sequence from the LayoutManager is shown, followed by the name of the account and the creation date.

There are a couple differences between the properties to set on InquiryView versus those that were set in KNS InquiryDefinitions.  The biggest difference, quickly covered in the example above, is how to set the Inquirable implementation.  InquiryView's property which holds the Inquirable implementation is viewHelperServiceClassName.  Inquirables are the ViewHelperServices for Inquiry views - so the work that is done during the rendering lifecycle by the ViewHelperService can be overridden in any Inquirable.  [ WHY OVERRIDE INQUIRABLE ANYMORE? ]

InquiryViews can also have custom presentationControllerClass and authorizerClass properties set to determine what values to hide and show on the Inquiry.  The page and footer property are pre-injected with the standard PageInquiry and FooterInquiry groups but if wildly different looks are necessary, these Groups can be overridden.

[ JERRY - LIGHTBOX? ]

h2. Lookup

Inquiry Views display the read only fields for a DataObject.  Certainly, child collections and sub-collections may complicate things but it's all fairly easy.  The LookupView is a bit more complicated as a View type.  Here we have the classic set of fields and labels which allow the user to search among all the members of a given DataObject; once the search is complete, a CollectionGroup of results are display - assuming the search found some matching records, of course.

LookupViews also give us a much better example of why one would create a custom standard View.  LookupView has a property for the dataObjectClassName just as InquiryView does.  But it has four interesting properties defined after that:
* criteriaGroup - a Group of Fields which form the criteria part of the LookupView (where fields are queried for certain values)
* resultsGroup - a CollectionGroup which displays the rows for the results
* resultsActionsField - the Field which contains the actions available on each line of the results
* resultsReturnField - the Field which contains the action available for returning each line of the results to a previous screen

Why are these four specific properties available?  Because the look of the LookupView is standard and it has two major visual sections: the criteria section and the results section.  Each results row may have actions to handle that row (for instance, if looking up a data object with a related maintenance document, edit and copy links are typically available).  If the results row was looked up in a quick finder, then there needs to be an action to return the value of the current row back to the calling screen.  Because the vast majority of lookups have these standard visual regions, LookupView has properties that correspond.

The standardization goes even beyond that.  In KNS applications, criteria for lookups always have a set look, as do the results.  Instead of defining that look in a Group, one can just enter the fields that are part of the CriteriaGroup into a special property, criteriaFields. Likewise, one can enter the fields to display on each result row in a special list, resultFields.  This makes configuration of LookupView feel a lot more like a KNS LookupDefinition.  The choice is up to the developer - utilize the absolute freedom of Groups or make use of the standard approach which is quicker to configure.

There are two more special properties left on LookupView.  First: defaultSortAttributeNames corresponds to LookupDefinition's defaultSort; if using the standard lookup mechanism, it configures the sort keys for the rows.  Second: sortAscending...which direction should the attributes be sorted in; the default is ascending.

Here's an example of the configuration for a LookupView, taken from the sample app:

{code:xml}
 1. <bean id="FiscalOfficerInfo-LookupView" parent="LookupView">
 2.   <property name="title" value="Fiscal Officer Lookup" />
 3.   <property name="dataObjectClassName" value="edu.sampleu.travel.dto.FiscalOfficerInfo" />
 4.   <property name="viewHelperServiceClassName" value="edu.sampleu.travel.service.FiscalOfficerInfoLookupViewHelperServiceImpl" />
 5.   <property name="criteriaFields">
 6.     <list>
 7.       <bean parent="LookupCriteriaAttributeField" p:propertyName="id" />
 8.       <bean parent="LookupCriteriaAttributeField" p:propertyName="userName" />
 9.     </list>
10.   </property>
11.   <property name="resultFields">
12.     <list>
13.       <bean parent="AttributeField" p:propertyName="id" />
14.       <bean parent="AttributeField" p:propertyName="userName" />
15.     </list>
16.   </property>
17. </bean>
{code}

Just as the Inquirable in InquiryView is set through the viewHelperServiceClassName, the ViewHelperService for all lookups is the implementation of org.kuali.rice.kns.uif.service.LookupViewHelperService for the lookup.  (LookupViewHelperService is an amalgamation of the KNS LookupableHelperService and Lookupable).  That is set on line 4.

Note that this configuration decided to make use of the standard criteria and results look and feel attributes: criteriaFields (lines 5-10) and resultFields (lines 11-16) were configured instead of setting criteriaGroup and resultGroup.

[ DOES THIS SUPPORT MULTI-VALUE LOOKUPS?  JUST CURIOUS... ]

h2. MaintenanceView

Compared to LookupView, MaintenanceView, the custom standard View for maintenance documents, is very simple.  It extends a custom standard View called DocumentView, which stores the class of the document and several properties associated with displaying notes (boolean allowsNoteAttachments, boolean allowsNoteFYI, boolean displayTopicFieldInNotes, and Class<? extends KeyValuesFinder> attachmentTypesValuesFinderClass).  

MaintenanceView then adds a handful of its own properties.  dataObjectClassName is the name of the class of the data object being maintained by the maintenance document.  If the maintenance document represents an edit or copy of an existing data object, oldObjectBindingPath should be set (KRAD should do this automatically [ JERRY - TRUE THAT? ]) to the path to the existing version of the object to display.

Here's the configuration, again taken from the sample app: the MaintenanceView for the FiscalOfficerInfo data object:

{code:xml}
 1. <bean id="FiscalOfficerInfo-MaintenanceView" parent="MaintenanceView">
 2.   <property name="title" value="Fiscal Officer Maintenance" />
 3.   <property name="dataObjectClassName" value="edu.sampleu.travel.dto.FiscalOfficerInfo" />
 4.   <property name="viewHelperServiceClassName" value="edu.sampleu.travel.service.FiscalOfficerInfoMaintainableImpl" />
 5.   <property name="items">
 6.     <list merge="true">
 7.       <bean parent="MaintenanceGroupSectionGridLayout">
 8.         <property name="items">
 9.           <list>
10.             <bean parent="AttributeField" p:propertyName="id" />
11.             <bean parent="AttributeField" p:propertyName="userName" />
12.           </list>
13.         </property>
14.         <property name="title" value="Fiscal Officer Information" />
15.       </bean>
16.       <bean parent="MaintenanceCollectionGroupSection">
17.         <property name="title" value="Fiscal Officer Accounts"/>  
18.         <property name="collectionObjectClass" value="edu.sampleu.travel.dto.TravelAccountInfo"/>
19.         <property name="propertyName" value="accounts"/>
20.         <property name="items">
21.           <list>
22.             <bean parent="AttributeField" p:propertyName="number"/>
23.             <bean parent="AttributeField" p:propertyName="name"/>
24.           </list>
25.         </property>   
26.         <property name="layoutManager.summaryTitle" value="Travel Account"/> 
27.         <property name="layoutManager.summaryFields">
28.           <list>
29.             <value>number</value>
30.           </list>
31.         </property>
32.       </bean>
33.      </list>
34.    </property>
35.  </bean>
{code}

The MaintenanceView is simple; the configuration is a wee bit complex but easy to follow.

Line 2 contains the title for the View.  Line 3 sets the name of the class of data object that is being maintained.  Once again, the Maintainable implementation is injected into the viewHelperServiceClassName property one line 4.

In items, the sections are set out.  There are two sections.  The first (lines 7-15) allows the editing of the FiscalOfficerInfo's id and userName.  The parent of this Group is MaintenanceGroupSectionGridLayout - the standard look and feel for a Maintenance document's fields.  The second Group (lines 16-31) is a MaintenanceCollectionGroupSection and this Group requires some extra configuration.

For the MaintenanceCollectionGroupSection, the collectionObjectClass is set (line 18) to TravelAccountInfo - the class of the collection being maintained.  Line 19 sets the name of the property on FiscalOfficerInfo where the collection could be found.  Lines 20 through 25 are the items which will be editable on every line of the collection.  On lines 26 through 31, the summaryTitle and summaryFields properties are set.  Every object in a collection on a maintenance document has a header; the header will display with the summaryTitle plus the values of the summaryFields properties.  summaryFields are typically the primary key for the child object.  Given that, a newly added TravelAccountInfo on the document may have a header line which reads "Travel Account 30033" for a TravelAccountInfo with a number of 3033.

This offers an interesting contrast with LookupView.  While LookupView had specific properties at the View level that helped set look and feel, MaintenanceView does not have much at the View level but expects the use of Groups which will display in the standard look and feel.  Either response is appropriate in different contexts.  These kinds of questions must be answered when an application creates its own custom standard View.

h2. {anchor}Custom Views{anchor}

Can applications create their own custom specialized Views?  Certainly - in fact, that's expected.  KFS, for instance, may have an AccountingDocumentView, since a vast number of KFS's transactional documents have a unified look and feel which presents accounting lines.  Indeed, most applications will have a set of documents or pages which share a look and feel, where it would be nice to standardize the configuration of the View.  Given that, the creation of standard specialized Views is not going to be uncommon at all. But what goes in to making a custom View?

Mostly thought.  As we saw above, there are a number of different places where a standard look and feel can be injected.  It's up to the developers of a custom standard View to figure out if the visual elements are standard at the View level or the Group level.

Take, for instance, the case of KFS's batch upload pages.  All of these pages look almost precisely alike: a title for the upload (which is taken care of by View title in any case); and then one Group which has controls allowing the upload of the file and a file identifier, plus an add label and an "add" button.  The "add" button is perhaps misleading - there is no collection here; if the file upload was acceptable, the form redisplays itself with all fields cleared.

(There is a variation where two files are uploaded; this would likely be an extension of the BatchUploadView currently being proposed.)

How are batch upload pages configured?  Currently, a Spring bean is passed in which represents an implementation of the org.kuali.kfs.sys.batch.BatchInputFileType interface.  The name of that bean is passed in to the BatchUploadAction via the batchUpload.batchInputFileTypeName property.  From there, BatchUploadAction and the corresponding JSP are able to configure the page.

This brings us to question number one: is this custom standard View or a set of custom standard Groups?  In this case, we have one Group and that's it; and every batch upload file has precisely the same Group.  Because of this, BatchUploadView makes a lot more sense than having several different Views with a single BatchUploadGroup.

(Likewise, KFS's accounting documents will probably be opposite: there will likely be an AccountingLineGroup; if a standard AccountingLineView does exist, it probably won't do very much on its own, much like MaintenanceView.)

Continuing this thought exercise, what properties belong on BatchUploadView?  The first property we need is the name of the BatchInputFileType implementation bean.  The title attribute would probably be removed from that bean and simply set on the View itself.  In terms of visual components on each View, really, there's just the BatchUploadGroup.  The BatchUploadGroup could be built from the information held on the BatchInputFileType bean, and the View would likely add it to the top of the items list automatically in BatchUploadView#performInitialization (reference LookupView#performInitialization for a similar use case).

BatchUploadView is a very simple View, and yet it's going to make it much easier for developers to maintain a consistent look and feel across the application for the same functionality.  This is the big win for custom standard Views - making it easy to configure a standard look and feel and not having to reinvent the wheel for each similar page.

h1. {anchor:expressions}Using Expressions in Views{anchor}

As seen in our example above, using expressions within the View leads to some powerful new configuration possibilities.  Above, of course, we simply turned on or off rendering of the "Academic Institution" Group based on whether the "Academic Institution" checkbox was checked.  There are many other uses for expressions as well.

All of the expressions in KRAD are uses of the [Spring Expression Language|http://static.springsource.org/spring/docs/3.0.5.RELEASE/reference/expressions.html].  Spring's documentation does an excellent job of presenting how to use the expression language.  However, there are some elements of its use in KRAD which are very unique.  Let's cover those.

h2. Contexts

First things first.  Uses of Spring Expression Language typically have a context from which properties are evaluated.  When defining a View or Group in KRAD, that implicit context is the form associated with the View.  This means that expressions will not be evaluated until the form is populated with data.  From the example above, when we set the property conditionalRender to \@\{acadmicInstituion\} in ConferenceSignupView-AcademicInstitution Group, that was actually going to call ConferenceSignupForm.isAcademicInstitution().  Properties are nestable; for example, we could have checked \@\{\} for some reason (it's not a boolean, so it would have made conditionalRender blow up).  And again, the \@\{...\} syntax is KRAD's way of knowing that a value for a property is actually an expression which needs to be evaluated after the model has been applied.  [ JERRY - WHICH LIFECYCLE DO EXPRESSIONS GET EVALUATED IN?  FINALIZATION OR APPLY MODEL? ]

The most basic use of expressions is to template into String properties.  For instance, let's say a view had the following configuration:

{code:xml}
 1. <bean id="ExpressionView" parent="View">
 2.   <property name="title" value="Hello @{contact.firstName}"/>
 3. </bean>
{code}

In this case, getContact().getFirstName() would be called against the form and the value returned would be templated into the title.  Let's say, getContact().getFirstName() returned "Jerry"; in that case, the title of the View would be "Hello Jerry".  Of course, maybe the user hasn't entered getContact().getFirstName() into the form yet.  The expression can be updated to be a bit more neutral if getContact().getFirstName() returns null or an empty String:

{code:xml}
 1. <bean id="ExpressionView" parent="View">
 2.   <property name="title" value="@{contact.firstName == null or contact.firstName == '' ? 'Welcome' : 'Hello '+contact.firstName}"/>
 3. </bean>
{code}

Here, the built in ternary operator is used to return "Welcome" if there is no first name, or "Hello, \@\{contact.firstName\}" if the firstName is populated. The expression language can be pretty powerful.

h2. Conditions, Revisited

At the time of this writing, there are two conditions which can be specified for any Component: conditionalReadOnly and conditionalRender.

[ HERE JAMES ]

h3. Conditions versus Presentation Controllers and Authorizers
h2. Special Variables
h2. Overriding variables via the request

[ HERE JAMES ]

The addition of the Spring expression language into KRAD leads to some powerful configuration techniques.  It's well worth looking into these features as well as reading [Spring's Own Documentation|http://static.springsource.org/spring/docs/3.0.5.RELEASE/reference/expressions.html] on the subject.

h1. {anchor}View Helper Services{anchor}

Customization can also be carried out by creating a custom implementation of org.kuali.rice.kns.uif.service.ViewHelperService.  This service is responsible for acting on a View while it goes through its four major stages of rendering:

* population of View from the request - carried out by populateViewFromRequestParameters.  In the default implementation in org.kuali.rice.kns.uif.service.impl.ViewHelperServiceImpl, reflection is used to find any properties on the View that have a @RequestParameter annotation.  For those properties, the parameter is sought in the Request and if found, the View is populated with that parameter.  This is overridden by org.kuali.rice.kns.uif.service.impl.LookupViewHelperServiceImpl to set all the request parameters on the LookupView itself to act as search keys.
* initialization - carried out by performInitialization.  This simply calls performComponentInitialization  on the View itself; this, in turn has the View perform its own initialization (which initializes the layout manager and sets up the single page view if one exists).  Then all nested components are initialized recursively.  This, by the way, is where AttributeFields have any missing data populated from corresponding AttributeDefinitions.
* applying the model - carried out by performApplyModel.  This invokes the presentationController and authorizer on the View and then calls the apply model on the View itself.
* finalization - carried out by performFinalize.  Calls performComponentFinalize on the View, which basically finalizes nested Components.

There should be very few cases where a custom ViewHelperService implementation is necessary.  Already with the standard Views, very few customizations have been made at the ViewHelperService level.  However, every component also participates in the View rendering lifecycle; each Component - such as a new Field, Widget, or customized Group - has a chance to use the lifecycle hooks to customize behavior.

What would a Component do in the override of a View lifecycle method?  Let's take a look at each method and see some customizations.

h2. Component#performInitialization

Component#performInitiation is easily the most overridden life cycle method.  Each of the standard Views above utilize it, along with ContainerBase and several other children of Component.  What all do these Components do in initialization?

Most of the overrides make a lot of sense - it takes some preparation before a Component is ready for the model to be applied.  For instance, in Group's override of performInitialization, it goes through all sub-children to find AttributeFields and GroupFields; any GroupFields and AttributeFields with missing bindByNamePrefixes have those bindByNamePrefixes set.  That's terribly important; the model wouldn't be able to set properties correctly for those values if they weren't set before the Apply Model phase occurred.  AttributeField#performInitialization is also concerned with setting binding properties correctly before Apply Model.  MaintenanceView, InquiryView, and LookupView all override performInitialization to set the defaultBindingsObjectPath.

While setting bindings before Apply Model is a big concern in the Initialization phase, there are other reasons to override performInitialization as well.  ContainerBase#performInitialization initializes the LayoutManager and sorts the contained items.  ActionField overrides performInitialization to set its actionLabel, the text shown on the button or link itself.

Anything which needs to be completed before Apply Model should happen in performInitialization, as well as anything that does not need the model information to be completed.

h2. Component#performApplyModel

In opposition to Component#performInitialization, practically no Components override Component#performApplyModel.  At the time of this writing only three UIF Components in Rice do anything with this method.  ContainerBase overrides it to tell the LayoutManager to perform the Apply Model phase.  CollectionGroup overrides it because, now that it has all of the data in its collection, it can use its set CollectionGroupBuilder to add the addLine to the collection if necessary and then set all of the indexed binding properties.  LookupView overrides performApplyModel to add actions to results lines.

The big theme here is performing any major data changing alterations of the model data held by the Component before performFinalize occurs.  Those cases are rare indeed.

h2. Component#performFinalize

Component#performFinalize may not be overridden quite as often as performInitialize but it's not too far behind.

A number of Widgets override performFinalize to create sub-fields now that the Widget has the data that it needs to act upon set.  A handful of Fields override performFinalize as well.  ActionField overrides it to set the methodToCall parameter associated with the button.  Since that parameter often is associated with data from parameters, that data must be completely set before performFinalize can occur.  AttributeField overrides performFinalize to set up ids on sub-components - such as the Control, ErrorsField, and LabelField - and associates client side javascript constraints with the AttributeField

The major theme with performFinalize is that all the data must be set before these changes can be made.  During the Apply Model phase, there still a chance that sub-components or other components on the page will change the data associated with the Component.  That's all done when performFinalize occurs and since all the data is stable, performFinalize gives Components a chance to set aspects that needed to know about data.

And that concludes this introductory View tutorial.